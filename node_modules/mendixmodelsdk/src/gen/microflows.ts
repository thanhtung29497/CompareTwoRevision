/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import {common} from "../common";

import {projects} from "./projects";

export namespace microflows {

	export class ActionActivityColor extends internal.IEnum {
		public static Default: ActionActivityColor = new ActionActivityColor("Default", { });
		public static Red: ActionActivityColor = new ActionActivityColor("Red", { });
		public static Orange: ActionActivityColor = new ActionActivityColor("Orange", { });
		public static Yellow: ActionActivityColor = new ActionActivityColor("Yellow", { });
		public static Green: ActionActivityColor = new ActionActivityColor("Green", { });
		public static Blue: ActionActivityColor = new ActionActivityColor("Blue", { });
		public static Purple: ActionActivityColor = new ActionActivityColor("Purple", { });
		public static Gray: ActionActivityColor = new ActionActivityColor("Gray", { });
		protected qualifiedTsTypeName: string = "microflows.ActionActivityColor";
	}

	export class AggregateFunctionEnum extends internal.IEnum {
		public static Sum: AggregateFunctionEnum = new AggregateFunctionEnum("Sum", { });
		public static Average: AggregateFunctionEnum = new AggregateFunctionEnum("Average", { });
		public static Count: AggregateFunctionEnum = new AggregateFunctionEnum("Count", { });
		public static Minimum: AggregateFunctionEnum = new AggregateFunctionEnum("Minimum", { });
		public static Maximum: AggregateFunctionEnum = new AggregateFunctionEnum("Maximum", { });
		protected qualifiedTsTypeName: string = "microflows.AggregateFunctionEnum";
	}

	export class ChangeActionItemType extends internal.IEnum {
		public static Set: ChangeActionItemType = new ChangeActionItemType("Set", { });
		public static Add: ChangeActionItemType = new ChangeActionItemType("Add", { });
		public static Remove: ChangeActionItemType = new ChangeActionItemType("Remove", { });
		protected qualifiedTsTypeName: string = "microflows.ChangeActionItemType";
	}

	export class ChangeListActionType extends internal.IEnum {
		public static Set: ChangeListActionType = new ChangeListActionType("Set", { });
		public static Add: ChangeListActionType = new ChangeListActionType("Add", { });
		public static Remove: ChangeListActionType = new ChangeListActionType("Remove", { });
		public static Clear: ChangeListActionType = new ChangeListActionType("Clear", { });
		protected qualifiedTsTypeName: string = "microflows.ChangeListActionType";
	}

	export class CommitEnum extends internal.IEnum {
		public static Yes: CommitEnum = new CommitEnum("Yes", { });
		public static YesWithoutEvents: CommitEnum = new CommitEnum("YesWithoutEvents", { });
		public static No: CommitEnum = new CommitEnum("No", { });
		protected qualifiedTsTypeName: string = "microflows.CommitEnum";
	}

	export class ErrorHandlingType extends internal.IEnum {
		public static Rollback: ErrorHandlingType = new ErrorHandlingType("Rollback", { });
		public static Custom: ErrorHandlingType = new ErrorHandlingType("Custom", { });
		public static CustomWithoutRollBack: ErrorHandlingType = new ErrorHandlingType("CustomWithoutRollBack", { });
		public static Continue: ErrorHandlingType = new ErrorHandlingType("Continue", { });
		protected qualifiedTsTypeName: string = "microflows.ErrorHandlingType";
	}

	export class HttpMethod extends internal.IEnum {
		public static Post: HttpMethod = new HttpMethod("Post", { });
		public static Get: HttpMethod = new HttpMethod("Get", { });
		public static Put: HttpMethod = new HttpMethod("Put", { });
		public static Patch: HttpMethod = new HttpMethod("Patch", { });
		public static Delete: HttpMethod = new HttpMethod("Delete", { });
		protected qualifiedTsTypeName: string = "microflows.HttpMethod";
	}

	export class LanguageSettingType extends internal.IEnum {
		public static CurrentUser: LanguageSettingType = new LanguageSettingType("CurrentUser", { });
		public static ProjectDefault: LanguageSettingType = new LanguageSettingType("ProjectDefault", { });
		public static Variable: LanguageSettingType = new LanguageSettingType("Variable", { });
		protected qualifiedTsTypeName: string = "microflows.LanguageSettingType";
	}

	export class LogLevel extends internal.IEnum {
		public static Trace: LogLevel = new LogLevel("Trace", { });
		public static Debug: LogLevel = new LogLevel("Debug", { });
		public static Info: LogLevel = new LogLevel("Info", { });
		public static Warning: LogLevel = new LogLevel("Warning", { });
		public static Error: LogLevel = new LogLevel("Error", { });
		public static Critical: LogLevel = new LogLevel("Critical", { });
		protected qualifiedTsTypeName: string = "microflows.LogLevel";
	}

	export class NullValueOption extends internal.IEnum {
		public static SendAsNil: NullValueOption = new NullValueOption("SendAsNil", { });
		public static LeaveOutElement: NullValueOption = new NullValueOption("LeaveOutElement", { });
		protected qualifiedTsTypeName: string = "microflows.NullValueOption";
	}

	export class RequestHandlingType extends internal.IEnum {
		public static Mapping: RequestHandlingType = new RequestHandlingType("Mapping", { });
		public static Simple: RequestHandlingType = new RequestHandlingType("Simple", { });
		public static Advanced: RequestHandlingType = new RequestHandlingType("Advanced", { });
		public static Binary: RequestHandlingType = new RequestHandlingType("Binary", { });
		public static Custom: RequestHandlingType = new RequestHandlingType("Custom", { });
		protected qualifiedTsTypeName: string = "microflows.RequestHandlingType";
	}

	export class ResultHandlingType extends internal.IEnum {
		public static Mapping: ResultHandlingType = new ResultHandlingType("Mapping", { });
		public static String: ResultHandlingType = new ResultHandlingType("String", { });
		public static FileDocument: ResultHandlingType = new ResultHandlingType("FileDocument", { });
		public static None: ResultHandlingType = new ResultHandlingType("None", { });
		protected qualifiedTsTypeName: string = "microflows.ResultHandlingType";
	}

	export class ShowMessageType extends internal.IEnum {
		public static Information: ShowMessageType = new ShowMessageType("Information", { });
		public static Warning: ShowMessageType = new ShowMessageType("Warning", { });
		public static Error: ShowMessageType = new ShowMessageType("Error", { });
		protected qualifiedTsTypeName: string = "microflows.ShowMessageType";
	}

	export class SortOrderEnum extends internal.IEnum {
		public static Ascending: SortOrderEnum = new SortOrderEnum("Ascending", { });
		public static Descending: SortOrderEnum = new SortOrderEnum("Descending", { });
		protected qualifiedTsTypeName: string = "microflows.SortOrderEnum";
	}

	export class TargetDocumentType extends internal.IEnum {
		public static HTML: TargetDocumentType = new TargetDocumentType("HTML", { });
		public static PDF: TargetDocumentType = new TargetDocumentType("PDF", { });
		public static DOCX: TargetDocumentType = new TargetDocumentType("DOCX", { });
		public static DOC: TargetDocumentType = new TargetDocumentType("DOC", { });
		public static RTF: TargetDocumentType = new TargetDocumentType("RTF", { });
		public static ODT: TargetDocumentType = new TargetDocumentType("ODT", { });
		protected qualifiedTsTypeName: string = "microflows.TargetDocumentType";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Microflows`.
	 */


	/**
	 * TODO: Abstract
	 */
	export interface IMicroflowObject extends internal.IElement {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): MicroflowObject;
		load(callback: (element: MicroflowObject) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: Abstract
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MicroflowObject extends internal.Element implements IMicroflowObject {
		public static typeName: string = "Microflows$MicroflowObject";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __relativeMiddlePoint: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(MicroflowObject, this, "relativeMiddlePoint", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get relativeMiddlePoint(): common.IPoint { return this.__relativeMiddlePoint.get(); }
		public set relativeMiddlePoint(newValue: common.IPoint) { this.__relativeMiddlePoint.set(newValue); }
		private __size: internal.PrimitiveProperty<common.ISize> =
			new internal.PrimitiveProperty<common.ISize>(MicroflowObject, this, "size", { width: 0, height: 0 }, internal.PrimitiveTypeEnum.Size);
		public get size(): common.ISize { return this.__size.get(); }
		public set size(newValue: common.ISize) { this.__size.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowObject() cannot be invoked directly, please use 'model.microflows.createMicroflowObject()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO: abstract element
	 */
	export interface IActivity extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): Activity;
		load(callback: (element: Activity) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: abstract element
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Activity extends MicroflowObject implements IActivity {
		public static typeName: string = "Microflows$Activity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Activity() cannot be invoked directly, please use 'model.microflows.createActivity()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/activities relevant section in reference guide}
	 */
	export interface IActionActivity extends IActivity {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): ActionActivity;
		load(callback: (element: ActionActivity) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/activities relevant section in reference guide}
	 */
	export class ActionActivity extends Activity implements IActionActivity {
		public static typeName: string = "Microflows$ActionActivity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __action: internal.PartProperty<MicroflowAction> =
			new internal.PartProperty<MicroflowAction>(ActionActivity, this, "action", null, false);
		public get action(): MicroflowAction { return this.__action.get(); }
		public set action(newValue: MicroflowAction) { this.__action.set(newValue); }
		private __caption: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ActionActivity, this, "caption", "", internal.PrimitiveTypeEnum.String);
		public get caption(): string { return this.__caption.get(); }
		public set caption(newValue: string) { this.__caption.set(newValue); }
		private __autoGenerateCaption: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ActionActivity, this, "autoGenerateCaption", false, internal.PrimitiveTypeEnum.Boolean);
		public get autoGenerateCaption(): boolean { return this.__autoGenerateCaption.get(); }
		public set autoGenerateCaption(newValue: boolean) { this.__autoGenerateCaption.set(newValue); }
		private __backgroundColor: internal.EnumProperty<ActionActivityColor> =
			new internal.EnumProperty<ActionActivityColor>(ActionActivity, this, "backgroundColor", ActionActivityColor.Default, ActionActivityColor);
		public get backgroundColor(): ActionActivityColor { return this.__backgroundColor.get(); }
		public set backgroundColor(newValue: ActionActivityColor) { this.__backgroundColor.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ActionActivity, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ActionActivity() cannot be invoked directly, please use 'model.microflows.createActionActivity()'"
				);
			}
		}

		/**
		 * Creates and returns a new ActionActivity instance in the SDK and on the server.
		 * The new ActionActivity will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): ActionActivity {
			return internal.instancehelpers.createElement(container, ActionActivity, "objects", true);
		}

		/**
		 * Creates and returns a new ActionActivity instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ActionActivity {
			return internal.instancehelpers.createElement(model, ActionActivity);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.autoGenerateCaption = true;
			this.backgroundColor = ActionActivityColor.Default;
			this.caption = "Activity";
			this.size = { width: 120, height: 60 };
		}

	}

	/**
	 * TODO
	 */
	export interface IRequestHandling extends internal.IElement {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): RequestHandling;
		load(callback: (element: RequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class RequestHandling extends internal.Element implements IRequestHandling {
		public static typeName: string = "Microflows$RequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RequestHandling() cannot be invoked directly, please use 'model.microflows.createRequestHandling()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IAdvancedRequestHandling extends IRequestHandling {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): AdvancedRequestHandling;
		load(callback: (element: AdvancedRequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class AdvancedRequestHandling extends RequestHandling implements IAdvancedRequestHandling {
		public static typeName: string = "Microflows$AdvancedRequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"nullValueOption" : {
					"introduced" : "6.7.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __parameterMappings: internal.PartListProperty<WebServiceOperationAdvancedParameterMapping> =
			new internal.PartListProperty<WebServiceOperationAdvancedParameterMapping>(AdvancedRequestHandling, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<WebServiceOperationAdvancedParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<WebServiceOperationAdvancedParameterMapping>) { this.__parameterMappings.set(newValue); }
		private __nullValueOption: internal.EnumProperty<NullValueOption> =
			new internal.EnumProperty<NullValueOption>(AdvancedRequestHandling, this, "nullValueOption", NullValueOption.LeaveOutElement, NullValueOption);
		/**
		 * In version 6.7.0: introduced
		 */
		public get nullValueOption(): NullValueOption { return this.__nullValueOption.get(); }
		public set nullValueOption(newValue: NullValueOption) { this.__nullValueOption.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AdvancedRequestHandling() cannot be invoked directly, please use 'model.microflows.createAdvancedRequestHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
		 * The new AdvancedRequestHandling will be automatically stored in the 'requestHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderRequestHandling(container: RestCallAction): AdvancedRequestHandling {
			internal.createInVersionCheck(container.model, AdvancedRequestHandling.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, AdvancedRequestHandling, "requestHandling", false);
		}

		/**
		 * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
		 * The new AdvancedRequestHandling will be automatically stored in the 'requestBodyHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): AdvancedRequestHandling {
			return internal.instancehelpers.createElement(container, AdvancedRequestHandling, "requestBodyHandling", false);
		}

		/**
		 * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
		 * The new AdvancedRequestHandling will be automatically stored in the 'requestHeaderHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): AdvancedRequestHandling {
			return internal.instancehelpers.createElement(container, AdvancedRequestHandling, "requestHeaderHandling", false);
		}

		/**
		 * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AdvancedRequestHandling {
			return internal.instancehelpers.createElement(model, AdvancedRequestHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			if (this.__nullValueOption.isAvailable) {
				this.nullValueOption = NullValueOption.LeaveOutElement;
			}
		}

	}

	/**
	 * TODO
	 */
	export interface IMicroflowAction extends internal.IElement {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): MicroflowAction;
		load(callback: (element: MicroflowAction) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MicroflowAction extends internal.Element implements IMicroflowAction {
		public static typeName: string = "Microflows$MicroflowAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __errorHandlingType: internal.EnumProperty<ErrorHandlingType> =
			new internal.EnumProperty<ErrorHandlingType>(MicroflowAction, this, "errorHandlingType", ErrorHandlingType.Rollback, ErrorHandlingType);
		public get errorHandlingType(): ErrorHandlingType { return this.__errorHandlingType.get(); }
		public set errorHandlingType(newValue: ErrorHandlingType) { this.__errorHandlingType.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowAction() cannot be invoked directly, please use 'model.microflows.createMicroflowAction()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.errorHandlingType = ErrorHandlingType.Rollback;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/aggregate-list relevant section in reference guide}
	 */
	export interface IAggregateListAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): AggregateListAction;
		load(callback: (element: AggregateListAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/aggregate-list relevant section in reference guide}
	 */
	export class AggregateListAction extends MicroflowAction implements IAggregateListAction {
		public static typeName: string = "Microflows$AggregateListAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __inputListVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AggregateListAction, this, "inputListVariableName", "", internal.PrimitiveTypeEnum.String);
		public get inputListVariableName(): string { return this.__inputListVariableName.get(); }
		public set inputListVariableName(newValue: string) { this.__inputListVariableName.set(newValue); }
		private __attribute: internal.ByNameReferenceProperty<domainmodels.IAttribute> =
			new internal.ByNameReferenceProperty<domainmodels.IAttribute>(AggregateListAction, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): domainmodels.IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: domainmodels.IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __aggregateFunction: internal.EnumProperty<AggregateFunctionEnum> =
			new internal.EnumProperty<AggregateFunctionEnum>(AggregateListAction, this, "aggregateFunction", AggregateFunctionEnum.Sum, AggregateFunctionEnum);
		public get aggregateFunction(): AggregateFunctionEnum { return this.__aggregateFunction.get(); }
		public set aggregateFunction(newValue: AggregateFunctionEnum) { this.__aggregateFunction.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AggregateListAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AggregateListAction() cannot be invoked directly, please use 'model.microflows.createAggregateListAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new AggregateListAction instance in the SDK and on the server.
		 * The new AggregateListAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): AggregateListAction {
			return internal.instancehelpers.createElement(container, AggregateListAction, "action", false);
		}

		/**
		 * Creates and returns a new AggregateListAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AggregateListAction {
			return internal.instancehelpers.createElement(model, AggregateListAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.aggregateFunction = AggregateFunctionEnum.Sum;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotation relevant section in reference guide}
	 */
	export interface IAnnotation extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): Annotation;
		load(callback: (element: Annotation) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotation relevant section in reference guide}
	 */
	export class Annotation extends MicroflowObject implements IAnnotation {
		public static typeName: string = "Microflows$Annotation";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __caption: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Annotation, this, "caption", "", internal.PrimitiveTypeEnum.String);
		public get caption(): string { return this.__caption.get(); }
		public set caption(newValue: string) { this.__caption.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Annotation() cannot be invoked directly, please use 'model.microflows.createAnnotation()'"
				);
			}
		}

		/**
		 * Creates and returns a new Annotation instance in the SDK and on the server.
		 * The new Annotation will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): Annotation {
			return internal.instancehelpers.createElement(container, Annotation, "objects", true);
		}

		/**
		 * Creates and returns a new Annotation instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Annotation {
			return internal.instancehelpers.createElement(model, Annotation);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 100, height: 40 };
		}

	}

	/**
	 * TODO abstract
	 */
	export interface IFlow extends internal.IElement {
		model: IModel;
		containerAsMicroflowBase: IMicroflowBase;
		load(): Flow;
		load(callback: (element: Flow) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO abstract
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Flow extends internal.Element implements IFlow {
		public static typeName: string = "Microflows$Flow";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"origin" : {
					"required" : {
						"currentValue" : true
					}
				},
				"destination" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowBase() { return super.getContainerAs<MicroflowBase>(MicroflowBase); }

		private __origin: internal.ByIdReferenceProperty<MicroflowObject> =
			new internal.ByIdReferenceProperty<MicroflowObject>(Flow, this, "origin", null);
		public get origin(): MicroflowObject { return this.__origin.get(); }
		public set origin(newValue: MicroflowObject) { this.__origin.set(newValue); }
		private __destination: internal.ByIdReferenceProperty<MicroflowObject> =
			new internal.ByIdReferenceProperty<MicroflowObject>(Flow, this, "destination", null);
		public get destination(): MicroflowObject { return this.__destination.get(); }
		public set destination(newValue: MicroflowObject) { this.__destination.set(newValue); }
		private __originConnectionIndex: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Flow, this, "originConnectionIndex", 0, internal.PrimitiveTypeEnum.Integer);
		public get originConnectionIndex(): number { return this.__originConnectionIndex.get(); }
		public set originConnectionIndex(newValue: number) { this.__originConnectionIndex.set(newValue); }
		private __destinationConnectionIndex: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Flow, this, "destinationConnectionIndex", 0, internal.PrimitiveTypeEnum.Integer);
		public get destinationConnectionIndex(): number { return this.__destinationConnectionIndex.get(); }
		public set destinationConnectionIndex(newValue: number) { this.__destinationConnectionIndex.set(newValue); }
		private __originBezierVector: internal.PrimitiveProperty<common.ISize> =
			new internal.PrimitiveProperty<common.ISize>(Flow, this, "originBezierVector", { width: 0, height: 0 }, internal.PrimitiveTypeEnum.Size);
		public get originBezierVector(): common.ISize { return this.__originBezierVector.get(); }
		public set originBezierVector(newValue: common.ISize) { this.__originBezierVector.set(newValue); }
		private __destinationBezierVector: internal.PrimitiveProperty<common.ISize> =
			new internal.PrimitiveProperty<common.ISize>(Flow, this, "destinationBezierVector", { width: 0, height: 0 }, internal.PrimitiveTypeEnum.Size);
		public get destinationBezierVector(): common.ISize { return this.__destinationBezierVector.get(); }
		public set destinationBezierVector(newValue: common.ISize) { this.__destinationBezierVector.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Flow() cannot be invoked directly, please use 'model.microflows.createFlow()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotation-flow relevant section in reference guide}
	 */
	export interface IAnnotationFlow extends IFlow {
		model: IModel;
		containerAsMicroflowBase: IMicroflowBase;
		load(): AnnotationFlow;
		load(callback: (element: AnnotationFlow) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotation-flow relevant section in reference guide}
	 */
	export class AnnotationFlow extends Flow implements IAnnotationFlow {
		public static typeName: string = "Microflows$AnnotationFlow";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowBase() { return super.getContainerAs<MicroflowBase>(MicroflowBase); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AnnotationFlow() cannot be invoked directly, please use 'model.microflows.createAnnotationFlow()'"
				);
			}
		}

		/**
		 * Creates and returns a new AnnotationFlow instance in the SDK and on the server.
		 * The new AnnotationFlow will be automatically stored in the 'flows' property
		 * of the parent MicroflowBase element passed as argument.
		 */
		public static createIn(container: MicroflowBase): AnnotationFlow {
			return internal.instancehelpers.createElement(container, AnnotationFlow, "flows", true);
		}

		/**
		 * Creates and returns a new AnnotationFlow instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AnnotationFlow {
			return internal.instancehelpers.createElement(model, AnnotationFlow);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO: Missing in ref guide ?
	 */
	export interface IAppServiceCallAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): AppServiceCallAction;
		load(callback: (element: AppServiceCallAction) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: Missing in ref guide ?
	 */
	export class AppServiceCallAction extends MicroflowAction implements IAppServiceCallAction {
		public static typeName: string = "Microflows$AppServiceCallAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __appServiceAction: internal.ByNameReferenceProperty<appservices.IAppServiceAction> =
			new internal.ByNameReferenceProperty<appservices.IAppServiceAction>(AppServiceCallAction, this, "appServiceAction", null, "AppServices$AppServiceAction");
		public get appServiceAction(): appservices.IAppServiceAction { return this.__appServiceAction.get(); }
		public set appServiceAction(newValue: appservices.IAppServiceAction) { this.__appServiceAction.set(newValue); }
		get appServiceActionQualifiedName(): string { return this.__appServiceAction.qualifiedName(); }
		private __parameterMappings: internal.PartListProperty<AppServiceCallParameterMapping> =
			new internal.PartListProperty<AppServiceCallParameterMapping>(AppServiceCallAction, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<AppServiceCallParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<AppServiceCallParameterMapping>) { this.__parameterMappings.set(newValue); }
		private __useVariable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(AppServiceCallAction, this, "useVariable", false, internal.PrimitiveTypeEnum.Boolean);
		public get useVariable(): boolean { return this.__useVariable.get(); }
		public set useVariable(newValue: boolean) { this.__useVariable.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AppServiceCallAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AppServiceCallAction() cannot be invoked directly, please use 'model.microflows.createAppServiceCallAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new AppServiceCallAction instance in the SDK and on the server.
		 * The new AppServiceCallAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): AppServiceCallAction {
			return internal.instancehelpers.createElement(container, AppServiceCallAction, "action", false);
		}

		/**
		 * Creates and returns a new AppServiceCallAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AppServiceCallAction {
			return internal.instancehelpers.createElement(model, AppServiceCallAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.useVariable = true;
		}

	}

	/**
	 * TODO: Missing in ref guide ?
	 */
	export interface IAppServiceCallParameterMapping extends internal.IElement {
		model: IModel;
		containerAsAppServiceCallAction: IAppServiceCallAction;
		load(): AppServiceCallParameterMapping;
		load(callback: (element: AppServiceCallParameterMapping) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: Missing in ref guide ?
	 */
	export class AppServiceCallParameterMapping extends internal.Element implements IAppServiceCallParameterMapping {
		public static typeName: string = "Microflows$AppServiceCallParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsAppServiceCallAction() { return super.getContainerAs<AppServiceCallAction>(AppServiceCallAction); }

		private __parameter: internal.ByNameReferenceProperty<appservices.IAppServiceActionParameter> =
			new internal.ByNameReferenceProperty<appservices.IAppServiceActionParameter>(AppServiceCallParameterMapping, this, "parameter", null, "AppServices$AppServiceActionParameter");
		public get parameter(): appservices.IAppServiceActionParameter { return this.__parameter.get(); }
		public set parameter(newValue: appservices.IAppServiceActionParameter) { this.__parameter.set(newValue); }
		get parameterQualifiedName(): string { return this.__parameter.qualifiedName(); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AppServiceCallParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AppServiceCallParameterMapping() cannot be invoked directly, please use 'model.microflows.createAppServiceCallParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new AppServiceCallParameterMapping instance in the SDK and on the server.
		 * The new AppServiceCallParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent AppServiceCallAction element passed as argument.
		 */
		public static createIn(container: AppServiceCallAction): AppServiceCallParameterMapping {
			return internal.instancehelpers.createElement(container, AppServiceCallParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new AppServiceCallParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AppServiceCallParameterMapping {
			return internal.instancehelpers.createElement(model, AppServiceCallParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IRetrieveSource extends internal.IElement {
		model: IModel;
		containerAsRetrieveAction: IRetrieveAction;
		load(): RetrieveSource;
		load(callback: (element: RetrieveSource) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class RetrieveSource extends internal.Element implements IRetrieveSource {
		public static typeName: string = "Microflows$RetrieveSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsRetrieveAction() { return super.getContainerAs<RetrieveAction>(RetrieveAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RetrieveSource() cannot be invoked directly, please use 'model.microflows.createRetrieveSource()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IAssociationRetrieveSource extends IRetrieveSource {
		model: IModel;
		containerAsRetrieveAction: IRetrieveAction;
		load(): AssociationRetrieveSource;
		load(callback: (element: AssociationRetrieveSource) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class AssociationRetrieveSource extends RetrieveSource implements IAssociationRetrieveSource {
		public static typeName: string = "Microflows$AssociationRetrieveSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsRetrieveAction() { return super.getContainerAs<RetrieveAction>(RetrieveAction); }

		private __startVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AssociationRetrieveSource, this, "startVariableName", "", internal.PrimitiveTypeEnum.String);
		public get startVariableName(): string { return this.__startVariableName.get(); }
		public set startVariableName(newValue: string) { this.__startVariableName.set(newValue); }
		private __association: internal.ByNameReferenceProperty<domainmodels.IAssociationBase> =
			new internal.ByNameReferenceProperty<domainmodels.IAssociationBase>(AssociationRetrieveSource, this, "association", null, "DomainModels$AssociationBase");
		public get association(): domainmodels.IAssociationBase { return this.__association.get(); }
		public set association(newValue: domainmodels.IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AssociationRetrieveSource() cannot be invoked directly, please use 'model.microflows.createAssociationRetrieveSource()'"
				);
			}
		}

		/**
		 * Creates and returns a new AssociationRetrieveSource instance in the SDK and on the server.
		 * The new AssociationRetrieveSource will be automatically stored in the 'retrieveSource' property
		 * of the parent RetrieveAction element passed as argument.
		 */
		public static createIn(container: RetrieveAction): AssociationRetrieveSource {
			return internal.instancehelpers.createElement(container, AssociationRetrieveSource, "retrieveSource", false);
		}

		/**
		 * Creates and returns a new AssociationRetrieveSource instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AssociationRetrieveSource {
			return internal.instancehelpers.createElement(model, AssociationRetrieveSource);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.7.0: introduced
	 */
	export interface IJavaActionParameterValue extends internal.IElement {
		model: IModel;
		containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
		load(): JavaActionParameterValue;
		load(callback: (element: JavaActionParameterValue) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

	 *
	 * In version 6.7.0: introduced
	 */
	export abstract class JavaActionParameterValue extends internal.Element implements IJavaActionParameterValue {
		public static typeName: string = "Microflows$JavaActionParameterValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.7.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaActionParameterMapping() { return super.getContainerAs<JavaActionParameterMapping>(JavaActionParameterMapping); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new JavaActionParameterValue() cannot be invoked directly, please use 'model.microflows.createJavaActionParameterValue()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.7.0: introduced
	 */
	export interface IBasicJavaActionParameterValue extends IJavaActionParameterValue {
		model: IModel;
		containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
		load(): BasicJavaActionParameterValue;
		load(callback: (element: BasicJavaActionParameterValue) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.7.0: introduced
	 */
	export class BasicJavaActionParameterValue extends JavaActionParameterValue implements IBasicJavaActionParameterValue {
		public static typeName: string = "Microflows$BasicJavaActionParameterValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.7.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaActionParameterMapping() { return super.getContainerAs<JavaActionParameterMapping>(JavaActionParameterMapping); }

		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(BasicJavaActionParameterValue, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BasicJavaActionParameterValue() cannot be invoked directly, please use 'model.microflows.createBasicJavaActionParameterValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new BasicJavaActionParameterValue instance in the SDK and on the server.
		 * The new BasicJavaActionParameterValue will be automatically stored in the 'value' property
		 * of the parent JavaActionParameterMapping element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createIn(container: JavaActionParameterMapping): BasicJavaActionParameterValue {
			internal.createInVersionCheck(container.model, BasicJavaActionParameterValue.typeName,
				["6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, BasicJavaActionParameterValue, "value", false);
		}

		/**
		 * Creates and returns a new BasicJavaActionParameterValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BasicJavaActionParameterValue {
			return internal.instancehelpers.createElement(model, BasicJavaActionParameterValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IListOperation extends internal.IElement {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): ListOperation;
		load(callback: (element: ListOperation) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ListOperation extends internal.Element implements IListOperation {
		public static typeName: string = "Microflows$ListOperation";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }

		private __listVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ListOperation, this, "listVariableName", "", internal.PrimitiveTypeEnum.String);
		public get listVariableName(): string { return this.__listVariableName.get(); }
		public set listVariableName(newValue: string) { this.__listVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ListOperation() cannot be invoked directly, please use 'model.microflows.createListOperation()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IBinaryListOperation extends IListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): BinaryListOperation;
		load(callback: (element: BinaryListOperation) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class BinaryListOperation extends ListOperation implements IBinaryListOperation {
		public static typeName: string = "Microflows$BinaryListOperation";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }

		private __secondListOrObjectVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(BinaryListOperation, this, "secondListOrObjectVariableName", "", internal.PrimitiveTypeEnum.String);
		public get secondListOrObjectVariableName(): string { return this.__secondListOrObjectVariableName.get(); }
		public set secondListOrObjectVariableName(newValue: string) { this.__secondListOrObjectVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BinaryListOperation() cannot be invoked directly, please use 'model.microflows.createBinaryListOperation()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.9.0: introduced
	 */
	export interface IBinaryRequestHandling extends IRequestHandling {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): BinaryRequestHandling;
		load(callback: (element: BinaryRequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.9.0: introduced
	 */
	export class BinaryRequestHandling extends RequestHandling implements IBinaryRequestHandling {
		public static typeName: string = "Microflows$BinaryRequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.9.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __expression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(BinaryRequestHandling, this, "expression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get expression(): string { return this.__expression.get(); }
		public set expression(newValue: string) { this.__expression.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BinaryRequestHandling() cannot be invoked directly, please use 'model.microflows.createBinaryRequestHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
		 * The new BinaryRequestHandling will be automatically stored in the 'requestHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderRequestHandling(container: RestCallAction): BinaryRequestHandling {
			internal.createInVersionCheck(container.model, BinaryRequestHandling.typeName,
				["6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, BinaryRequestHandling, "requestHandling", false);
		}

		/**
		 * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
		 * The new BinaryRequestHandling will be automatically stored in the 'requestBodyHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): BinaryRequestHandling {
			internal.createInVersionCheck(container.model, BinaryRequestHandling.typeName,
				["6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, BinaryRequestHandling, "requestBodyHandling", false);
		}

		/**
		 * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
		 * The new BinaryRequestHandling will be automatically stored in the 'requestHeaderHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): BinaryRequestHandling {
			internal.createInVersionCheck(container.model, BinaryRequestHandling.typeName,
				["6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, BinaryRequestHandling, "requestHeaderHandling", false);
		}

		/**
		 * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BinaryRequestHandling {
			return internal.instancehelpers.createElement(model, BinaryRequestHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/break-event relevant section in reference guide}
	 */
	export interface IBreakEvent extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): BreakEvent;
		load(callback: (element: BreakEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/break-event relevant section in reference guide}
	 */
	export class BreakEvent extends MicroflowObject implements IBreakEvent {
		public static typeName: string = "Microflows$BreakEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BreakEvent() cannot be invoked directly, please use 'model.microflows.createBreakEvent()'"
				);
			}
		}

		/**
		 * Creates and returns a new BreakEvent instance in the SDK and on the server.
		 * The new BreakEvent will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): BreakEvent {
			return internal.instancehelpers.createElement(container, BreakEvent, "objects", true);
		}

		/**
		 * Creates and returns a new BreakEvent instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BreakEvent {
			return internal.instancehelpers.createElement(model, BreakEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 20, height: 20 };
		}

	}

	/**
	 * TODO
	 */
	export interface ICaseValue extends internal.IElement {
		model: IModel;
		containerAsSequenceFlow: ISequenceFlow;
		load(): CaseValue;
		load(callback: (element: CaseValue) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class CaseValue extends internal.Element implements ICaseValue {
		public static typeName: string = "Microflows$CaseValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsSequenceFlow() { return super.getContainerAs<SequenceFlow>(SequenceFlow); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CaseValue() cannot be invoked directly, please use 'model.microflows.createCaseValue()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/cast-object relevant section in reference guide}
	 */
	export interface ICastAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CastAction;
		load(callback: (element: CastAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/cast-object relevant section in reference guide}
	 */
	export class CastAction extends MicroflowAction implements ICastAction {
		public static typeName: string = "Microflows$CastAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CastAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CastAction() cannot be invoked directly, please use 'model.microflows.createCastAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CastAction instance in the SDK and on the server.
		 * The new CastAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CastAction {
			return internal.instancehelpers.createElement(container, CastAction, "action", false);
		}

		/**
		 * Creates and returns a new CastAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CastAction {
			return internal.instancehelpers.createElement(model, CastAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-list relevant section in reference guide}
	 */
	export interface IChangeListAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ChangeListAction;
		load(callback: (element: ChangeListAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-list relevant section in reference guide}
	 */
	export class ChangeListAction extends MicroflowAction implements IChangeListAction {
		public static typeName: string = "Microflows$ChangeListAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __changeVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ChangeListAction, this, "changeVariableName", "", internal.PrimitiveTypeEnum.String);
		public get changeVariableName(): string { return this.__changeVariableName.get(); }
		public set changeVariableName(newValue: string) { this.__changeVariableName.set(newValue); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ChangeListAction, this, "value", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }
		private __type: internal.EnumProperty<ChangeListActionType> =
			new internal.EnumProperty<ChangeListActionType>(ChangeListAction, this, "type", ChangeListActionType.Add, ChangeListActionType);
		public get type(): ChangeListActionType { return this.__type.get(); }
		public set type(newValue: ChangeListActionType) { this.__type.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ChangeListAction() cannot be invoked directly, please use 'model.microflows.createChangeListAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ChangeListAction instance in the SDK and on the server.
		 * The new ChangeListAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ChangeListAction {
			return internal.instancehelpers.createElement(container, ChangeListAction, "action", false);
		}

		/**
		 * Creates and returns a new ChangeListAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ChangeListAction {
			return internal.instancehelpers.createElement(model, ChangeListAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = ChangeListActionType.Add;
		}

	}

	/**
	 * TODO
	 */
	export interface IChangeMembersAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ChangeMembersAction;
		load(callback: (element: ChangeMembersAction) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ChangeMembersAction extends MicroflowAction implements IChangeMembersAction {
		public static typeName: string = "Microflows$ChangeMembersAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __items: internal.PartListProperty<MemberChange> =
			new internal.PartListProperty<MemberChange>(ChangeMembersAction, this, "items", []);
		public get items(): internal.IList<MemberChange> { return this.__items.get(); }
		public set items(newValue: internal.IList<MemberChange>) { this.__items.set(newValue); }
		private __refreshInClient: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ChangeMembersAction, this, "refreshInClient", false, internal.PrimitiveTypeEnum.Boolean);
		public get refreshInClient(): boolean { return this.__refreshInClient.get(); }
		public set refreshInClient(newValue: boolean) { this.__refreshInClient.set(newValue); }
		private __commit: internal.EnumProperty<CommitEnum> =
			new internal.EnumProperty<CommitEnum>(ChangeMembersAction, this, "commit", CommitEnum.No, CommitEnum);
		public get commit(): CommitEnum { return this.__commit.get(); }
		public set commit(newValue: CommitEnum) { this.__commit.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ChangeMembersAction() cannot be invoked directly, please use 'model.microflows.createChangeMembersAction()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.commit = CommitEnum.No;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-object relevant section in reference guide}
	 */
	export interface IChangeObjectAction extends IChangeMembersAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ChangeObjectAction;
		load(callback: (element: ChangeObjectAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-object relevant section in reference guide}
	 */
	export class ChangeObjectAction extends ChangeMembersAction implements IChangeObjectAction {
		public static typeName: string = "Microflows$ChangeObjectAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __changeVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ChangeObjectAction, this, "changeVariableName", "", internal.PrimitiveTypeEnum.String);
		public get changeVariableName(): string { return this.__changeVariableName.get(); }
		public set changeVariableName(newValue: string) { this.__changeVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ChangeObjectAction() cannot be invoked directly, please use 'model.microflows.createChangeObjectAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ChangeObjectAction instance in the SDK and on the server.
		 * The new ChangeObjectAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ChangeObjectAction {
			return internal.instancehelpers.createElement(container, ChangeObjectAction, "action", false);
		}

		/**
		 * Creates and returns a new ChangeObjectAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ChangeObjectAction {
			return internal.instancehelpers.createElement(model, ChangeObjectAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-variable relevant section in reference guide}
	 */
	export interface IChangeVariableAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ChangeVariableAction;
		load(callback: (element: ChangeVariableAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/change-variable relevant section in reference guide}
	 */
	export class ChangeVariableAction extends MicroflowAction implements IChangeVariableAction {
		public static typeName: string = "Microflows$ChangeVariableAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __changeVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ChangeVariableAction, this, "changeVariableName", "", internal.PrimitiveTypeEnum.String);
		public get changeVariableName(): string { return this.__changeVariableName.get(); }
		public set changeVariableName(newValue: string) { this.__changeVariableName.set(newValue); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ChangeVariableAction, this, "value", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ChangeVariableAction() cannot be invoked directly, please use 'model.microflows.createChangeVariableAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ChangeVariableAction instance in the SDK and on the server.
		 * The new ChangeVariableAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ChangeVariableAction {
			return internal.instancehelpers.createElement(container, ChangeVariableAction, "action", false);
		}

		/**
		 * Creates and returns a new ChangeVariableAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ChangeVariableAction {
			return internal.instancehelpers.createElement(model, ChangeVariableAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/close-form relevant section in reference guide}
	 */
	export interface ICloseFormAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CloseFormAction;
		load(callback: (element: CloseFormAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/close-form relevant section in reference guide}
	 */
	export class CloseFormAction extends MicroflowAction implements ICloseFormAction {
		public static typeName: string = "Microflows$CloseFormAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CloseFormAction() cannot be invoked directly, please use 'model.microflows.createCloseFormAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CloseFormAction instance in the SDK and on the server.
		 * The new CloseFormAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CloseFormAction {
			return internal.instancehelpers.createElement(container, CloseFormAction, "action", false);
		}

		/**
		 * Creates and returns a new CloseFormAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CloseFormAction {
			return internal.instancehelpers.createElement(model, CloseFormAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/committing-objects relevant section in reference guide}
	 */
	export interface ICommitAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CommitAction;
		load(callback: (element: CommitAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/committing-objects relevant section in reference guide}
	 */
	export class CommitAction extends MicroflowAction implements ICommitAction {
		public static typeName: string = "Microflows$CommitAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __withEvents: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(CommitAction, this, "withEvents", false, internal.PrimitiveTypeEnum.Boolean);
		public get withEvents(): boolean { return this.__withEvents.get(); }
		public set withEvents(newValue: boolean) { this.__withEvents.set(newValue); }
		private __commitVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CommitAction, this, "commitVariableName", "", internal.PrimitiveTypeEnum.String);
		public get commitVariableName(): string { return this.__commitVariableName.get(); }
		public set commitVariableName(newValue: string) { this.__commitVariableName.set(newValue); }
		private __refreshInClient: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(CommitAction, this, "refreshInClient", false, internal.PrimitiveTypeEnum.Boolean);
		public get refreshInClient(): boolean { return this.__refreshInClient.get(); }
		public set refreshInClient(newValue: boolean) { this.__refreshInClient.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CommitAction() cannot be invoked directly, please use 'model.microflows.createCommitAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CommitAction instance in the SDK and on the server.
		 * The new CommitAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CommitAction {
			return internal.instancehelpers.createElement(container, CommitAction, "action", false);
		}

		/**
		 * Creates and returns a new CommitAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CommitAction {
			return internal.instancehelpers.createElement(model, CommitAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.withEvents = true;
		}

	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 */
	export interface IRange extends internal.IElement {
		model: IModel;
		containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
		containerAsImportMappingCall: IImportMappingCall;
		load(): Range;
		load(callback: (element: Range) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Range extends internal.Element implements IRange {
		public static typeName: string = "Microflows$Range";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDatabaseRetrieveSource() { return super.getContainerAs<DatabaseRetrieveSource>(DatabaseRetrieveSource); }
		get containerAsImportMappingCall() { return super.getContainerAs<ImportMappingCall>(ImportMappingCall); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Range() cannot be invoked directly, please use 'model.microflows.createRange()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 */
	export interface IConstantRange extends IRange {
		model: IModel;
		containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
		containerAsImportMappingCall: IImportMappingCall;
		load(): ConstantRange;
		load(callback: (element: ConstantRange) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 */
	export class ConstantRange extends Range implements IConstantRange {
		public static typeName: string = "Microflows$ConstantRange";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDatabaseRetrieveSource() { return super.getContainerAs<DatabaseRetrieveSource>(DatabaseRetrieveSource); }
		get containerAsImportMappingCall() { return super.getContainerAs<ImportMappingCall>(ImportMappingCall); }

		private __singleObject: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ConstantRange, this, "singleObject", false, internal.PrimitiveTypeEnum.Boolean);
		public get singleObject(): boolean { return this.__singleObject.get(); }
		public set singleObject(newValue: boolean) { this.__singleObject.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ConstantRange() cannot be invoked directly, please use 'model.microflows.createConstantRange()'"
				);
			}
		}


		/**
		 * Creates and returns a new ConstantRange instance in the SDK and on the server.
		 * The new ConstantRange will be automatically stored in the 'range' property
		 * of the parent DatabaseRetrieveSource element passed as argument.
		 */
		public static createInDatabaseRetrieveSourceUnderRange(container: DatabaseRetrieveSource): ConstantRange {
			return internal.instancehelpers.createElement(container, ConstantRange, "range", false);
		}

		/**
		 * Creates and returns a new ConstantRange instance in the SDK and on the server.
		 * The new ConstantRange will be automatically stored in the 'range' property
		 * of the parent ImportMappingCall element passed as argument.
		 */
		public static createInImportMappingCallUnderRange(container: ImportMappingCall): ConstantRange {
			return internal.instancehelpers.createElement(container, ConstantRange, "range", false);
		}

		/**
		 * Creates and returns a new ConstantRange instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ConstantRange {
			return internal.instancehelpers.createElement(model, ConstantRange);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IContains extends IBinaryListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Contains;
		load(callback: (element: Contains) => void, forceRefresh?: boolean);
	}

	export class Contains extends BinaryListOperation implements IContains {
		public static typeName: string = "Microflows$Contains";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Contains() cannot be invoked directly, please use 'model.microflows.createContains()'"
				);
			}
		}

		/**
		 * Creates and returns a new Contains instance in the SDK and on the server.
		 * The new Contains will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Contains {
			return internal.instancehelpers.createElement(container, Contains, "operation", false);
		}

		/**
		 * Creates and returns a new Contains instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Contains {
			return internal.instancehelpers.createElement(model, Contains);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/continue-event relevant section in reference guide}
	 */
	export interface IContinueEvent extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): ContinueEvent;
		load(callback: (element: ContinueEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/continue-event relevant section in reference guide}
	 */
	export class ContinueEvent extends MicroflowObject implements IContinueEvent {
		public static typeName: string = "Microflows$ContinueEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ContinueEvent() cannot be invoked directly, please use 'model.microflows.createContinueEvent()'"
				);
			}
		}

		/**
		 * Creates and returns a new ContinueEvent instance in the SDK and on the server.
		 * The new ContinueEvent will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): ContinueEvent {
			return internal.instancehelpers.createElement(container, ContinueEvent, "objects", true);
		}

		/**
		 * Creates and returns a new ContinueEvent instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ContinueEvent {
			return internal.instancehelpers.createElement(model, ContinueEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 20, height: 20 };
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-list relevant section in reference guide}
	 */
	export interface ICreateListAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CreateListAction;
		load(callback: (element: CreateListAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-list relevant section in reference guide}
	 */
	export class CreateListAction extends MicroflowAction implements ICreateListAction {
		public static typeName: string = "Microflows$CreateListAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(CreateListAction, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CreateListAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CreateListAction() cannot be invoked directly, please use 'model.microflows.createCreateListAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CreateListAction instance in the SDK and on the server.
		 * The new CreateListAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CreateListAction {
			return internal.instancehelpers.createElement(container, CreateListAction, "action", false);
		}

		/**
		 * Creates and returns a new CreateListAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CreateListAction {
			return internal.instancehelpers.createElement(model, CreateListAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-object relevant section in reference guide}
	 */
	export interface ICreateObjectAction extends IChangeMembersAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CreateObjectAction;
		load(callback: (element: CreateObjectAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-object relevant section in reference guide}
	 */
	export class CreateObjectAction extends ChangeMembersAction implements ICreateObjectAction {
		public static typeName: string = "Microflows$CreateObjectAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(CreateObjectAction, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CreateObjectAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CreateObjectAction() cannot be invoked directly, please use 'model.microflows.createCreateObjectAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CreateObjectAction instance in the SDK and on the server.
		 * The new CreateObjectAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CreateObjectAction {
			return internal.instancehelpers.createElement(container, CreateObjectAction, "action", false);
		}

		/**
		 * Creates and returns a new CreateObjectAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CreateObjectAction {
			return internal.instancehelpers.createElement(model, CreateObjectAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-variable relevant section in reference guide}
	 */
	export interface ICreateVariableAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): CreateVariableAction;
		load(callback: (element: CreateVariableAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/create-variable relevant section in reference guide}
	 */
	export class CreateVariableAction extends MicroflowAction implements ICreateVariableAction {
		public static typeName: string = "Microflows$CreateVariableAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __variableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CreateVariableAction, this, "variableName", "", internal.PrimitiveTypeEnum.String);
		public get variableName(): string { return this.__variableName.get(); }
		public set variableName(newValue: string) { this.__variableName.set(newValue); }
		private __variableDataType: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CreateVariableAction, this, "variableDataType", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get variableDataType(): string { return this.__variableDataType.get(); }
		public set variableDataType(newValue: string) { this.__variableDataType.set(newValue); }
		private __initialValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CreateVariableAction, this, "initialValue", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get initialValue(): string { return this.__initialValue.get(); }
		public set initialValue(newValue: string) { this.__initialValue.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CreateVariableAction() cannot be invoked directly, please use 'model.microflows.createCreateVariableAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new CreateVariableAction instance in the SDK and on the server.
		 * The new CreateVariableAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): CreateVariableAction {
			return internal.instancehelpers.createElement(container, CreateVariableAction, "action", false);
		}

		/**
		 * Creates and returns a new CreateVariableAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CreateVariableAction {
			return internal.instancehelpers.createElement(model, CreateVariableAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.variableDataType = "Boolean";
		}

	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 */
	export interface ICustomRange extends IRange {
		model: IModel;
		containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
		containerAsImportMappingCall: IImportMappingCall;
		load(): CustomRange;
		load(callback: (element: CustomRange) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: also described in ImporrtXmlAction and CallWebServiceAction
	 */
	export class CustomRange extends Range implements ICustomRange {
		public static typeName: string = "Microflows$CustomRange";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDatabaseRetrieveSource() { return super.getContainerAs<DatabaseRetrieveSource>(DatabaseRetrieveSource); }
		get containerAsImportMappingCall() { return super.getContainerAs<ImportMappingCall>(ImportMappingCall); }

		private __limitExpression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CustomRange, this, "limitExpression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get limitExpression(): string { return this.__limitExpression.get(); }
		public set limitExpression(newValue: string) { this.__limitExpression.set(newValue); }
		private __offsetExpression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CustomRange, this, "offsetExpression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get offsetExpression(): string { return this.__offsetExpression.get(); }
		public set offsetExpression(newValue: string) { this.__offsetExpression.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CustomRange() cannot be invoked directly, please use 'model.microflows.createCustomRange()'"
				);
			}
		}


		/**
		 * Creates and returns a new CustomRange instance in the SDK and on the server.
		 * The new CustomRange will be automatically stored in the 'range' property
		 * of the parent DatabaseRetrieveSource element passed as argument.
		 */
		public static createInDatabaseRetrieveSourceUnderRange(container: DatabaseRetrieveSource): CustomRange {
			return internal.instancehelpers.createElement(container, CustomRange, "range", false);
		}

		/**
		 * Creates and returns a new CustomRange instance in the SDK and on the server.
		 * The new CustomRange will be automatically stored in the 'range' property
		 * of the parent ImportMappingCall element passed as argument.
		 */
		public static createInImportMappingCallUnderRange(container: ImportMappingCall): CustomRange {
			return internal.instancehelpers.createElement(container, CustomRange, "range", false);
		}

		/**
		 * Creates and returns a new CustomRange instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CustomRange {
			return internal.instancehelpers.createElement(model, CustomRange);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface ICustomRequestHandling extends IRequestHandling {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): CustomRequestHandling;
		load(callback: (element: CustomRequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class CustomRequestHandling extends RequestHandling implements ICustomRequestHandling {
		public static typeName: string = "Microflows$CustomRequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"template" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __template: internal.PartProperty<StringTemplate> =
			new internal.PartProperty<StringTemplate>(CustomRequestHandling, this, "template", null, true);
		public get template(): StringTemplate { return this.__template.get(); }
		public set template(newValue: StringTemplate) { this.__template.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CustomRequestHandling() cannot be invoked directly, please use 'model.microflows.createCustomRequestHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
		 * The new CustomRequestHandling will be automatically stored in the 'requestHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderRequestHandling(container: RestCallAction): CustomRequestHandling {
			internal.createInVersionCheck(container.model, CustomRequestHandling.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, CustomRequestHandling, "requestHandling", false);
		}

		/**
		 * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
		 * The new CustomRequestHandling will be automatically stored in the 'requestBodyHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): CustomRequestHandling {
			return internal.instancehelpers.createElement(container, CustomRequestHandling, "requestBodyHandling", false);
		}

		/**
		 * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
		 * The new CustomRequestHandling will be automatically stored in the 'requestHeaderHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): CustomRequestHandling {
			return internal.instancehelpers.createElement(container, CustomRequestHandling, "requestHeaderHandling", false);
		}

		/**
		 * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CustomRequestHandling {
			return internal.instancehelpers.createElement(model, CustomRequestHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.template = StringTemplate.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface IDatabaseRetrieveSource extends IRetrieveSource {
		model: IModel;
		containerAsRetrieveAction: IRetrieveAction;
		load(): DatabaseRetrieveSource;
		load(callback: (element: DatabaseRetrieveSource) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class DatabaseRetrieveSource extends RetrieveSource implements IDatabaseRetrieveSource {
		public static typeName: string = "Microflows$DatabaseRetrieveSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"range" : {
					"required" : {
						"currentValue" : true
					}
				},
				"sortItemList" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRetrieveAction() { return super.getContainerAs<RetrieveAction>(RetrieveAction); }

		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(DatabaseRetrieveSource, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }
		private __range: internal.PartProperty<Range> =
			new internal.PartProperty<Range>(DatabaseRetrieveSource, this, "range", null, true);
		public get range(): Range { return this.__range.get(); }
		public set range(newValue: Range) { this.__range.set(newValue); }
		private __xPathConstraint: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DatabaseRetrieveSource, this, "xPathConstraint", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
		 */
		public get xPathConstraint(): string { return this.__xPathConstraint.get(); }
		public set xPathConstraint(newValue: string) { this.__xPathConstraint.set(newValue); }
		private __sortItemList: internal.PartProperty<SortItemList> =
			new internal.PartProperty<SortItemList>(DatabaseRetrieveSource, this, "sortItemList", null, true);
		public get sortItemList(): SortItemList { return this.__sortItemList.get(); }
		public set sortItemList(newValue: SortItemList) { this.__sortItemList.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DatabaseRetrieveSource() cannot be invoked directly, please use 'model.microflows.createDatabaseRetrieveSource()'"
				);
			}
		}

		/**
		 * Creates and returns a new DatabaseRetrieveSource instance in the SDK and on the server.
		 * The new DatabaseRetrieveSource will be automatically stored in the 'retrieveSource' property
		 * of the parent RetrieveAction element passed as argument.
		 */
		public static createIn(container: RetrieveAction): DatabaseRetrieveSource {
			return internal.instancehelpers.createElement(container, DatabaseRetrieveSource, "retrieveSource", false);
		}

		/**
		 * Creates and returns a new DatabaseRetrieveSource instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DatabaseRetrieveSource {
			return internal.instancehelpers.createElement(model, DatabaseRetrieveSource);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.range = ConstantRange.create(this.model);
			this.sortItemList = SortItemList.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/deleting-objects relevant section in reference guide}
	 */
	export interface IDeleteAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): DeleteAction;
		load(callback: (element: DeleteAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/deleting-objects relevant section in reference guide}
	 */
	export class DeleteAction extends MicroflowAction implements IDeleteAction {
		public static typeName: string = "Microflows$DeleteAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __deleteVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DeleteAction, this, "deleteVariableName", "", internal.PrimitiveTypeEnum.String);
		public get deleteVariableName(): string { return this.__deleteVariableName.get(); }
		public set deleteVariableName(newValue: string) { this.__deleteVariableName.set(newValue); }
		private __refreshInClient: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DeleteAction, this, "refreshInClient", false, internal.PrimitiveTypeEnum.Boolean);
		public get refreshInClient(): boolean { return this.__refreshInClient.get(); }
		public set refreshInClient(newValue: boolean) { this.__refreshInClient.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DeleteAction() cannot be invoked directly, please use 'model.microflows.createDeleteAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new DeleteAction instance in the SDK and on the server.
		 * The new DeleteAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): DeleteAction {
			return internal.instancehelpers.createElement(container, DeleteAction, "action", false);
		}

		/**
		 * Creates and returns a new DeleteAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DeleteAction {
			return internal.instancehelpers.createElement(model, DeleteAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDocumentTemplateParameterMapping extends internal.IElement {
		model: IModel;
		containerAsGenerateDocumentAction: IGenerateDocumentAction;
		load(): DocumentTemplateParameterMapping;
		load(callback: (element: DocumentTemplateParameterMapping) => void, forceRefresh?: boolean);
	}

	export class DocumentTemplateParameterMapping extends internal.Element implements IDocumentTemplateParameterMapping {
		public static typeName: string = "Microflows$DocumentTemplateParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsGenerateDocumentAction() { return super.getContainerAs<GenerateDocumentAction>(GenerateDocumentAction); }

		private __widgetName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DocumentTemplateParameterMapping, this, "widgetName", "", internal.PrimitiveTypeEnum.String);
		public get widgetName(): string { return this.__widgetName.get(); }
		public set widgetName(newValue: string) { this.__widgetName.set(newValue); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DocumentTemplateParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DocumentTemplateParameterMapping() cannot be invoked directly, please use 'model.microflows.createDocumentTemplateParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new DocumentTemplateParameterMapping instance in the SDK and on the server.
		 * The new DocumentTemplateParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent GenerateDocumentAction element passed as argument.
		 */
		public static createIn(container: GenerateDocumentAction): DocumentTemplateParameterMapping {
			return internal.instancehelpers.createElement(container, DocumentTemplateParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new DocumentTemplateParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DocumentTemplateParameterMapping {
			return internal.instancehelpers.createElement(model, DocumentTemplateParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/download-file relevant section in reference guide}
	 */
	export interface IDownloadFileAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): DownloadFileAction;
		load(callback: (element: DownloadFileAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/download-file relevant section in reference guide}
	 */
	export class DownloadFileAction extends MicroflowAction implements IDownloadFileAction {
		public static typeName: string = "Microflows$DownloadFileAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __fileDocumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DownloadFileAction, this, "fileDocumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get fileDocumentVariableName(): string { return this.__fileDocumentVariableName.get(); }
		public set fileDocumentVariableName(newValue: string) { this.__fileDocumentVariableName.set(newValue); }
		private __showFileInBrowser: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DownloadFileAction, this, "showFileInBrowser", false, internal.PrimitiveTypeEnum.Boolean);
		public get showFileInBrowser(): boolean { return this.__showFileInBrowser.get(); }
		public set showFileInBrowser(newValue: boolean) { this.__showFileInBrowser.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DownloadFileAction() cannot be invoked directly, please use 'model.microflows.createDownloadFileAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new DownloadFileAction instance in the SDK and on the server.
		 * The new DownloadFileAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): DownloadFileAction {
			return internal.instancehelpers.createElement(container, DownloadFileAction, "action", false);
		}

		/**
		 * Creates and returns a new DownloadFileAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DownloadFileAction {
			return internal.instancehelpers.createElement(model, DownloadFileAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/end-event relevant section in reference guide}
	 */
	export interface IEndEvent extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): EndEvent;
		load(callback: (element: EndEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/end-event relevant section in reference guide}
	 */
	export class EndEvent extends MicroflowObject implements IEndEvent {
		public static typeName: string = "Microflows$EndEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __returnValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(EndEvent, this, "returnValue", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get returnValue(): string { return this.__returnValue.get(); }
		public set returnValue(newValue: string) { this.__returnValue.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(EndEvent, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EndEvent() cannot be invoked directly, please use 'model.microflows.createEndEvent()'"
				);
			}
		}

		/**
		 * Creates and returns a new EndEvent instance in the SDK and on the server.
		 * The new EndEvent will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): EndEvent {
			return internal.instancehelpers.createElement(container, EndEvent, "objects", true);
		}

		/**
		 * Creates and returns a new EndEvent instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EndEvent {
			return internal.instancehelpers.createElement(model, EndEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 20, height: 20 };
		}

	}

	/**
	 * In version 6.8.0: introduced
	 */
	export interface IEntityTypeJavaActionParameterValue extends IJavaActionParameterValue {
		model: IModel;
		containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
		load(): EntityTypeJavaActionParameterValue;
		load(callback: (element: EntityTypeJavaActionParameterValue) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.8.0: introduced
	 */
	export class EntityTypeJavaActionParameterValue extends JavaActionParameterValue implements IEntityTypeJavaActionParameterValue {
		public static typeName: string = "Microflows$EntityTypeJavaActionParameterValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.8.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaActionParameterMapping() { return super.getContainerAs<JavaActionParameterMapping>(JavaActionParameterMapping); }

		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(EntityTypeJavaActionParameterValue, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EntityTypeJavaActionParameterValue() cannot be invoked directly, please use 'model.microflows.createEntityTypeJavaActionParameterValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new EntityTypeJavaActionParameterValue instance in the SDK and on the server.
		 * The new EntityTypeJavaActionParameterValue will be automatically stored in the 'value' property
		 * of the parent JavaActionParameterMapping element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createIn(container: JavaActionParameterMapping): EntityTypeJavaActionParameterValue {
			internal.createInVersionCheck(container.model, EntityTypeJavaActionParameterValue.typeName,
				["6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, EntityTypeJavaActionParameterValue, "value", false);
		}

		/**
		 * Creates and returns a new EntityTypeJavaActionParameterValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EntityTypeJavaActionParameterValue {
			return internal.instancehelpers.createElement(model, EntityTypeJavaActionParameterValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IEnumerationCase extends ICaseValue {
		model: IModel;
		containerAsSequenceFlow: ISequenceFlow;
		load(): EnumerationCase;
		load(callback: (element: EnumerationCase) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class EnumerationCase extends CaseValue implements IEnumerationCase {
		public static typeName: string = "Microflows$EnumerationCase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsSequenceFlow() { return super.getContainerAs<SequenceFlow>(SequenceFlow); }

		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(EnumerationCase, this, "value", "", internal.PrimitiveTypeEnum.String);
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EnumerationCase() cannot be invoked directly, please use 'model.microflows.createEnumerationCase()'"
				);
			}
		}

		/**
		 * Creates and returns a new EnumerationCase instance in the SDK and on the server.
		 * The new EnumerationCase will be automatically stored in the 'caseValue' property
		 * of the parent SequenceFlow element passed as argument.
		 */
		public static createIn(container: SequenceFlow): EnumerationCase {
			return internal.instancehelpers.createElement(container, EnumerationCase, "caseValue", false);
		}

		/**
		 * Creates and returns a new EnumerationCase instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EnumerationCase {
			return internal.instancehelpers.createElement(model, EnumerationCase);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/error-event relevant section in reference guide}
	 */
	export interface IErrorEvent extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): ErrorEvent;
		load(callback: (element: ErrorEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/error-event relevant section in reference guide}
	 */
	export class ErrorEvent extends MicroflowObject implements IErrorEvent {
		public static typeName: string = "Microflows$ErrorEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ErrorEvent() cannot be invoked directly, please use 'model.microflows.createErrorEvent()'"
				);
			}
		}

		/**
		 * Creates and returns a new ErrorEvent instance in the SDK and on the server.
		 * The new ErrorEvent will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): ErrorEvent {
			return internal.instancehelpers.createElement(container, ErrorEvent, "objects", true);
		}

		/**
		 * Creates and returns a new ErrorEvent instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ErrorEvent {
			return internal.instancehelpers.createElement(model, ErrorEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 20, height: 20 };
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/merge relevant section in reference guide}
	 */
	export interface IExclusiveMerge extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): ExclusiveMerge;
		load(callback: (element: ExclusiveMerge) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/merge relevant section in reference guide}
	 */
	export class ExclusiveMerge extends MicroflowObject implements IExclusiveMerge {
		public static typeName: string = "Microflows$ExclusiveMerge";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ExclusiveMerge() cannot be invoked directly, please use 'model.microflows.createExclusiveMerge()'"
				);
			}
		}

		/**
		 * Creates and returns a new ExclusiveMerge instance in the SDK and on the server.
		 * The new ExclusiveMerge will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): ExclusiveMerge {
			return internal.instancehelpers.createElement(container, ExclusiveMerge, "objects", true);
		}

		/**
		 * Creates and returns a new ExclusiveMerge instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ExclusiveMerge {
			return internal.instancehelpers.createElement(model, ExclusiveMerge);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 60, height: 40 };
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/exclusive-split relevant section in reference guide}
	 */
	export interface IExclusiveSplit extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): ExclusiveSplit;
		load(callback: (element: ExclusiveSplit) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/exclusive-split relevant section in reference guide}
	 */
	export class ExclusiveSplit extends MicroflowObject implements IExclusiveSplit {
		public static typeName: string = "Microflows$ExclusiveSplit";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"splitCondition" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __splitCondition: internal.PartProperty<SplitCondition> =
			new internal.PartProperty<SplitCondition>(ExclusiveSplit, this, "splitCondition", null, true);
		public get splitCondition(): SplitCondition { return this.__splitCondition.get(); }
		public set splitCondition(newValue: SplitCondition) { this.__splitCondition.set(newValue); }
		private __caption: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ExclusiveSplit, this, "caption", "", internal.PrimitiveTypeEnum.String);
		public get caption(): string { return this.__caption.get(); }
		public set caption(newValue: string) { this.__caption.set(newValue); }
		private __errorHandlingType: internal.EnumProperty<ErrorHandlingType> =
			new internal.EnumProperty<ErrorHandlingType>(ExclusiveSplit, this, "errorHandlingType", ErrorHandlingType.Rollback, ErrorHandlingType);
		public get errorHandlingType(): ErrorHandlingType { return this.__errorHandlingType.get(); }
		public set errorHandlingType(newValue: ErrorHandlingType) { this.__errorHandlingType.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ExclusiveSplit, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ExclusiveSplit() cannot be invoked directly, please use 'model.microflows.createExclusiveSplit()'"
				);
			}
		}

		/**
		 * Creates and returns a new ExclusiveSplit instance in the SDK and on the server.
		 * The new ExclusiveSplit will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): ExclusiveSplit {
			return internal.instancehelpers.createElement(container, ExclusiveSplit, "objects", true);
		}

		/**
		 * Creates and returns a new ExclusiveSplit instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ExclusiveSplit {
			return internal.instancehelpers.createElement(model, ExclusiveSplit);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.errorHandlingType = ErrorHandlingType.Rollback;
			this.size = { width: 60, height: 40 };
			this.splitCondition = ExpressionSplitCondition.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/export-mapping-action relevant section in reference guide}
	 */
	export interface IExportXmlAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ExportXmlAction;
		load(callback: (element: ExportXmlAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/export-mapping-action relevant section in reference guide}
	 */
	export class ExportXmlAction extends MicroflowAction implements IExportXmlAction {
		public static typeName: string = "Microflows$ExportXmlAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"outputMethod" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __mapping: internal.ByNameReferenceProperty<exportmappings.IExportMapping> =
			new internal.ByNameReferenceProperty<exportmappings.IExportMapping>(ExportXmlAction, this, "mapping", null, "ExportMappings$ExportMapping");
		public get mapping(): exportmappings.IExportMapping { return this.__mapping.get(); }
		public set mapping(newValue: exportmappings.IExportMapping) { this.__mapping.set(newValue); }
		get mappingQualifiedName(): string { return this.__mapping.qualifiedName(); }
		private __mappingArgumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ExportXmlAction, this, "mappingArgumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get mappingArgumentVariableName(): string { return this.__mappingArgumentVariableName.get(); }
		public set mappingArgumentVariableName(newValue: string) { this.__mappingArgumentVariableName.set(newValue); }
		private __outputMethod: internal.PartProperty<OutputMethod> =
			new internal.PartProperty<OutputMethod>(ExportXmlAction, this, "outputMethod", null, true);
		public get outputMethod(): OutputMethod { return this.__outputMethod.get(); }
		public set outputMethod(newValue: OutputMethod) { this.__outputMethod.set(newValue); }
		private __isValidationRequired: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ExportXmlAction, this, "isValidationRequired", false, internal.PrimitiveTypeEnum.Boolean);
		public get isValidationRequired(): boolean { return this.__isValidationRequired.get(); }
		public set isValidationRequired(newValue: boolean) { this.__isValidationRequired.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ExportXmlAction() cannot be invoked directly, please use 'model.microflows.createExportXmlAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ExportXmlAction instance in the SDK and on the server.
		 * The new ExportXmlAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ExportXmlAction {
			return internal.instancehelpers.createElement(container, ExportXmlAction, "action", false);
		}

		/**
		 * Creates and returns a new ExportXmlAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ExportXmlAction {
			return internal.instancehelpers.createElement(model, ExportXmlAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.outputMethod = FileDocumentExport.create(this.model);
		}

	}

	/**
	 * TODO : Abstract
	 */
	export interface ISplitCondition extends internal.IElement {
		model: IModel;
		containerAsExclusiveSplit: IExclusiveSplit;
		load(): SplitCondition;
		load(callback: (element: SplitCondition) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO : Abstract
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class SplitCondition extends internal.Element implements ISplitCondition {
		public static typeName: string = "Microflows$SplitCondition";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsExclusiveSplit() { return super.getContainerAs<ExclusiveSplit>(ExclusiveSplit); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SplitCondition() cannot be invoked directly, please use 'model.microflows.createSplitCondition()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IExpressionSplitCondition extends ISplitCondition {
		model: IModel;
		containerAsExclusiveSplit: IExclusiveSplit;
		load(): ExpressionSplitCondition;
		load(callback: (element: ExpressionSplitCondition) => void, forceRefresh?: boolean);
	}

	export class ExpressionSplitCondition extends SplitCondition implements IExpressionSplitCondition {
		public static typeName: string = "Microflows$ExpressionSplitCondition";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsExclusiveSplit() { return super.getContainerAs<ExclusiveSplit>(ExclusiveSplit); }

		private __expression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ExpressionSplitCondition, this, "expression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get expression(): string { return this.__expression.get(); }
		public set expression(newValue: string) { this.__expression.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ExpressionSplitCondition() cannot be invoked directly, please use 'model.microflows.createExpressionSplitCondition()'"
				);
			}
		}

		/**
		 * Creates and returns a new ExpressionSplitCondition instance in the SDK and on the server.
		 * The new ExpressionSplitCondition will be automatically stored in the 'splitCondition' property
		 * of the parent ExclusiveSplit element passed as argument.
		 */
		public static createIn(container: ExclusiveSplit): ExpressionSplitCondition {
			return internal.instancehelpers.createElement(container, ExpressionSplitCondition, "splitCondition", false);
		}

		/**
		 * Creates and returns a new ExpressionSplitCondition instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ExpressionSplitCondition {
			return internal.instancehelpers.createElement(model, ExpressionSplitCondition);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IOutputMethod extends internal.IElement {
		model: IModel;
		containerAsExportXmlAction: IExportXmlAction;
		load(): OutputMethod;
		load(callback: (element: OutputMethod) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class OutputMethod extends internal.Element implements IOutputMethod {
		public static typeName: string = "Microflows$OutputMethod";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsExportXmlAction() { return super.getContainerAs<ExportXmlAction>(ExportXmlAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new OutputMethod() cannot be invoked directly, please use 'model.microflows.createOutputMethod()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IFileDocumentExport extends IOutputMethod {
		model: IModel;
		containerAsExportXmlAction: IExportXmlAction;
		load(): FileDocumentExport;
		load(callback: (element: FileDocumentExport) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class FileDocumentExport extends OutputMethod implements IFileDocumentExport {
		public static typeName: string = "Microflows$FileDocumentExport";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsExportXmlAction() { return super.getContainerAs<ExportXmlAction>(ExportXmlAction); }

		private __targetDocumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(FileDocumentExport, this, "targetDocumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get targetDocumentVariableName(): string { return this.__targetDocumentVariableName.get(); }
		public set targetDocumentVariableName(newValue: string) { this.__targetDocumentVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new FileDocumentExport() cannot be invoked directly, please use 'model.microflows.createFileDocumentExport()'"
				);
			}
		}

		/**
		 * Creates and returns a new FileDocumentExport instance in the SDK and on the server.
		 * The new FileDocumentExport will be automatically stored in the 'outputMethod' property
		 * of the parent ExportXmlAction element passed as argument.
		 */
		public static createIn(container: ExportXmlAction): FileDocumentExport {
			return internal.instancehelpers.createElement(container, FileDocumentExport, "outputMethod", false);
		}

		/**
		 * Creates and returns a new FileDocumentExport instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): FileDocumentExport {
			return internal.instancehelpers.createElement(model, FileDocumentExport);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IInspectAttribute extends IListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): InspectAttribute;
		load(callback: (element: InspectAttribute) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class InspectAttribute extends ListOperation implements IInspectAttribute {
		public static typeName: string = "Microflows$InspectAttribute";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"association" : {
					"introduced" : "7.0.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }

		private __expression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(InspectAttribute, this, "expression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get expression(): string { return this.__expression.get(); }
		public set expression(newValue: string) { this.__expression.set(newValue); }
		private __attribute: internal.ByNameReferenceProperty<domainmodels.IAttribute> =
			new internal.ByNameReferenceProperty<domainmodels.IAttribute>(InspectAttribute, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): domainmodels.IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: domainmodels.IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __association: internal.ByNameReferenceProperty<domainmodels.IAssociationBase> =
			new internal.ByNameReferenceProperty<domainmodels.IAssociationBase>(InspectAttribute, this, "association", null, "DomainModels$AssociationBase");
		/**
		 * In version 7.0.0: introduced
		 */
		public get association(): domainmodels.IAssociationBase { return this.__association.get(); }
		public set association(newValue: domainmodels.IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new InspectAttribute() cannot be invoked directly, please use 'model.microflows.createInspectAttribute()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFilter extends IInspectAttribute {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Filter;
		load(callback: (element: Filter) => void, forceRefresh?: boolean);
	}

	export class Filter extends InspectAttribute implements IFilter {
		public static typeName: string = "Microflows$Filter";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Filter() cannot be invoked directly, please use 'model.microflows.createFilter()'"
				);
			}
		}

		/**
		 * Creates and returns a new Filter instance in the SDK and on the server.
		 * The new Filter will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Filter {
			return internal.instancehelpers.createElement(container, Filter, "operation", false);
		}

		/**
		 * Creates and returns a new Filter instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Filter {
			return internal.instancehelpers.createElement(model, Filter);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFind extends IInspectAttribute {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Find;
		load(callback: (element: Find) => void, forceRefresh?: boolean);
	}

	export class Find extends InspectAttribute implements IFind {
		public static typeName: string = "Microflows$Find";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Find() cannot be invoked directly, please use 'model.microflows.createFind()'"
				);
			}
		}

		/**
		 * Creates and returns a new Find instance in the SDK and on the server.
		 * The new Find will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Find {
			return internal.instancehelpers.createElement(container, Find, "operation", false);
		}

		/**
		 * Creates and returns a new Find instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Find {
			return internal.instancehelpers.createElement(model, Find);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/generate-document relevant section in reference guide}
	 */
	export interface IGenerateDocumentAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): GenerateDocumentAction;
		load(callback: (element: GenerateDocumentAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/generate-document relevant section in reference guide}
	 */
	export class GenerateDocumentAction extends MicroflowAction implements IGenerateDocumentAction {
		public static typeName: string = "Microflows$GenerateDocumentAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __parameterMappings: internal.PartListProperty<DocumentTemplateParameterMapping> =
			new internal.PartListProperty<DocumentTemplateParameterMapping>(GenerateDocumentAction, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<DocumentTemplateParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<DocumentTemplateParameterMapping>) { this.__parameterMappings.set(newValue); }
		private __fileVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "fileVariableName", "", internal.PrimitiveTypeEnum.String);
		public get fileVariableName(): string { return this.__fileVariableName.get(); }
		public set fileVariableName(newValue: string) { this.__fileVariableName.set(newValue); }
		private __languageVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "languageVariableName", "", internal.PrimitiveTypeEnum.String);
		public get languageVariableName(): string { return this.__languageVariableName.get(); }
		public set languageVariableName(newValue: string) { this.__languageVariableName.set(newValue); }
		private __documentType: internal.EnumProperty<TargetDocumentType> =
			new internal.EnumProperty<TargetDocumentType>(GenerateDocumentAction, this, "documentType", TargetDocumentType.HTML, TargetDocumentType);
		public get documentType(): TargetDocumentType { return this.__documentType.get(); }
		public set documentType(newValue: TargetDocumentType) { this.__documentType.set(newValue); }
		private __languageSetting: internal.EnumProperty<LanguageSettingType> =
			new internal.EnumProperty<LanguageSettingType>(GenerateDocumentAction, this, "languageSetting", LanguageSettingType.CurrentUser, LanguageSettingType);
		public get languageSetting(): LanguageSettingType { return this.__languageSetting.get(); }
		public set languageSetting(newValue: LanguageSettingType) { this.__languageSetting.set(newValue); }
		private __documentTemplate: internal.ByNameReferenceProperty<documenttemplates.IDocumentTemplate> =
			new internal.ByNameReferenceProperty<documenttemplates.IDocumentTemplate>(GenerateDocumentAction, this, "documentTemplate", null, "DocumentTemplates$DocumentTemplate");
		public get documentTemplate(): documenttemplates.IDocumentTemplate { return this.__documentTemplate.get(); }
		public set documentTemplate(newValue: documenttemplates.IDocumentTemplate) { this.__documentTemplate.set(newValue); }
		get documentTemplateQualifiedName(): string { return this.__documentTemplate.qualifiedName(); }
		private __overrideTopMargin: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(GenerateDocumentAction, this, "overrideTopMargin", false, internal.PrimitiveTypeEnum.Boolean);
		public get overrideTopMargin(): boolean { return this.__overrideTopMargin.get(); }
		public set overrideTopMargin(newValue: boolean) { this.__overrideTopMargin.set(newValue); }
		private __overrideBottomMargin: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(GenerateDocumentAction, this, "overrideBottomMargin", false, internal.PrimitiveTypeEnum.Boolean);
		public get overrideBottomMargin(): boolean { return this.__overrideBottomMargin.get(); }
		public set overrideBottomMargin(newValue: boolean) { this.__overrideBottomMargin.set(newValue); }
		private __overrideLeftMargin: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(GenerateDocumentAction, this, "overrideLeftMargin", false, internal.PrimitiveTypeEnum.Boolean);
		public get overrideLeftMargin(): boolean { return this.__overrideLeftMargin.get(); }
		public set overrideLeftMargin(newValue: boolean) { this.__overrideLeftMargin.set(newValue); }
		private __overrideRightMargin: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(GenerateDocumentAction, this, "overrideRightMargin", false, internal.PrimitiveTypeEnum.Boolean);
		public get overrideRightMargin(): boolean { return this.__overrideRightMargin.get(); }
		public set overrideRightMargin(newValue: boolean) { this.__overrideRightMargin.set(newValue); }
		private __marginLeftInInch: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "marginLeftInInch", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get marginLeftInInch(): string { return this.__marginLeftInInch.get(); }
		public set marginLeftInInch(newValue: string) { this.__marginLeftInInch.set(newValue); }
		private __marginRightInInch: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "marginRightInInch", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get marginRightInInch(): string { return this.__marginRightInInch.get(); }
		public set marginRightInInch(newValue: string) { this.__marginRightInInch.set(newValue); }
		private __marginTopInInch: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "marginTopInInch", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get marginTopInInch(): string { return this.__marginTopInInch.get(); }
		public set marginTopInInch(newValue: string) { this.__marginTopInInch.set(newValue); }
		private __marginBottomInInch: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(GenerateDocumentAction, this, "marginBottomInInch", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get marginBottomInInch(): string { return this.__marginBottomInInch.get(); }
		public set marginBottomInInch(newValue: string) { this.__marginBottomInInch.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new GenerateDocumentAction() cannot be invoked directly, please use 'model.microflows.createGenerateDocumentAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new GenerateDocumentAction instance in the SDK and on the server.
		 * The new GenerateDocumentAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): GenerateDocumentAction {
			return internal.instancehelpers.createElement(container, GenerateDocumentAction, "action", false);
		}

		/**
		 * Creates and returns a new GenerateDocumentAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): GenerateDocumentAction {
			return internal.instancehelpers.createElement(model, GenerateDocumentAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.documentType = TargetDocumentType.HTML;
			this.languageSetting = LanguageSettingType.CurrentUser;
			this.marginBottomInInch = "0";
			this.marginLeftInInch = "0";
			this.marginRightInInch = "0";
			this.marginTopInInch = "0";
		}

	}

	export interface IHead extends IListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Head;
		load(callback: (element: Head) => void, forceRefresh?: boolean);
	}

	export class Head extends ListOperation implements IHead {
		public static typeName: string = "Microflows$Head";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Head() cannot be invoked directly, please use 'model.microflows.createHead()'"
				);
			}
		}

		/**
		 * Creates and returns a new Head instance in the SDK and on the server.
		 * The new Head will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Head {
			return internal.instancehelpers.createElement(container, Head, "operation", false);
		}

		/**
		 * Creates and returns a new Head instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Head {
			return internal.instancehelpers.createElement(model, Head);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IHttpConfiguration extends internal.IElement {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): HttpConfiguration;
		load(callback: (element: HttpConfiguration) => void, forceRefresh?: boolean);
	}

	export class HttpConfiguration extends internal.Element implements IHttpConfiguration {
		public static typeName: string = "Microflows$HttpConfiguration";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"customLocationTemplate" : {
					"introduced" : "6.6.0"
				},
				"httpMethod" : {
					"introduced" : "6.6.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __overrideLocation: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(HttpConfiguration, this, "overrideLocation", false, internal.PrimitiveTypeEnum.Boolean);
		public get overrideLocation(): boolean { return this.__overrideLocation.get(); }
		public set overrideLocation(newValue: boolean) { this.__overrideLocation.set(newValue); }
		private __customLocation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(HttpConfiguration, this, "customLocation", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get customLocation(): string { return this.__customLocation.get(); }
		public set customLocation(newValue: string) { this.__customLocation.set(newValue); }
		private __customLocationTemplate: internal.PartProperty<StringTemplate> =
			new internal.PartProperty<StringTemplate>(HttpConfiguration, this, "customLocationTemplate", null, false);
		/**
		 * In version 6.6.0: introduced
		 */
		public get customLocationTemplate(): StringTemplate { return this.__customLocationTemplate.get(); }
		public set customLocationTemplate(newValue: StringTemplate) { this.__customLocationTemplate.set(newValue); }
		private __useAuthentication: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(HttpConfiguration, this, "useAuthentication", false, internal.PrimitiveTypeEnum.Boolean);
		public get useAuthentication(): boolean { return this.__useAuthentication.get(); }
		public set useAuthentication(newValue: boolean) { this.__useAuthentication.set(newValue); }
		private __httpAuthenticationUserName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(HttpConfiguration, this, "httpAuthenticationUserName", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get httpAuthenticationUserName(): string { return this.__httpAuthenticationUserName.get(); }
		public set httpAuthenticationUserName(newValue: string) { this.__httpAuthenticationUserName.set(newValue); }
		private __authenticationPassword: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(HttpConfiguration, this, "authenticationPassword", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get authenticationPassword(): string { return this.__authenticationPassword.get(); }
		public set authenticationPassword(newValue: string) { this.__authenticationPassword.set(newValue); }
		private __headerEntries: internal.PartListProperty<HttpHeaderEntry> =
			new internal.PartListProperty<HttpHeaderEntry>(HttpConfiguration, this, "headerEntries", []);
		public get headerEntries(): internal.IList<HttpHeaderEntry> { return this.__headerEntries.get(); }
		public set headerEntries(newValue: internal.IList<HttpHeaderEntry>) { this.__headerEntries.set(newValue); }
		private __httpMethod: internal.EnumProperty<HttpMethod> =
			new internal.EnumProperty<HttpMethod>(HttpConfiguration, this, "httpMethod", HttpMethod.Post, HttpMethod);
		/**
		 * In version 6.6.0: introduced
		 */
		public get httpMethod(): HttpMethod { return this.__httpMethod.get(); }
		public set httpMethod(newValue: HttpMethod) { this.__httpMethod.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new HttpConfiguration() cannot be invoked directly, please use 'model.microflows.createHttpConfiguration()'"
				);
			}
		}

		/**
		 * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
		 * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
		 * of the parent WebServiceCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.0, 6.0.1, 6.1.0, 6.2.0, 6.3.0, 6.4.0, 6.4.1, 6.5.0
		 */
		public static createIn(container: WebServiceCallAction): HttpConfiguration {
			internal.createInVersionCheck(container.model, HttpConfiguration.typeName,
				["6.0.0", "6.0.1", "6.1.0", "6.2.0", "6.3.0", "6.4.0", "6.4.1", "6.5.0"]
			);
			return internal.instancehelpers.createElement(container, HttpConfiguration, "httpConfiguration", false);
		}

		/**
		 * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
		 * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderHttpConfiguration(container: RestCallAction): HttpConfiguration {
			internal.createInVersionCheck(container.model, HttpConfiguration.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, HttpConfiguration, "httpConfiguration", false);
		}

		/**
		 * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
		 * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderHttpConfiguration(container: WebServiceCallAction): HttpConfiguration {
			return internal.instancehelpers.createElement(container, HttpConfiguration, "httpConfiguration", false);
		}

		/**
		 * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): HttpConfiguration {
			return internal.instancehelpers.createElement(model, HttpConfiguration);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			if (this.__httpMethod.isAvailable) {
				this.httpMethod = HttpMethod.Post;
			}
		}

	}

	/**
	 * TODO
	 */
	export interface IHttpHeaderEntry extends internal.IElement {
		model: IModel;
		containerAsHttpConfiguration: IHttpConfiguration;
		load(): HttpHeaderEntry;
		load(callback: (element: HttpHeaderEntry) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class HttpHeaderEntry extends internal.Element implements IHttpHeaderEntry {
		public static typeName: string = "Microflows$HttpHeaderEntry";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsHttpConfiguration() { return super.getContainerAs<HttpConfiguration>(HttpConfiguration); }

		private __key: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(HttpHeaderEntry, this, "key", "", internal.PrimitiveTypeEnum.String);
		public get key(): string { return this.__key.get(); }
		public set key(newValue: string) { this.__key.set(newValue); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(HttpHeaderEntry, this, "value", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new HttpHeaderEntry() cannot be invoked directly, please use 'model.microflows.createHttpHeaderEntry()'"
				);
			}
		}

		/**
		 * Creates and returns a new HttpHeaderEntry instance in the SDK and on the server.
		 * The new HttpHeaderEntry will be automatically stored in the 'headerEntries' property
		 * of the parent HttpConfiguration element passed as argument.
		 */
		public static createIn(container: HttpConfiguration): HttpHeaderEntry {
			return internal.instancehelpers.createElement(container, HttpHeaderEntry, "headerEntries", true);
		}

		/**
		 * Creates and returns a new HttpHeaderEntry instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): HttpHeaderEntry {
			return internal.instancehelpers.createElement(model, HttpHeaderEntry);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IImportMappingCall extends internal.IElement {
		model: IModel;
		containerAsResultHandling: IResultHandling;
		load(): ImportMappingCall;
		load(callback: (element: ImportMappingCall) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class ImportMappingCall extends internal.Element implements IImportMappingCall {
		public static typeName: string = "Microflows$ImportMappingCall";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"range" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsResultHandling() { return super.getContainerAs<ResultHandling>(ResultHandling); }

		private __mapping: internal.ByNameReferenceProperty<importmappings.IImportMapping> =
			new internal.ByNameReferenceProperty<importmappings.IImportMapping>(ImportMappingCall, this, "mapping", null, "ImportMappings$ImportMapping");
		public get mapping(): importmappings.IImportMapping { return this.__mapping.get(); }
		public set mapping(newValue: importmappings.IImportMapping) { this.__mapping.set(newValue); }
		get mappingQualifiedName(): string { return this.__mapping.qualifiedName(); }
		private __mappingArgumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ImportMappingCall, this, "mappingArgumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get mappingArgumentVariableName(): string { return this.__mappingArgumentVariableName.get(); }
		public set mappingArgumentVariableName(newValue: string) { this.__mappingArgumentVariableName.set(newValue); }
		private __range: internal.PartProperty<Range> =
			new internal.PartProperty<Range>(ImportMappingCall, this, "range", null, true);
		public get range(): Range { return this.__range.get(); }
		public set range(newValue: Range) { this.__range.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ImportMappingCall() cannot be invoked directly, please use 'model.microflows.createImportMappingCall()'"
				);
			}
		}

		/**
		 * Creates and returns a new ImportMappingCall instance in the SDK and on the server.
		 * The new ImportMappingCall will be automatically stored in the 'importMappingCall' property
		 * of the parent ResultHandling element passed as argument.
		 */
		public static createIn(container: ResultHandling): ImportMappingCall {
			return internal.instancehelpers.createElement(container, ImportMappingCall, "importMappingCall", false);
		}

		/**
		 * Creates and returns a new ImportMappingCall instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ImportMappingCall {
			return internal.instancehelpers.createElement(model, ImportMappingCall);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.range = ConstantRange.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/import-mapping-action relevant section in reference guide}
	 */
	export interface IImportXmlAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ImportXmlAction;
		load(callback: (element: ImportXmlAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/import-mapping-action relevant section in reference guide}
	 */
	export class ImportXmlAction extends MicroflowAction implements IImportXmlAction {
		public static typeName: string = "Microflows$ImportXmlAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"resultHandling" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __xmlDocumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ImportXmlAction, this, "xmlDocumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get xmlDocumentVariableName(): string { return this.__xmlDocumentVariableName.get(); }
		public set xmlDocumentVariableName(newValue: string) { this.__xmlDocumentVariableName.set(newValue); }
		private __resultHandling: internal.PartProperty<ResultHandling> =
			new internal.PartProperty<ResultHandling>(ImportXmlAction, this, "resultHandling", null, true);
		public get resultHandling(): ResultHandling { return this.__resultHandling.get(); }
		public set resultHandling(newValue: ResultHandling) { this.__resultHandling.set(newValue); }
		private __isValidationRequired: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ImportXmlAction, this, "isValidationRequired", false, internal.PrimitiveTypeEnum.Boolean);
		public get isValidationRequired(): boolean { return this.__isValidationRequired.get(); }
		public set isValidationRequired(newValue: boolean) { this.__isValidationRequired.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ImportXmlAction() cannot be invoked directly, please use 'model.microflows.createImportXmlAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ImportXmlAction instance in the SDK and on the server.
		 * The new ImportXmlAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ImportXmlAction {
			return internal.instancehelpers.createElement(container, ImportXmlAction, "action", false);
		}

		/**
		 * Creates and returns a new ImportXmlAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ImportXmlAction {
			return internal.instancehelpers.createElement(model, ImportXmlAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.resultHandling = ResultHandling.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface IInheritanceCase extends ICaseValue {
		model: IModel;
		containerAsSequenceFlow: ISequenceFlow;
		load(): InheritanceCase;
		load(callback: (element: InheritanceCase) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class InheritanceCase extends CaseValue implements IInheritanceCase {
		public static typeName: string = "Microflows$InheritanceCase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsSequenceFlow() { return super.getContainerAs<SequenceFlow>(SequenceFlow); }

		private __value: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(InheritanceCase, this, "value", null, "DomainModels$Entity");
		public get value(): domainmodels.IEntity { return this.__value.get(); }
		public set value(newValue: domainmodels.IEntity) { this.__value.set(newValue); }
		get valueQualifiedName(): string { return this.__value.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new InheritanceCase() cannot be invoked directly, please use 'model.microflows.createInheritanceCase()'"
				);
			}
		}

		/**
		 * Creates and returns a new InheritanceCase instance in the SDK and on the server.
		 * The new InheritanceCase will be automatically stored in the 'caseValue' property
		 * of the parent SequenceFlow element passed as argument.
		 */
		public static createIn(container: SequenceFlow): InheritanceCase {
			return internal.instancehelpers.createElement(container, InheritanceCase, "caseValue", false);
		}

		/**
		 * Creates and returns a new InheritanceCase instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): InheritanceCase {
			return internal.instancehelpers.createElement(model, InheritanceCase);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/inheritance-split relevant section in reference guide}
	 */
	export interface IInheritanceSplit extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): InheritanceSplit;
		load(callback: (element: InheritanceSplit) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/inheritance-split relevant section in reference guide}
	 */
	export class InheritanceSplit extends MicroflowObject implements IInheritanceSplit {
		public static typeName: string = "Microflows$InheritanceSplit";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __splitVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(InheritanceSplit, this, "splitVariableName", "", internal.PrimitiveTypeEnum.String);
		public get splitVariableName(): string { return this.__splitVariableName.get(); }
		public set splitVariableName(newValue: string) { this.__splitVariableName.set(newValue); }
		private __caption: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(InheritanceSplit, this, "caption", "", internal.PrimitiveTypeEnum.String);
		public get caption(): string { return this.__caption.get(); }
		public set caption(newValue: string) { this.__caption.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(InheritanceSplit, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new InheritanceSplit() cannot be invoked directly, please use 'model.microflows.createInheritanceSplit()'"
				);
			}
		}

		/**
		 * Creates and returns a new InheritanceSplit instance in the SDK and on the server.
		 * The new InheritanceSplit will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): InheritanceSplit {
			return internal.instancehelpers.createElement(container, InheritanceSplit, "objects", true);
		}

		/**
		 * Creates and returns a new InheritanceSplit instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): InheritanceSplit {
			return internal.instancehelpers.createElement(model, InheritanceSplit);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 60, height: 40 };
		}

	}

	export interface IIntersect extends IBinaryListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Intersect;
		load(callback: (element: Intersect) => void, forceRefresh?: boolean);
	}

	export class Intersect extends BinaryListOperation implements IIntersect {
		public static typeName: string = "Microflows$Intersect";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Intersect() cannot be invoked directly, please use 'model.microflows.createIntersect()'"
				);
			}
		}

		/**
		 * Creates and returns a new Intersect instance in the SDK and on the server.
		 * The new Intersect will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Intersect {
			return internal.instancehelpers.createElement(container, Intersect, "operation", false);
		}

		/**
		 * Creates and returns a new Intersect instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Intersect {
			return internal.instancehelpers.createElement(model, Intersect);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/java-action-call relevant section in reference guide}
	 */
	export interface IJavaActionCallAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): JavaActionCallAction;
		load(callback: (element: JavaActionCallAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/java-action-call relevant section in reference guide}
	 */
	export class JavaActionCallAction extends MicroflowAction implements IJavaActionCallAction {
		public static typeName: string = "Microflows$JavaActionCallAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __javaAction: internal.ByNameReferenceProperty<javaactions.IJavaAction> =
			new internal.ByNameReferenceProperty<javaactions.IJavaAction>(JavaActionCallAction, this, "javaAction", null, "JavaActions$JavaAction");
		public get javaAction(): javaactions.IJavaAction { return this.__javaAction.get(); }
		public set javaAction(newValue: javaactions.IJavaAction) { this.__javaAction.set(newValue); }
		get javaActionQualifiedName(): string { return this.__javaAction.qualifiedName(); }
		private __parameterMappings: internal.PartListProperty<JavaActionParameterMapping> =
			new internal.PartListProperty<JavaActionParameterMapping>(JavaActionCallAction, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<JavaActionParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<JavaActionParameterMapping>) { this.__parameterMappings.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(JavaActionCallAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new JavaActionCallAction() cannot be invoked directly, please use 'model.microflows.createJavaActionCallAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new JavaActionCallAction instance in the SDK and on the server.
		 * The new JavaActionCallAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): JavaActionCallAction {
			return internal.instancehelpers.createElement(container, JavaActionCallAction, "action", false);
		}

		/**
		 * Creates and returns a new JavaActionCallAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): JavaActionCallAction {
			return internal.instancehelpers.createElement(model, JavaActionCallAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IJavaActionParameterMapping extends internal.IElement {
		model: IModel;
		containerAsJavaActionCallAction: IJavaActionCallAction;
		load(): JavaActionParameterMapping;
		load(callback: (element: JavaActionParameterMapping) => void, forceRefresh?: boolean);
	}

	export class JavaActionParameterMapping extends internal.Element implements IJavaActionParameterMapping {
		public static typeName: string = "Microflows$JavaActionParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"parameter" : {
					"required" : {
						"currentValue" : true
					}
				},
				"argument" : {
					"deleted" : "6.7.0",
					"deletionMessage" : null
				},
				"value" : {
					"introduced" : "6.7.0",
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaActionCallAction() { return super.getContainerAs<JavaActionCallAction>(JavaActionCallAction); }

		private __parameter: internal.ByNameReferenceProperty<javaactions.IJavaActionParameter> =
			new internal.ByNameReferenceProperty<javaactions.IJavaActionParameter>(JavaActionParameterMapping, this, "parameter", null, "JavaActions$JavaActionParameter");
		public get parameter(): javaactions.IJavaActionParameter { return this.__parameter.get(); }
		public set parameter(newValue: javaactions.IJavaActionParameter) { this.__parameter.set(newValue); }
		get parameterQualifiedName(): string { return this.__parameter.qualifiedName(); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(JavaActionParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 *
		 * In version 6.7.0: deleted
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }
		private __value: internal.PartProperty<JavaActionParameterValue> =
			new internal.PartProperty<JavaActionParameterValue>(JavaActionParameterMapping, this, "value", null, true);
		/**
		 * In version 6.7.0: introduced
		 */
		public get value(): JavaActionParameterValue { return this.__value.get(); }
		public set value(newValue: JavaActionParameterValue) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new JavaActionParameterMapping() cannot be invoked directly, please use 'model.microflows.createJavaActionParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new JavaActionParameterMapping instance in the SDK and on the server.
		 * The new JavaActionParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent JavaActionCallAction element passed as argument.
		 */
		public static createIn(container: JavaActionCallAction): JavaActionParameterMapping {
			return internal.instancehelpers.createElement(container, JavaActionParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new JavaActionParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): JavaActionParameterMapping {
			return internal.instancehelpers.createElement(model, JavaActionParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			if (this.__value.isAvailable) {
				this.value = BasicJavaActionParameterValue.create(this.model);
			}
		}

	}

	export interface IListEquals extends IBinaryListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): ListEquals;
		load(callback: (element: ListEquals) => void, forceRefresh?: boolean);
	}

	export class ListEquals extends BinaryListOperation implements IListEquals {
		public static typeName: string = "Microflows$ListEquals";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ListEquals() cannot be invoked directly, please use 'model.microflows.createListEquals()'"
				);
			}
		}

		/**
		 * Creates and returns a new ListEquals instance in the SDK and on the server.
		 * The new ListEquals will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): ListEquals {
			return internal.instancehelpers.createElement(container, ListEquals, "operation", false);
		}

		/**
		 * Creates and returns a new ListEquals instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ListEquals {
			return internal.instancehelpers.createElement(model, ListEquals);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/list-operation relevant section in reference guide}
	 */
	export interface IListOperationAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ListOperationAction;
		load(callback: (element: ListOperationAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/list-operation relevant section in reference guide}
	 */
	export class ListOperationAction extends MicroflowAction implements IListOperationAction {
		public static typeName: string = "Microflows$ListOperationAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __operation: internal.PartProperty<ListOperation> =
			new internal.PartProperty<ListOperation>(ListOperationAction, this, "operation", null, false);
		public get operation(): ListOperation { return this.__operation.get(); }
		public set operation(newValue: ListOperation) { this.__operation.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ListOperationAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ListOperationAction() cannot be invoked directly, please use 'model.microflows.createListOperationAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ListOperationAction instance in the SDK and on the server.
		 * The new ListOperationAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ListOperationAction {
			return internal.instancehelpers.createElement(container, ListOperationAction, "action", false);
		}

		/**
		 * Creates and returns a new ListOperationAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ListOperationAction {
			return internal.instancehelpers.createElement(model, ListOperationAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/log-message relevant section in reference guide}
	 */
	export interface ILogMessageAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): LogMessageAction;
		load(callback: (element: LogMessageAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/log-message relevant section in reference guide}
	 */
	export class LogMessageAction extends MicroflowAction implements ILogMessageAction {
		public static typeName: string = "Microflows$LogMessageAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"messageTemplate" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __level: internal.EnumProperty<LogLevel> =
			new internal.EnumProperty<LogLevel>(LogMessageAction, this, "level", LogLevel.Info, LogLevel);
		public get level(): LogLevel { return this.__level.get(); }
		public set level(newValue: LogLevel) { this.__level.set(newValue); }
		private __node: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(LogMessageAction, this, "node", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get node(): string { return this.__node.get(); }
		public set node(newValue: string) { this.__node.set(newValue); }
		private __messageTemplate: internal.PartProperty<StringTemplate> =
			new internal.PartProperty<StringTemplate>(LogMessageAction, this, "messageTemplate", null, true);
		public get messageTemplate(): StringTemplate { return this.__messageTemplate.get(); }
		public set messageTemplate(newValue: StringTemplate) { this.__messageTemplate.set(newValue); }
		private __includeLatestStackTrace: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(LogMessageAction, this, "includeLatestStackTrace", false, internal.PrimitiveTypeEnum.Boolean);
		public get includeLatestStackTrace(): boolean { return this.__includeLatestStackTrace.get(); }
		public set includeLatestStackTrace(newValue: boolean) { this.__includeLatestStackTrace.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new LogMessageAction() cannot be invoked directly, please use 'model.microflows.createLogMessageAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new LogMessageAction instance in the SDK and on the server.
		 * The new LogMessageAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): LogMessageAction {
			return internal.instancehelpers.createElement(container, LogMessageAction, "action", false);
		}

		/**
		 * Creates and returns a new LogMessageAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): LogMessageAction {
			return internal.instancehelpers.createElement(model, LogMessageAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.level = LogLevel.Info;
			this.messageTemplate = StringTemplate.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/loop relevant section in reference guide}
	 */
	export interface ILoopedActivity extends IActivity {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): LoopedActivity;
		load(callback: (element: LoopedActivity) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/loop relevant section in reference guide}
	 */
	export class LoopedActivity extends Activity implements ILoopedActivity {
		public static typeName: string = "Microflows$LoopedActivity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"objectCollection" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __objectCollection: internal.PartProperty<MicroflowObjectCollection> =
			new internal.PartProperty<MicroflowObjectCollection>(LoopedActivity, this, "objectCollection", null, true);
		public get objectCollection(): MicroflowObjectCollection { return this.__objectCollection.get(); }
		public set objectCollection(newValue: MicroflowObjectCollection) { this.__objectCollection.set(newValue); }
		private __iteratedListVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(LoopedActivity, this, "iteratedListVariableName", "", internal.PrimitiveTypeEnum.String);
		public get iteratedListVariableName(): string { return this.__iteratedListVariableName.get(); }
		public set iteratedListVariableName(newValue: string) { this.__iteratedListVariableName.set(newValue); }
		private __loopVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(LoopedActivity, this, "loopVariableName", "", internal.PrimitiveTypeEnum.String);
		public get loopVariableName(): string { return this.__loopVariableName.get(); }
		public set loopVariableName(newValue: string) { this.__loopVariableName.set(newValue); }
		private __errorHandlingType: internal.EnumProperty<ErrorHandlingType> =
			new internal.EnumProperty<ErrorHandlingType>(LoopedActivity, this, "errorHandlingType", ErrorHandlingType.Rollback, ErrorHandlingType);
		public get errorHandlingType(): ErrorHandlingType { return this.__errorHandlingType.get(); }
		public set errorHandlingType(newValue: ErrorHandlingType) { this.__errorHandlingType.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(LoopedActivity, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new LoopedActivity() cannot be invoked directly, please use 'model.microflows.createLoopedActivity()'"
				);
			}
		}

		/**
		 * Creates and returns a new LoopedActivity instance in the SDK and on the server.
		 * The new LoopedActivity will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): LoopedActivity {
			return internal.instancehelpers.createElement(container, LoopedActivity, "objects", true);
		}

		/**
		 * Creates and returns a new LoopedActivity instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): LoopedActivity {
			return internal.instancehelpers.createElement(model, LoopedActivity);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.errorHandlingType = ErrorHandlingType.Rollback;
			this.objectCollection = MicroflowObjectCollection.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface IMappingRequestHandling extends IRequestHandling {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): MappingRequestHandling;
		load(callback: (element: MappingRequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class MappingRequestHandling extends RequestHandling implements IMappingRequestHandling {
		public static typeName: string = "Microflows$MappingRequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __mapping: internal.ByNameReferenceProperty<exportmappings.IExportMapping> =
			new internal.ByNameReferenceProperty<exportmappings.IExportMapping>(MappingRequestHandling, this, "mapping", null, "ExportMappings$ExportMapping");
		public get mapping(): exportmappings.IExportMapping { return this.__mapping.get(); }
		public set mapping(newValue: exportmappings.IExportMapping) { this.__mapping.set(newValue); }
		get mappingQualifiedName(): string { return this.__mapping.qualifiedName(); }
		private __mappingArgumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingRequestHandling, this, "mappingArgumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get mappingArgumentVariableName(): string { return this.__mappingArgumentVariableName.get(); }
		public set mappingArgumentVariableName(newValue: string) { this.__mappingArgumentVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MappingRequestHandling() cannot be invoked directly, please use 'model.microflows.createMappingRequestHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
		 * The new MappingRequestHandling will be automatically stored in the 'requestHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderRequestHandling(container: RestCallAction): MappingRequestHandling {
			internal.createInVersionCheck(container.model, MappingRequestHandling.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, MappingRequestHandling, "requestHandling", false);
		}

		/**
		 * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
		 * The new MappingRequestHandling will be automatically stored in the 'requestBodyHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): MappingRequestHandling {
			return internal.instancehelpers.createElement(container, MappingRequestHandling, "requestBodyHandling", false);
		}

		/**
		 * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
		 * The new MappingRequestHandling will be automatically stored in the 'requestHeaderHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): MappingRequestHandling {
			return internal.instancehelpers.createElement(container, MappingRequestHandling, "requestHeaderHandling", false);
		}

		/**
		 * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MappingRequestHandling {
			return internal.instancehelpers.createElement(model, MappingRequestHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IMemberChange extends internal.IElement {
		model: IModel;
		containerAsChangeMembersAction: IChangeMembersAction;
		load(): MemberChange;
		load(callback: (element: MemberChange) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class MemberChange extends internal.Element implements IMemberChange {
		public static typeName: string = "Microflows$MemberChange";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsChangeMembersAction() { return super.getContainerAs<ChangeMembersAction>(ChangeMembersAction); }

		private __attribute: internal.ByNameReferenceProperty<domainmodels.IAttribute> =
			new internal.ByNameReferenceProperty<domainmodels.IAttribute>(MemberChange, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): domainmodels.IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: domainmodels.IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __association: internal.ByNameReferenceProperty<domainmodels.IAssociationBase> =
			new internal.ByNameReferenceProperty<domainmodels.IAssociationBase>(MemberChange, this, "association", null, "DomainModels$AssociationBase");
		public get association(): domainmodels.IAssociationBase { return this.__association.get(); }
		public set association(newValue: domainmodels.IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }
		private __type: internal.EnumProperty<ChangeActionItemType> =
			new internal.EnumProperty<ChangeActionItemType>(MemberChange, this, "type", ChangeActionItemType.Set, ChangeActionItemType);
		public get type(): ChangeActionItemType { return this.__type.get(); }
		public set type(newValue: ChangeActionItemType) { this.__type.set(newValue); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MemberChange, this, "value", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MemberChange() cannot be invoked directly, please use 'model.microflows.createMemberChange()'"
				);
			}
		}

		/**
		 * Creates and returns a new MemberChange instance in the SDK and on the server.
		 * The new MemberChange will be automatically stored in the 'items' property
		 * of the parent ChangeMembersAction element passed as argument.
		 */
		public static createIn(container: ChangeMembersAction): MemberChange {
			return internal.instancehelpers.createElement(container, MemberChange, "items", true);
		}

		/**
		 * Creates and returns a new MemberChange instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MemberChange {
			return internal.instancehelpers.createElement(model, MemberChange);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = ChangeActionItemType.Set;
		}

	}

	/**
	 * TODO: Abstract
	 */
	export interface IMicroflowBase extends projects.IDocument {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		returnType: string;
		load(): MicroflowBase;
		load(callback: (element: MicroflowBase) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: Abstract
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MicroflowBase extends projects.Document implements IMicroflowBase {
		public static typeName: string = "Microflows$MicroflowBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"objectCollection" : {
					"required" : {
						"currentValue" : true
					}
				},
				"returnType" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }

		private __objectCollection: internal.PartProperty<MicroflowObjectCollection> =
			new internal.PartProperty<MicroflowObjectCollection>(MicroflowBase, this, "objectCollection", null, true);
		public get objectCollection(): MicroflowObjectCollection { return this.__objectCollection.get(); }
		public set objectCollection(newValue: MicroflowObjectCollection) { this.__objectCollection.set(newValue); }
		private __flows: internal.PartListProperty<Flow> =
			new internal.PartListProperty<Flow>(MicroflowBase, this, "flows", []);
		public get flows(): internal.IList<Flow> { return this.__flows.get(); }
		public set flows(newValue: internal.IList<Flow>) { this.__flows.set(newValue); }
		private __returnType: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowBase, this, "returnType", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get returnType(): string { return this.__returnType.get(); }
		public set returnType(newValue: string) { this.__returnType.set(newValue); }
		private __applyEntityAccess: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(MicroflowBase, this, "applyEntityAccess", false, internal.PrimitiveTypeEnum.Boolean);
		public get applyEntityAccess(): boolean { return this.__applyEntityAccess.get(); }
		public set applyEntityAccess(newValue: boolean) { this.__applyEntityAccess.set(newValue); }
		private __markAsUsed: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(MicroflowBase, this, "markAsUsed", false, internal.PrimitiveTypeEnum.Boolean);
		public get markAsUsed(): boolean { return this.__markAsUsed.get(); }
		public set markAsUsed(newValue: boolean) { this.__markAsUsed.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.objectCollection = MicroflowObjectCollection.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/microflows relevant section in reference guide}
	 */
	export interface IMicroflow extends IMicroflowBase {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		load(): Microflow;
		load(callback: (element: Microflow) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/microflows relevant section in reference guide}
	 */
	export class Microflow extends MicroflowBase implements IMicroflow {
		public static typeName: string = "Microflows$Microflow";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"concurrencyErrorMessage" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }

		private __allowedModuleRoles: internal.ByNameReferenceListProperty<security.IModuleRole> =
			new internal.ByNameReferenceListProperty<security.IModuleRole>(Microflow, this, "allowedModuleRoles", [], "Security$ModuleRole");
		public get allowedModuleRoles(): internal.IList<security.IModuleRole> { return this.__allowedModuleRoles.get(); }
		public set allowedModuleRoles(newValue: internal.IList<security.IModuleRole>) { this.__allowedModuleRoles.set(newValue); }
		get allowedModuleRolesQualifiedNames(): string[] { return this.__allowedModuleRoles.qualifiedNames(); }
		private __allowConcurrentExecution: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Microflow, this, "allowConcurrentExecution", false, internal.PrimitiveTypeEnum.Boolean);
		public get allowConcurrentExecution(): boolean { return this.__allowConcurrentExecution.get(); }
		public set allowConcurrentExecution(newValue: boolean) { this.__allowConcurrentExecution.set(newValue); }
		private __concurrencyErrorMessage: internal.PartProperty<texts.Text> =
			new internal.PartProperty<texts.Text>(Microflow, this, "concurrencyErrorMessage", null, true);
		public get concurrencyErrorMessage(): texts.Text { return this.__concurrencyErrorMessage.get(); }
		public set concurrencyErrorMessage(newValue: texts.Text) { this.__concurrencyErrorMessage.set(newValue); }
		private __concurrencyErrorMicroflow: internal.ByNameReferenceProperty<IMicroflow> =
			new internal.ByNameReferenceProperty<IMicroflow>(Microflow, this, "concurrencyErrorMicroflow", null, "Microflows$Microflow");
		public get concurrencyErrorMicroflow(): IMicroflow { return this.__concurrencyErrorMicroflow.get(); }
		public set concurrencyErrorMicroflow(newValue: IMicroflow) { this.__concurrencyErrorMicroflow.set(newValue); }
		get concurrencyErrorMicroflowQualifiedName(): string { return this.__concurrencyErrorMicroflow.qualifiedName(); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "documents";
		}

		/**
		 * Creates a new Microflow unit in the SDK and on the server.
		 * Expects one argument, the projects.IFolderBase in which this unit is contained.
		 */
		public static createIn(container: projects.IFolderBase): Microflow {
			return internal.instancehelpers.createUnit(container, Microflow);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.allowConcurrentExecution = true;
			this.concurrencyErrorMessage = texts.Text.create(this.model);
			this.returnType = "Void";
		}

	}

	export interface IMicroflowCall extends internal.IElement {
		model: IModel;
		containerAsMicroflowCallAction: IMicroflowCallAction;
		load(): MicroflowCall;
		load(callback: (element: MicroflowCall) => void, forceRefresh?: boolean);
	}

	export class MicroflowCall extends internal.Element implements IMicroflowCall {
		public static typeName: string = "Microflows$MicroflowCall";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowCallAction() { return super.getContainerAs<MicroflowCallAction>(MicroflowCallAction); }

		private __microflow: internal.ByNameReferenceProperty<IMicroflow> =
			new internal.ByNameReferenceProperty<IMicroflow>(MicroflowCall, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }
		private __parameterMappings: internal.PartListProperty<MicroflowCallParameterMapping> =
			new internal.PartListProperty<MicroflowCallParameterMapping>(MicroflowCall, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<MicroflowCallParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<MicroflowCallParameterMapping>) { this.__parameterMappings.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowCall() cannot be invoked directly, please use 'model.microflows.createMicroflowCall()'"
				);
			}
		}

		/**
		 * Creates and returns a new MicroflowCall instance in the SDK and on the server.
		 * The new MicroflowCall will be automatically stored in the 'microflowCall' property
		 * of the parent MicroflowCallAction element passed as argument.
		 */
		public static createIn(container: MicroflowCallAction): MicroflowCall {
			return internal.instancehelpers.createElement(container, MicroflowCall, "microflowCall", false);
		}

		/**
		 * Creates and returns a new MicroflowCall instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowCall {
			return internal.instancehelpers.createElement(model, MicroflowCall);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/microflow-call relevant section in reference guide}
	 */
	export interface IMicroflowCallAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): MicroflowCallAction;
		load(callback: (element: MicroflowCallAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/microflow-call relevant section in reference guide}
	 */
	export class MicroflowCallAction extends MicroflowAction implements IMicroflowCallAction {
		public static typeName: string = "Microflows$MicroflowCallAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"microflowCall" : {
					"required" : {
						"currentValue" : true,
						"changedIn" : [
							"6.0.0"
						]
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __microflowCall: internal.PartProperty<MicroflowCall> =
			new internal.PartProperty<MicroflowCall>(MicroflowCallAction, this, "microflowCall", null, true);
		/**
		 * In version 6.0.0: removed optional
		 */
		public get microflowCall(): MicroflowCall { return this.__microflowCall.get(); }
		public set microflowCall(newValue: MicroflowCall) { this.__microflowCall.set(newValue); }
		private __useReturnVariable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(MicroflowCallAction, this, "useReturnVariable", false, internal.PrimitiveTypeEnum.Boolean);
		public get useReturnVariable(): boolean { return this.__useReturnVariable.get(); }
		public set useReturnVariable(newValue: boolean) { this.__useReturnVariable.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowCallAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowCallAction() cannot be invoked directly, please use 'model.microflows.createMicroflowCallAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new MicroflowCallAction instance in the SDK and on the server.
		 * The new MicroflowCallAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): MicroflowCallAction {
			return internal.instancehelpers.createElement(container, MicroflowCallAction, "action", false);
		}

		/**
		 * Creates and returns a new MicroflowCallAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowCallAction {
			return internal.instancehelpers.createElement(model, MicroflowCallAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.microflowCall = MicroflowCall.create(this.model);
			this.useReturnVariable = true;
		}

	}

	export interface IMicroflowCallParameterMapping extends internal.IElement {
		model: IModel;
		containerAsMicroflowCall: IMicroflowCall;
		load(): MicroflowCallParameterMapping;
		load(callback: (element: MicroflowCallParameterMapping) => void, forceRefresh?: boolean);
	}

	export class MicroflowCallParameterMapping extends internal.Element implements IMicroflowCallParameterMapping {
		public static typeName: string = "Microflows$MicroflowCallParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"parameter" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowCall() { return super.getContainerAs<MicroflowCall>(MicroflowCall); }

		private __parameter: internal.ByNameReferenceProperty<IMicroflowParameter> =
			new internal.ByNameReferenceProperty<IMicroflowParameter>(MicroflowCallParameterMapping, this, "parameter", null, "Microflows$MicroflowParameter");
		public get parameter(): IMicroflowParameter { return this.__parameter.get(); }
		public set parameter(newValue: IMicroflowParameter) { this.__parameter.set(newValue); }
		get parameterQualifiedName(): string { return this.__parameter.qualifiedName(); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowCallParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowCallParameterMapping() cannot be invoked directly, please use 'model.microflows.createMicroflowCallParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new MicroflowCallParameterMapping instance in the SDK and on the server.
		 * The new MicroflowCallParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent MicroflowCall element passed as argument.
		 */
		public static createIn(container: MicroflowCall): MicroflowCallParameterMapping {
			return internal.instancehelpers.createElement(container, MicroflowCallParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new MicroflowCallParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowCallParameterMapping {
			return internal.instancehelpers.createElement(model, MicroflowCallParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.9.0: introduced
	 */
	export interface IMicroflowJavaActionParameterValue extends IJavaActionParameterValue {
		model: IModel;
		containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
		load(): MicroflowJavaActionParameterValue;
		load(callback: (element: MicroflowJavaActionParameterValue) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.9.0: introduced
	 */
	export class MicroflowJavaActionParameterValue extends JavaActionParameterValue implements IMicroflowJavaActionParameterValue {
		public static typeName: string = "Microflows$MicroflowJavaActionParameterValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.9.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaActionParameterMapping() { return super.getContainerAs<JavaActionParameterMapping>(JavaActionParameterMapping); }

		private __microflow: internal.ByNameReferenceProperty<IMicroflow> =
			new internal.ByNameReferenceProperty<IMicroflow>(MicroflowJavaActionParameterValue, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowJavaActionParameterValue() cannot be invoked directly, please use 'model.microflows.createMicroflowJavaActionParameterValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new MicroflowJavaActionParameterValue instance in the SDK and on the server.
		 * The new MicroflowJavaActionParameterValue will be automatically stored in the 'value' property
		 * of the parent JavaActionParameterMapping element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createIn(container: JavaActionParameterMapping): MicroflowJavaActionParameterValue {
			internal.createInVersionCheck(container.model, MicroflowJavaActionParameterValue.typeName,
				["6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, MicroflowJavaActionParameterValue, "value", false);
		}

		/**
		 * Creates and returns a new MicroflowJavaActionParameterValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowJavaActionParameterValue {
			return internal.instancehelpers.createElement(model, MicroflowJavaActionParameterValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO: artificial object
	 */
	export interface IMicroflowObjectCollection extends internal.IElement {
		model: IModel;
		containerAsLoopedActivity: ILoopedActivity;
		containerAsMicroflowBase: IMicroflowBase;
		load(): MicroflowObjectCollection;
		load(callback: (element: MicroflowObjectCollection) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO: artificial object
	 */
	export class MicroflowObjectCollection extends internal.Element implements IMicroflowObjectCollection {
		public static typeName: string = "Microflows$MicroflowObjectCollection";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsLoopedActivity() { return super.getContainerAs<LoopedActivity>(LoopedActivity); }
		get containerAsMicroflowBase() { return super.getContainerAs<MicroflowBase>(MicroflowBase); }

		private __objects: internal.PartListProperty<MicroflowObject> =
			new internal.PartListProperty<MicroflowObject>(MicroflowObjectCollection, this, "objects", []);
		public get objects(): internal.IList<MicroflowObject> { return this.__objects.get(); }
		public set objects(newValue: internal.IList<MicroflowObject>) { this.__objects.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowObjectCollection() cannot be invoked directly, please use 'model.microflows.createMicroflowObjectCollection()'"
				);
			}
		}


		/**
		 * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
		 * The new MicroflowObjectCollection will be automatically stored in the 'objectCollection' property
		 * of the parent LoopedActivity element passed as argument.
		 */
		public static createInLoopedActivityUnderObjectCollection(container: LoopedActivity): MicroflowObjectCollection {
			return internal.instancehelpers.createElement(container, MicroflowObjectCollection, "objectCollection", false);
		}

		/**
		 * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
		 * The new MicroflowObjectCollection will be automatically stored in the 'objectCollection' property
		 * of the parent MicroflowBase element passed as argument.
		 */
		public static createInMicroflowBaseUnderObjectCollection(container: MicroflowBase): MicroflowObjectCollection {
			return internal.instancehelpers.createElement(container, MicroflowObjectCollection, "objectCollection", false);
		}

		/**
		 * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowObjectCollection {
			return internal.instancehelpers.createElement(model, MicroflowObjectCollection);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMicroflowParameterBase extends internal.IElement {
		model: IModel;
		containerAsMicroflow: IMicroflow;
		containerAsRule: IRule;
		name: string;
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		type: string;
		load(): MicroflowParameterBase;
		load(callback: (element: MicroflowParameterBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MicroflowParameterBase extends internal.Element implements IMicroflowParameterBase {
		public static typeName: string = "Microflows$MicroflowParameterBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"type" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflow() { return super.getContainerAs<Microflow>(Microflow); }
		get containerAsRule() { return super.getContainerAs<Rule>(Rule); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowParameterBase, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __type: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowParameterBase, this, "type", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get type(): string { return this.__type.get(); }
		public set type(newValue: string) { this.__type.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowParameterBase() cannot be invoked directly, please use 'model.microflows.createMicroflowParameterBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = "Unknown";
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
	 */
	export interface IMicroflowParameter extends IMicroflowParameterBase {
		model: IModel;
		containerAsMicroflow: IMicroflow;
		load(): MicroflowParameter;
		load(callback: (element: MicroflowParameter) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
	 */
	export class MicroflowParameter extends MicroflowParameterBase implements IMicroflowParameter {
		public static typeName: string = "Microflows$MicroflowParameter";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflow() { return super.getContainerAs<Microflow>(Microflow); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowParameter() cannot be invoked directly, please use 'model.microflows.createMicroflowParameter()'"
				);
			}
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMicroflowParameterObject extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): MicroflowParameterObject;
		load(callback: (element: MicroflowParameterObject) => void, forceRefresh?: boolean);
	}

	export class MicroflowParameterObject extends MicroflowObject implements IMicroflowParameterObject {
		public static typeName: string = "Microflows$MicroflowParameterObject";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowParameterObject, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __type: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowParameterObject, this, "type", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get type(): string { return this.__type.get(); }
		public set type(newValue: string) { this.__type.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MicroflowParameterObject, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MicroflowParameterObject() cannot be invoked directly, please use 'model.microflows.createMicroflowParameterObject()'"
				);
			}
		}

		/**
		 * Creates and returns a new MicroflowParameterObject instance in the SDK and on the server.
		 * The new MicroflowParameterObject will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): MicroflowParameterObject {
			return internal.instancehelpers.createElement(container, MicroflowParameterObject, "objects", true);
		}

		/**
		 * Creates and returns a new MicroflowParameterObject instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MicroflowParameterObject {
			return internal.instancehelpers.createElement(model, MicroflowParameterObject);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 30, height: 30 };
			this.type = "Unknown";
		}

	}

	/**
	 * TODO
	 */
	export interface INoCase extends ICaseValue {
		model: IModel;
		containerAsSequenceFlow: ISequenceFlow;
		load(): NoCase;
		load(callback: (element: NoCase) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class NoCase extends CaseValue implements INoCase {
		public static typeName: string = "Microflows$NoCase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsSequenceFlow() { return super.getContainerAs<SequenceFlow>(SequenceFlow); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new NoCase() cannot be invoked directly, please use 'model.microflows.createNoCase()'"
				);
			}
		}

		/**
		 * Creates and returns a new NoCase instance in the SDK and on the server.
		 * The new NoCase will be automatically stored in the 'caseValue' property
		 * of the parent SequenceFlow element passed as argument.
		 */
		public static createIn(container: SequenceFlow): NoCase {
			return internal.instancehelpers.createElement(container, NoCase, "caseValue", false);
		}

		/**
		 * Creates and returns a new NoCase instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): NoCase {
			return internal.instancehelpers.createElement(model, NoCase);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/call-rest-action relevant section in reference guide}
	 *
	 * In version 6.6.0: introduced
	 */
	export interface IRestCallAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): RestCallAction;
		load(callback: (element: RestCallAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/call-rest-action relevant section in reference guide}
	 *
	 * In version 6.6.0: introduced
	 */
	export class RestCallAction extends MicroflowAction implements IRestCallAction {
		public static typeName: string = "Microflows$RestCallAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.6.0",
			"properties" : {
				"httpConfiguration" : {
					"required" : {
						"currentValue" : true
					}
				},
				"requestHandling" : {
					"required" : {
						"currentValue" : true
					}
				},
				"requestHandlingType" : {
					"introduced" : "6.9.0"
				},
				"resultHandling" : {
					"required" : {
						"currentValue" : true
					}
				},
				"resultHandlingType" : {
					"introduced" : "6.9.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __httpConfiguration: internal.PartProperty<HttpConfiguration> =
			new internal.PartProperty<HttpConfiguration>(RestCallAction, this, "httpConfiguration", null, true);
		public get httpConfiguration(): HttpConfiguration { return this.__httpConfiguration.get(); }
		public set httpConfiguration(newValue: HttpConfiguration) { this.__httpConfiguration.set(newValue); }
		private __requestHandling: internal.PartProperty<RequestHandling> =
			new internal.PartProperty<RequestHandling>(RestCallAction, this, "requestHandling", null, true);
		public get requestHandling(): RequestHandling { return this.__requestHandling.get(); }
		public set requestHandling(newValue: RequestHandling) { this.__requestHandling.set(newValue); }
		private __requestHandlingType: internal.EnumProperty<RequestHandlingType> =
			new internal.EnumProperty<RequestHandlingType>(RestCallAction, this, "requestHandlingType", RequestHandlingType.Custom, RequestHandlingType);
		/**
		 * In version 6.9.0: introduced
		 */
		public get requestHandlingType(): RequestHandlingType { return this.__requestHandlingType.get(); }
		public set requestHandlingType(newValue: RequestHandlingType) { this.__requestHandlingType.set(newValue); }
		private __resultHandling: internal.PartProperty<ResultHandling> =
			new internal.PartProperty<ResultHandling>(RestCallAction, this, "resultHandling", null, true);
		public get resultHandling(): ResultHandling { return this.__resultHandling.get(); }
		public set resultHandling(newValue: ResultHandling) { this.__resultHandling.set(newValue); }
		private __resultHandlingType: internal.EnumProperty<ResultHandlingType> =
			new internal.EnumProperty<ResultHandlingType>(RestCallAction, this, "resultHandlingType", ResultHandlingType.None, ResultHandlingType);
		/**
		 * In version 6.9.0: introduced
		 */
		public get resultHandlingType(): ResultHandlingType { return this.__resultHandlingType.get(); }
		public set resultHandlingType(newValue: ResultHandlingType) { this.__resultHandlingType.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RestCallAction() cannot be invoked directly, please use 'model.microflows.createRestCallAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new RestCallAction instance in the SDK and on the server.
		 * The new RestCallAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createIn(container: ActionActivity): RestCallAction {
			internal.createInVersionCheck(container.model, RestCallAction.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, RestCallAction, "action", false);
		}

		/**
		 * Creates and returns a new RestCallAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RestCallAction {
			return internal.instancehelpers.createElement(model, RestCallAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.httpConfiguration = HttpConfiguration.create(this.model);
			this.requestHandling = CustomRequestHandling.create(this.model);
			if (this.__requestHandlingType.isAvailable) {
				this.requestHandlingType = RequestHandlingType.Custom;
			}
			this.resultHandling = ResultHandling.create(this.model);
			if (this.__resultHandlingType.isAvailable) {
				this.resultHandlingType = ResultHandlingType.None;
			}
		}

	}

	/**
	 * TODO
	 */
	export interface IResultHandling extends internal.IElement {
		model: IModel;
		containerAsImportXmlAction: IImportXmlAction;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): ResultHandling;
		load(callback: (element: ResultHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class ResultHandling extends internal.Element implements IResultHandling {
		public static typeName: string = "Microflows$ResultHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"variableDataType" : {
					"introduced" : "6.10.0",
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsImportXmlAction() { return super.getContainerAs<ImportXmlAction>(ImportXmlAction); }
		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __importMappingCall: internal.PartProperty<ImportMappingCall> =
			new internal.PartProperty<ImportMappingCall>(ResultHandling, this, "importMappingCall", null, false);
		public get importMappingCall(): ImportMappingCall { return this.__importMappingCall.get(); }
		public set importMappingCall(newValue: ImportMappingCall) { this.__importMappingCall.set(newValue); }
		private __storeInVariable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ResultHandling, this, "storeInVariable", false, internal.PrimitiveTypeEnum.Boolean);
		public get storeInVariable(): boolean { return this.__storeInVariable.get(); }
		public set storeInVariable(newValue: boolean) { this.__storeInVariable.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ResultHandling, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }
		private __variableDataType: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ResultHandling, this, "variableDataType", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 *
		 * In version 6.10.0: introduced
		 */
		public get variableDataType(): string { return this.__variableDataType.get(); }
		public set variableDataType(newValue: string) { this.__variableDataType.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ResultHandling() cannot be invoked directly, please use 'model.microflows.createResultHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new ResultHandling instance in the SDK and on the server.
		 * The new ResultHandling will be automatically stored in the 'resultHandling' property
		 * of the parent ImportXmlAction element passed as argument.
		 */
		public static createInImportXmlActionUnderResultHandling(container: ImportXmlAction): ResultHandling {
			return internal.instancehelpers.createElement(container, ResultHandling, "resultHandling", false);
		}

		/**
		 * Creates and returns a new ResultHandling instance in the SDK and on the server.
		 * The new ResultHandling will be automatically stored in the 'resultHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderResultHandling(container: RestCallAction): ResultHandling {
			internal.createInVersionCheck(container.model, ResultHandling.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, ResultHandling, "resultHandling", false);
		}

		/**
		 * Creates and returns a new ResultHandling instance in the SDK and on the server.
		 * The new ResultHandling will be automatically stored in the 'resultHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderResultHandling(container: WebServiceCallAction): ResultHandling {
			return internal.instancehelpers.createElement(container, ResultHandling, "resultHandling", false);
		}

		/**
		 * Creates and returns a new ResultHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ResultHandling {
			return internal.instancehelpers.createElement(model, ResultHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			if (this.__variableDataType.isAvailable) {
				this.variableDataType = "DataType.Void";
			}
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/retrieve relevant section in reference guide}
	 */
	export interface IRetrieveAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): RetrieveAction;
		load(callback: (element: RetrieveAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/retrieve relevant section in reference guide}
	 */
	export class RetrieveAction extends MicroflowAction implements IRetrieveAction {
		public static typeName: string = "Microflows$RetrieveAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"retrieveSource" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __retrieveSource: internal.PartProperty<RetrieveSource> =
			new internal.PartProperty<RetrieveSource>(RetrieveAction, this, "retrieveSource", null, true);
		public get retrieveSource(): RetrieveSource { return this.__retrieveSource.get(); }
		public set retrieveSource(newValue: RetrieveSource) { this.__retrieveSource.set(newValue); }
		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RetrieveAction, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RetrieveAction() cannot be invoked directly, please use 'model.microflows.createRetrieveAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new RetrieveAction instance in the SDK and on the server.
		 * The new RetrieveAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): RetrieveAction {
			return internal.instancehelpers.createElement(container, RetrieveAction, "action", false);
		}

		/**
		 * Creates and returns a new RetrieveAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RetrieveAction {
			return internal.instancehelpers.createElement(model, RetrieveAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.retrieveSource = AssociationRetrieveSource.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/rollback-object relevant section in reference guide}
	 */
	export interface IRollbackAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): RollbackAction;
		load(callback: (element: RollbackAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/rollback-object relevant section in reference guide}
	 */
	export class RollbackAction extends MicroflowAction implements IRollbackAction {
		public static typeName: string = "Microflows$RollbackAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __rollbackVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RollbackAction, this, "rollbackVariableName", "", internal.PrimitiveTypeEnum.String);
		public get rollbackVariableName(): string { return this.__rollbackVariableName.get(); }
		public set rollbackVariableName(newValue: string) { this.__rollbackVariableName.set(newValue); }
		private __refreshInClient: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(RollbackAction, this, "refreshInClient", false, internal.PrimitiveTypeEnum.Boolean);
		public get refreshInClient(): boolean { return this.__refreshInClient.get(); }
		public set refreshInClient(newValue: boolean) { this.__refreshInClient.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RollbackAction() cannot be invoked directly, please use 'model.microflows.createRollbackAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new RollbackAction instance in the SDK and on the server.
		 * The new RollbackAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): RollbackAction {
			return internal.instancehelpers.createElement(container, RollbackAction, "action", false);
		}

		/**
		 * Creates and returns a new RollbackAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RollbackAction {
			return internal.instancehelpers.createElement(model, RollbackAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/rules relevant section in reference guide}
	 */
	export interface IRule extends IMicroflowBase {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		load(): Rule;
		load(callback: (element: Rule) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/rules relevant section in reference guide}
	 */
	export class Rule extends MicroflowBase implements IRule {
		public static typeName: string = "Microflows$Rule";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }


		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "documents";
		}

		/**
		 * Creates a new Rule unit in the SDK and on the server.
		 * Expects one argument, the projects.IFolderBase in which this unit is contained.
		 */
		public static createIn(container: projects.IFolderBase): Rule {
			return internal.instancehelpers.createUnit(container, Rule);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.returnType = "Boolean";
		}

	}

	/**
	 * TODO
	 */
	export interface IRuleCall extends internal.IElement {
		model: IModel;
		containerAsRuleSplitCondition: IRuleSplitCondition;
		load(): RuleCall;
		load(callback: (element: RuleCall) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class RuleCall extends internal.Element implements IRuleCall {
		public static typeName: string = "Microflows$RuleCall";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsRuleSplitCondition() { return super.getContainerAs<RuleSplitCondition>(RuleSplitCondition); }

		private __rule: internal.ByNameReferenceProperty<IRule> =
			new internal.ByNameReferenceProperty<IRule>(RuleCall, this, "rule", null, "Microflows$Rule");
		public get rule(): IRule { return this.__rule.get(); }
		public set rule(newValue: IRule) { this.__rule.set(newValue); }
		get ruleQualifiedName(): string { return this.__rule.qualifiedName(); }
		private __parameterMappings: internal.PartListProperty<RuleCallParameterMapping> =
			new internal.PartListProperty<RuleCallParameterMapping>(RuleCall, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<RuleCallParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<RuleCallParameterMapping>) { this.__parameterMappings.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuleCall() cannot be invoked directly, please use 'model.microflows.createRuleCall()'"
				);
			}
		}

		/**
		 * Creates and returns a new RuleCall instance in the SDK and on the server.
		 * The new RuleCall will be automatically stored in the 'ruleCall' property
		 * of the parent RuleSplitCondition element passed as argument.
		 */
		public static createIn(container: RuleSplitCondition): RuleCall {
			return internal.instancehelpers.createElement(container, RuleCall, "ruleCall", false);
		}

		/**
		 * Creates and returns a new RuleCall instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RuleCall {
			return internal.instancehelpers.createElement(model, RuleCall);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IRuleCallParameterMapping extends internal.IElement {
		model: IModel;
		containerAsRuleCall: IRuleCall;
		load(): RuleCallParameterMapping;
		load(callback: (element: RuleCallParameterMapping) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class RuleCallParameterMapping extends internal.Element implements IRuleCallParameterMapping {
		public static typeName: string = "Microflows$RuleCallParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"parameter" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRuleCall() { return super.getContainerAs<RuleCall>(RuleCall); }

		private __parameter: internal.ByNameReferenceProperty<IRuleParameter> =
			new internal.ByNameReferenceProperty<IRuleParameter>(RuleCallParameterMapping, this, "parameter", null, "Microflows$RuleParameter");
		public get parameter(): IRuleParameter { return this.__parameter.get(); }
		public set parameter(newValue: IRuleParameter) { this.__parameter.set(newValue); }
		get parameterQualifiedName(): string { return this.__parameter.qualifiedName(); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RuleCallParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuleCallParameterMapping() cannot be invoked directly, please use 'model.microflows.createRuleCallParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new RuleCallParameterMapping instance in the SDK and on the server.
		 * The new RuleCallParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent RuleCall element passed as argument.
		 */
		public static createIn(container: RuleCall): RuleCallParameterMapping {
			return internal.instancehelpers.createElement(container, RuleCallParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new RuleCallParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RuleCallParameterMapping {
			return internal.instancehelpers.createElement(model, RuleCallParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
	 */
	export interface IRuleParameter extends IMicroflowParameterBase {
		model: IModel;
		containerAsRule: IRule;
		load(): RuleParameter;
		load(callback: (element: RuleParameter) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
	 */
	export class RuleParameter extends MicroflowParameterBase implements IRuleParameter {
		public static typeName: string = "Microflows$RuleParameter";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRule() { return super.getContainerAs<Rule>(Rule); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuleParameter() cannot be invoked directly, please use 'model.microflows.createRuleParameter()'"
				);
			}
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IRuleSplitCondition extends ISplitCondition {
		model: IModel;
		containerAsExclusiveSplit: IExclusiveSplit;
		load(): RuleSplitCondition;
		load(callback: (element: RuleSplitCondition) => void, forceRefresh?: boolean);
	}

	export class RuleSplitCondition extends SplitCondition implements IRuleSplitCondition {
		public static typeName: string = "Microflows$RuleSplitCondition";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"ruleCall" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsExclusiveSplit() { return super.getContainerAs<ExclusiveSplit>(ExclusiveSplit); }

		private __ruleCall: internal.PartProperty<RuleCall> =
			new internal.PartProperty<RuleCall>(RuleSplitCondition, this, "ruleCall", null, true);
		public get ruleCall(): RuleCall { return this.__ruleCall.get(); }
		public set ruleCall(newValue: RuleCall) { this.__ruleCall.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuleSplitCondition() cannot be invoked directly, please use 'model.microflows.createRuleSplitCondition()'"
				);
			}
		}

		/**
		 * Creates and returns a new RuleSplitCondition instance in the SDK and on the server.
		 * The new RuleSplitCondition will be automatically stored in the 'splitCondition' property
		 * of the parent ExclusiveSplit element passed as argument.
		 */
		public static createIn(container: ExclusiveSplit): RuleSplitCondition {
			return internal.instancehelpers.createElement(container, RuleSplitCondition, "splitCondition", false);
		}

		/**
		 * Creates and returns a new RuleSplitCondition instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RuleSplitCondition {
			return internal.instancehelpers.createElement(model, RuleSplitCondition);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.ruleCall = RuleCall.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/sequence-flow relevant section in reference guide}
	 */
	export interface ISequenceFlow extends IFlow {
		model: IModel;
		containerAsMicroflowBase: IMicroflowBase;
		load(): SequenceFlow;
		load(callback: (element: SequenceFlow) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/sequence-flow relevant section in reference guide}
	 */
	export class SequenceFlow extends Flow implements ISequenceFlow {
		public static typeName: string = "Microflows$SequenceFlow";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"caseValue" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowBase() { return super.getContainerAs<MicroflowBase>(MicroflowBase); }

		private __caseValue: internal.PartProperty<CaseValue> =
			new internal.PartProperty<CaseValue>(SequenceFlow, this, "caseValue", null, true);
		public get caseValue(): CaseValue { return this.__caseValue.get(); }
		public set caseValue(newValue: CaseValue) { this.__caseValue.set(newValue); }
		private __isErrorHandler: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(SequenceFlow, this, "isErrorHandler", false, internal.PrimitiveTypeEnum.Boolean);
		public get isErrorHandler(): boolean { return this.__isErrorHandler.get(); }
		public set isErrorHandler(newValue: boolean) { this.__isErrorHandler.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SequenceFlow() cannot be invoked directly, please use 'model.microflows.createSequenceFlow()'"
				);
			}
		}

		/**
		 * Creates and returns a new SequenceFlow instance in the SDK and on the server.
		 * The new SequenceFlow will be automatically stored in the 'flows' property
		 * of the parent MicroflowBase element passed as argument.
		 */
		public static createIn(container: MicroflowBase): SequenceFlow {
			return internal.instancehelpers.createElement(container, SequenceFlow, "flows", true);
		}

		/**
		 * Creates and returns a new SequenceFlow instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SequenceFlow {
			return internal.instancehelpers.createElement(model, SequenceFlow);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.caseValue = NoCase.create(this.model);
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-home-page TODO: Page does not exist, should be created.}
	 */
	export interface IShowHomePageAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ShowHomePageAction;
		load(callback: (element: ShowHomePageAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-home-page TODO: Page does not exist, should be created.}
	 */
	export class ShowHomePageAction extends MicroflowAction implements IShowHomePageAction {
		public static typeName: string = "Microflows$ShowHomePageAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ShowHomePageAction() cannot be invoked directly, please use 'model.microflows.createShowHomePageAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ShowHomePageAction instance in the SDK and on the server.
		 * The new ShowHomePageAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ShowHomePageAction {
			return internal.instancehelpers.createElement(container, ShowHomePageAction, "action", false);
		}

		/**
		 * Creates and returns a new ShowHomePageAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ShowHomePageAction {
			return internal.instancehelpers.createElement(model, ShowHomePageAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-message relevant section in reference guide}
	 */
	export interface IShowMessageAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ShowMessageAction;
		load(callback: (element: ShowMessageAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-message relevant section in reference guide}
	 */
	export class ShowMessageAction extends MicroflowAction implements IShowMessageAction {
		public static typeName: string = "Microflows$ShowMessageAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"template" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __template: internal.PartProperty<TextTemplate> =
			new internal.PartProperty<TextTemplate>(ShowMessageAction, this, "template", null, true);
		public get template(): TextTemplate { return this.__template.get(); }
		public set template(newValue: TextTemplate) { this.__template.set(newValue); }
		private __type: internal.EnumProperty<ShowMessageType> =
			new internal.EnumProperty<ShowMessageType>(ShowMessageAction, this, "type", ShowMessageType.Information, ShowMessageType);
		public get type(): ShowMessageType { return this.__type.get(); }
		public set type(newValue: ShowMessageType) { this.__type.set(newValue); }
		private __blocking: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ShowMessageAction, this, "blocking", false, internal.PrimitiveTypeEnum.Boolean);
		public get blocking(): boolean { return this.__blocking.get(); }
		public set blocking(newValue: boolean) { this.__blocking.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ShowMessageAction() cannot be invoked directly, please use 'model.microflows.createShowMessageAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ShowMessageAction instance in the SDK and on the server.
		 * The new ShowMessageAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ShowMessageAction {
			return internal.instancehelpers.createElement(container, ShowMessageAction, "action", false);
		}

		/**
		 * Creates and returns a new ShowMessageAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ShowMessageAction {
			return internal.instancehelpers.createElement(model, ShowMessageAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.blocking = true;
			this.template = TextTemplate.create(this.model);
			this.type = ShowMessageType.Information;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-page relevant section in reference guide}
	 */
	export interface IShowPageAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ShowPageAction;
		load(callback: (element: ShowPageAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/show-page relevant section in reference guide}
	 */
	export class ShowPageAction extends MicroflowAction implements IShowPageAction {
		public static typeName: string = "Microflows$ShowPageAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"pageSettings" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __pageSettings: internal.PartProperty<pages.PageSettings> =
			new internal.PartProperty<pages.PageSettings>(ShowPageAction, this, "pageSettings", null, true);
		public get pageSettings(): pages.PageSettings { return this.__pageSettings.get(); }
		public set pageSettings(newValue: pages.PageSettings) { this.__pageSettings.set(newValue); }
		private __passedObjectVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ShowPageAction, this, "passedObjectVariableName", "", internal.PrimitiveTypeEnum.String);
		public get passedObjectVariableName(): string { return this.__passedObjectVariableName.get(); }
		public set passedObjectVariableName(newValue: string) { this.__passedObjectVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ShowPageAction() cannot be invoked directly, please use 'model.microflows.createShowPageAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ShowPageAction instance in the SDK and on the server.
		 * The new ShowPageAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ShowPageAction {
			return internal.instancehelpers.createElement(container, ShowPageAction, "action", false);
		}

		/**
		 * Creates and returns a new ShowPageAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ShowPageAction {
			return internal.instancehelpers.createElement(model, ShowPageAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.pageSettings = pages.PageSettings.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface ISimpleRequestHandling extends IRequestHandling {
		model: IModel;
		containerAsRestCallAction: IRestCallAction;
		containerAsWebServiceCallAction: IWebServiceCallAction;
		load(): SimpleRequestHandling;
		load(callback: (element: SimpleRequestHandling) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class SimpleRequestHandling extends RequestHandling implements ISimpleRequestHandling {
		public static typeName: string = "Microflows$SimpleRequestHandling";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"nullValueOption" : {
					"introduced" : "6.7.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsRestCallAction() { return super.getContainerAs<RestCallAction>(RestCallAction); }
		get containerAsWebServiceCallAction() { return super.getContainerAs<WebServiceCallAction>(WebServiceCallAction); }

		private __parameterMappings: internal.PartListProperty<WebServiceOperationSimpleParameterMapping> =
			new internal.PartListProperty<WebServiceOperationSimpleParameterMapping>(SimpleRequestHandling, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<WebServiceOperationSimpleParameterMapping> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<WebServiceOperationSimpleParameterMapping>) { this.__parameterMappings.set(newValue); }
		private __nullValueOption: internal.EnumProperty<NullValueOption> =
			new internal.EnumProperty<NullValueOption>(SimpleRequestHandling, this, "nullValueOption", NullValueOption.LeaveOutElement, NullValueOption);
		/**
		 * In version 6.7.0: introduced
		 */
		public get nullValueOption(): NullValueOption { return this.__nullValueOption.get(); }
		public set nullValueOption(newValue: NullValueOption) { this.__nullValueOption.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SimpleRequestHandling() cannot be invoked directly, please use 'model.microflows.createSimpleRequestHandling()'"
				);
			}
		}


		/**
		 * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
		 * The new SimpleRequestHandling will be automatically stored in the 'requestHandling' property
		 * of the parent RestCallAction element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInRestCallActionUnderRequestHandling(container: RestCallAction): SimpleRequestHandling {
			internal.createInVersionCheck(container.model, SimpleRequestHandling.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, SimpleRequestHandling, "requestHandling", false);
		}

		/**
		 * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
		 * The new SimpleRequestHandling will be automatically stored in the 'requestBodyHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): SimpleRequestHandling {
			return internal.instancehelpers.createElement(container, SimpleRequestHandling, "requestBodyHandling", false);
		}

		/**
		 * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
		 * The new SimpleRequestHandling will be automatically stored in the 'requestHeaderHandling' property
		 * of the parent WebServiceCallAction element passed as argument.
		 */
		public static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): SimpleRequestHandling {
			return internal.instancehelpers.createElement(container, SimpleRequestHandling, "requestHeaderHandling", false);
		}

		/**
		 * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SimpleRequestHandling {
			return internal.instancehelpers.createElement(model, SimpleRequestHandling);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			if (this.__nullValueOption.isAvailable) {
				this.nullValueOption = NullValueOption.LeaveOutElement;
			}
		}

	}

	export interface ISort extends IListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Sort;
		load(callback: (element: Sort) => void, forceRefresh?: boolean);
	}

	export class Sort extends ListOperation implements ISort {
		public static typeName: string = "Microflows$Sort";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"sortItemList" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }

		private __sortItemList: internal.PartProperty<SortItemList> =
			new internal.PartProperty<SortItemList>(Sort, this, "sortItemList", null, true);
		public get sortItemList(): SortItemList { return this.__sortItemList.get(); }
		public set sortItemList(newValue: SortItemList) { this.__sortItemList.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Sort() cannot be invoked directly, please use 'model.microflows.createSort()'"
				);
			}
		}

		/**
		 * Creates and returns a new Sort instance in the SDK and on the server.
		 * The new Sort will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Sort {
			return internal.instancehelpers.createElement(container, Sort, "operation", false);
		}

		/**
		 * Creates and returns a new Sort instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Sort {
			return internal.instancehelpers.createElement(model, Sort);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.sortItemList = SortItemList.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface ISortItem extends internal.IElement {
		model: IModel;
		containerAsSortItemList: ISortItemList;
		load(): SortItem;
		load(callback: (element: SortItem) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class SortItem extends internal.Element implements ISortItem {
		public static typeName: string = "Microflows$SortItem";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"attributePath" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsSortItemList() { return super.getContainerAs<SortItemList>(SortItemList); }

		private __attributePath: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(SortItem, this, "attributePath", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type paths.AttributePath.
		 */
		public get attributePath(): string { return this.__attributePath.get(); }
		public set attributePath(newValue: string) { this.__attributePath.set(newValue); }
		private __sortOrder: internal.EnumProperty<SortOrderEnum> =
			new internal.EnumProperty<SortOrderEnum>(SortItem, this, "sortOrder", SortOrderEnum.Ascending, SortOrderEnum);
		public get sortOrder(): SortOrderEnum { return this.__sortOrder.get(); }
		public set sortOrder(newValue: SortOrderEnum) { this.__sortOrder.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SortItem() cannot be invoked directly, please use 'model.microflows.createSortItem()'"
				);
			}
		}

		/**
		 * Creates and returns a new SortItem instance in the SDK and on the server.
		 * The new SortItem will be automatically stored in the 'items' property
		 * of the parent SortItemList element passed as argument.
		 */
		public static createIn(container: SortItemList): SortItem {
			return internal.instancehelpers.createElement(container, SortItem, "items", true);
		}

		/**
		 * Creates and returns a new SortItem instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SortItem {
			return internal.instancehelpers.createElement(model, SortItem);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.attributePath = "";
			this.sortOrder = SortOrderEnum.Ascending;
		}

	}

	/**
	 * TODO
	 */
	export interface ISortItemList extends internal.IElement {
		model: IModel;
		containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
		containerAsSort: ISort;
		load(): SortItemList;
		load(callback: (element: SortItemList) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class SortItemList extends internal.Element implements ISortItemList {
		public static typeName: string = "Microflows$SortItemList";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDatabaseRetrieveSource() { return super.getContainerAs<DatabaseRetrieveSource>(DatabaseRetrieveSource); }
		get containerAsSort() { return super.getContainerAs<Sort>(Sort); }

		private __items: internal.PartListProperty<SortItem> =
			new internal.PartListProperty<SortItem>(SortItemList, this, "items", []);
		public get items(): internal.IList<SortItem> { return this.__items.get(); }
		public set items(newValue: internal.IList<SortItem>) { this.__items.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SortItemList() cannot be invoked directly, please use 'model.microflows.createSortItemList()'"
				);
			}
		}


		/**
		 * Creates and returns a new SortItemList instance in the SDK and on the server.
		 * The new SortItemList will be automatically stored in the 'sortItemList' property
		 * of the parent DatabaseRetrieveSource element passed as argument.
		 */
		public static createInDatabaseRetrieveSourceUnderSortItemList(container: DatabaseRetrieveSource): SortItemList {
			return internal.instancehelpers.createElement(container, SortItemList, "sortItemList", false);
		}

		/**
		 * Creates and returns a new SortItemList instance in the SDK and on the server.
		 * The new SortItemList will be automatically stored in the 'sortItemList' property
		 * of the parent Sort element passed as argument.
		 */
		public static createInSortUnderSortItemList(container: Sort): SortItemList {
			return internal.instancehelpers.createElement(container, SortItemList, "sortItemList", false);
		}

		/**
		 * Creates and returns a new SortItemList instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SortItemList {
			return internal.instancehelpers.createElement(model, SortItemList);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/start-event relevant section in reference guide}
	 */
	export interface IStartEvent extends IMicroflowObject {
		model: IModel;
		containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
		load(): StartEvent;
		load(callback: (element: StartEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/start-event relevant section in reference guide}
	 */
	export class StartEvent extends MicroflowObject implements IStartEvent {
		public static typeName: string = "Microflows$StartEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMicroflowObjectCollection() { return super.getContainerAs<MicroflowObjectCollection>(MicroflowObjectCollection); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new StartEvent() cannot be invoked directly, please use 'model.microflows.createStartEvent()'"
				);
			}
		}

		/**
		 * Creates and returns a new StartEvent instance in the SDK and on the server.
		 * The new StartEvent will be automatically stored in the 'objects' property
		 * of the parent MicroflowObjectCollection element passed as argument.
		 */
		public static createIn(container: MicroflowObjectCollection): StartEvent {
			return internal.instancehelpers.createElement(container, StartEvent, "objects", true);
		}

		/**
		 * Creates and returns a new StartEvent instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): StartEvent {
			return internal.instancehelpers.createElement(model, StartEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.size = { width: 20, height: 20 };
		}

	}

	export interface ITemplate extends internal.IElement {
		model: IModel;
		containerAsCustomRequestHandling: ICustomRequestHandling;
		containerAsHttpConfiguration: IHttpConfiguration;
		containerAsLogMessageAction: ILogMessageAction;
		containerAsShowMessageAction: IShowMessageAction;
		containerAsValidationFeedbackAction: IValidationFeedbackAction;
		load(): Template;
		load(callback: (element: Template) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Template extends internal.Element implements ITemplate {
		public static typeName: string = "Microflows$Template";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsCustomRequestHandling() { return super.getContainerAs<CustomRequestHandling>(CustomRequestHandling); }
		get containerAsHttpConfiguration() { return super.getContainerAs<HttpConfiguration>(HttpConfiguration); }
		get containerAsLogMessageAction() { return super.getContainerAs<LogMessageAction>(LogMessageAction); }
		get containerAsShowMessageAction() { return super.getContainerAs<ShowMessageAction>(ShowMessageAction); }
		get containerAsValidationFeedbackAction() { return super.getContainerAs<ValidationFeedbackAction>(ValidationFeedbackAction); }

		private __arguments: internal.PartListProperty<TemplateArgument> =
			new internal.PartListProperty<TemplateArgument>(Template, this, "arguments", []);
		public get arguments(): internal.IList<TemplateArgument> { return this.__arguments.get(); }
		public set arguments(newValue: internal.IList<TemplateArgument>) { this.__arguments.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Template() cannot be invoked directly, please use 'model.microflows.createTemplate()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IStringTemplate extends ITemplate {
		model: IModel;
		containerAsCustomRequestHandling: ICustomRequestHandling;
		containerAsHttpConfiguration: IHttpConfiguration;
		containerAsLogMessageAction: ILogMessageAction;
		load(): StringTemplate;
		load(callback: (element: StringTemplate) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class StringTemplate extends Template implements IStringTemplate {
		public static typeName: string = "Microflows$StringTemplate";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsCustomRequestHandling() { return super.getContainerAs<CustomRequestHandling>(CustomRequestHandling); }
		get containerAsHttpConfiguration() { return super.getContainerAs<HttpConfiguration>(HttpConfiguration); }
		get containerAsLogMessageAction() { return super.getContainerAs<LogMessageAction>(LogMessageAction); }

		private __text: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(StringTemplate, this, "text", "", internal.PrimitiveTypeEnum.String);
		public get text(): string { return this.__text.get(); }
		public set text(newValue: string) { this.__text.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new StringTemplate() cannot be invoked directly, please use 'model.microflows.createStringTemplate()'"
				);
			}
		}


		/**
		 * Creates and returns a new StringTemplate instance in the SDK and on the server.
		 * The new StringTemplate will be automatically stored in the 'template' property
		 * of the parent CustomRequestHandling element passed as argument.
		 */
		public static createInCustomRequestHandlingUnderTemplate(container: CustomRequestHandling): StringTemplate {
			return internal.instancehelpers.createElement(container, StringTemplate, "template", false);
		}

		/**
		 * Creates and returns a new StringTemplate instance in the SDK and on the server.
		 * The new StringTemplate will be automatically stored in the 'customLocationTemplate' property
		 * of the parent HttpConfiguration element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createInHttpConfigurationUnderCustomLocationTemplate(container: HttpConfiguration): StringTemplate {
			internal.createInVersionCheck(container.model, StringTemplate.typeName,
				["6.6.0", "6.7.0", "6.8.0", "6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, StringTemplate, "customLocationTemplate", false);
		}

		/**
		 * Creates and returns a new StringTemplate instance in the SDK and on the server.
		 * The new StringTemplate will be automatically stored in the 'messageTemplate' property
		 * of the parent LogMessageAction element passed as argument.
		 */
		public static createInLogMessageActionUnderMessageTemplate(container: LogMessageAction): StringTemplate {
			return internal.instancehelpers.createElement(container, StringTemplate, "messageTemplate", false);
		}

		/**
		 * Creates and returns a new StringTemplate instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): StringTemplate {
			return internal.instancehelpers.createElement(model, StringTemplate);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ISubtract extends IBinaryListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Subtract;
		load(callback: (element: Subtract) => void, forceRefresh?: boolean);
	}

	export class Subtract extends BinaryListOperation implements ISubtract {
		public static typeName: string = "Microflows$Subtract";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Subtract() cannot be invoked directly, please use 'model.microflows.createSubtract()'"
				);
			}
		}

		/**
		 * Creates and returns a new Subtract instance in the SDK and on the server.
		 * The new Subtract will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Subtract {
			return internal.instancehelpers.createElement(container, Subtract, "operation", false);
		}

		/**
		 * Creates and returns a new Subtract instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Subtract {
			return internal.instancehelpers.createElement(model, Subtract);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ITail extends IListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Tail;
		load(callback: (element: Tail) => void, forceRefresh?: boolean);
	}

	export class Tail extends ListOperation implements ITail {
		public static typeName: string = "Microflows$Tail";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Tail() cannot be invoked directly, please use 'model.microflows.createTail()'"
				);
			}
		}

		/**
		 * Creates and returns a new Tail instance in the SDK and on the server.
		 * The new Tail will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Tail {
			return internal.instancehelpers.createElement(container, Tail, "operation", false);
		}

		/**
		 * Creates and returns a new Tail instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Tail {
			return internal.instancehelpers.createElement(model, Tail);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface ITemplateArgument extends internal.IElement {
		model: IModel;
		containerAsTemplate: ITemplate;
		load(): TemplateArgument;
		load(callback: (element: TemplateArgument) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class TemplateArgument extends internal.Element implements ITemplateArgument {
		public static typeName: string = "Microflows$TemplateArgument";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsTemplate() { return super.getContainerAs<Template>(Template); }

		private __expression: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(TemplateArgument, this, "expression", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get expression(): string { return this.__expression.get(); }
		public set expression(newValue: string) { this.__expression.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new TemplateArgument() cannot be invoked directly, please use 'model.microflows.createTemplateArgument()'"
				);
			}
		}

		/**
		 * Creates and returns a new TemplateArgument instance in the SDK and on the server.
		 * The new TemplateArgument will be automatically stored in the 'arguments' property
		 * of the parent Template element passed as argument.
		 */
		public static createIn(container: Template): TemplateArgument {
			return internal.instancehelpers.createElement(container, TemplateArgument, "arguments", true);
		}

		/**
		 * Creates and returns a new TemplateArgument instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): TemplateArgument {
			return internal.instancehelpers.createElement(model, TemplateArgument);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface ITextTemplate extends ITemplate {
		model: IModel;
		containerAsShowMessageAction: IShowMessageAction;
		containerAsValidationFeedbackAction: IValidationFeedbackAction;
		load(): TextTemplate;
		load(callback: (element: TextTemplate) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class TextTemplate extends Template implements ITextTemplate {
		public static typeName: string = "Microflows$TextTemplate";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"text" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsShowMessageAction() { return super.getContainerAs<ShowMessageAction>(ShowMessageAction); }
		get containerAsValidationFeedbackAction() { return super.getContainerAs<ValidationFeedbackAction>(ValidationFeedbackAction); }

		private __text: internal.PartProperty<texts.Text> =
			new internal.PartProperty<texts.Text>(TextTemplate, this, "text", null, true);
		public get text(): texts.Text { return this.__text.get(); }
		public set text(newValue: texts.Text) { this.__text.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new TextTemplate() cannot be invoked directly, please use 'model.microflows.createTextTemplate()'"
				);
			}
		}


		/**
		 * Creates and returns a new TextTemplate instance in the SDK and on the server.
		 * The new TextTemplate will be automatically stored in the 'template' property
		 * of the parent ShowMessageAction element passed as argument.
		 */
		public static createInShowMessageActionUnderTemplate(container: ShowMessageAction): TextTemplate {
			return internal.instancehelpers.createElement(container, TextTemplate, "template", false);
		}

		/**
		 * Creates and returns a new TextTemplate instance in the SDK and on the server.
		 * The new TextTemplate will be automatically stored in the 'feedbackTemplate' property
		 * of the parent ValidationFeedbackAction element passed as argument.
		 */
		public static createInValidationFeedbackActionUnderFeedbackTemplate(container: ValidationFeedbackAction): TextTemplate {
			return internal.instancehelpers.createElement(container, TextTemplate, "feedbackTemplate", false);
		}

		/**
		 * Creates and returns a new TextTemplate instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): TextTemplate {
			return internal.instancehelpers.createElement(model, TextTemplate);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.text = texts.Text.create(this.model);
		}

	}

	export interface IUnion extends IBinaryListOperation {
		model: IModel;
		containerAsListOperationAction: IListOperationAction;
		load(): Union;
		load(callback: (element: Union) => void, forceRefresh?: boolean);
	}

	export class Union extends BinaryListOperation implements IUnion {
		public static typeName: string = "Microflows$Union";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsListOperationAction() { return super.getContainerAs<ListOperationAction>(ListOperationAction); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Union() cannot be invoked directly, please use 'model.microflows.createUnion()'"
				);
			}
		}

		/**
		 * Creates and returns a new Union instance in the SDK and on the server.
		 * The new Union will be automatically stored in the 'operation' property
		 * of the parent ListOperationAction element passed as argument.
		 */
		public static createIn(container: ListOperationAction): Union {
			return internal.instancehelpers.createElement(container, Union, "operation", false);
		}

		/**
		 * Creates and returns a new Union instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Union {
			return internal.instancehelpers.createElement(model, Union);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/validation-feedback relevant section in reference guide}
	 */
	export interface IValidationFeedbackAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): ValidationFeedbackAction;
		load(callback: (element: ValidationFeedbackAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/validation-feedback relevant section in reference guide}
	 */
	export class ValidationFeedbackAction extends MicroflowAction implements IValidationFeedbackAction {
		public static typeName: string = "Microflows$ValidationFeedbackAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"feedbackTemplate" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __feedbackTemplate: internal.PartProperty<TextTemplate> =
			new internal.PartProperty<TextTemplate>(ValidationFeedbackAction, this, "feedbackTemplate", null, true);
		public get feedbackTemplate(): TextTemplate { return this.__feedbackTemplate.get(); }
		public set feedbackTemplate(newValue: TextTemplate) { this.__feedbackTemplate.set(newValue); }
		private __objectVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ValidationFeedbackAction, this, "objectVariableName", "", internal.PrimitiveTypeEnum.String);
		public get objectVariableName(): string { return this.__objectVariableName.get(); }
		public set objectVariableName(newValue: string) { this.__objectVariableName.set(newValue); }
		private __attribute: internal.ByNameReferenceProperty<domainmodels.IAttribute> =
			new internal.ByNameReferenceProperty<domainmodels.IAttribute>(ValidationFeedbackAction, this, "attribute", null, "DomainModels$Attribute");
		/**
		 * See: {@link https://docs.mendix.com/refguide7/validation-feedback See 'Member' section in reference guide}
		 */
		public get attribute(): domainmodels.IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: domainmodels.IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __association: internal.ByNameReferenceProperty<domainmodels.IAssociationBase> =
			new internal.ByNameReferenceProperty<domainmodels.IAssociationBase>(ValidationFeedbackAction, this, "association", null, "DomainModels$AssociationBase");
		/**
		 * See: {@link https://docs.mendix.com/refguide7/validation-feedback See 'Member' section in reference guide}
		 */
		public get association(): domainmodels.IAssociationBase { return this.__association.get(); }
		public set association(newValue: domainmodels.IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ValidationFeedbackAction() cannot be invoked directly, please use 'model.microflows.createValidationFeedbackAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new ValidationFeedbackAction instance in the SDK and on the server.
		 * The new ValidationFeedbackAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): ValidationFeedbackAction {
			return internal.instancehelpers.createElement(container, ValidationFeedbackAction, "action", false);
		}

		/**
		 * Creates and returns a new ValidationFeedbackAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ValidationFeedbackAction {
			return internal.instancehelpers.createElement(model, ValidationFeedbackAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.feedbackTemplate = TextTemplate.create(this.model);
		}

	}

	/**
	 * TODO
	 */
	export interface IVariableExport extends IOutputMethod {
		model: IModel;
		containerAsExportXmlAction: IExportXmlAction;
		load(): VariableExport;
		load(callback: (element: VariableExport) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class VariableExport extends OutputMethod implements IVariableExport {
		public static typeName: string = "Microflows$VariableExport";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsExportXmlAction() { return super.getContainerAs<ExportXmlAction>(ExportXmlAction); }

		private __outputVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(VariableExport, this, "outputVariableName", "", internal.PrimitiveTypeEnum.String);
		public get outputVariableName(): string { return this.__outputVariableName.get(); }
		public set outputVariableName(newValue: string) { this.__outputVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new VariableExport() cannot be invoked directly, please use 'model.microflows.createVariableExport()'"
				);
			}
		}

		/**
		 * Creates and returns a new VariableExport instance in the SDK and on the server.
		 * The new VariableExport will be automatically stored in the 'outputMethod' property
		 * of the parent ExportXmlAction element passed as argument.
		 */
		public static createIn(container: ExportXmlAction): VariableExport {
			return internal.instancehelpers.createElement(container, VariableExport, "outputMethod", false);
		}

		/**
		 * Creates and returns a new VariableExport instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): VariableExport {
			return internal.instancehelpers.createElement(model, VariableExport);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/call-web-service-action relevant section in reference guide}
	 */
	export interface IWebServiceCallAction extends IMicroflowAction {
		model: IModel;
		containerAsActionActivity: IActionActivity;
		load(): WebServiceCallAction;
		load(callback: (element: WebServiceCallAction) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/call-web-service-action relevant section in reference guide}
	 */
	export class WebServiceCallAction extends MicroflowAction implements IWebServiceCallAction {
		public static typeName: string = "Microflows$WebServiceCallAction";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"sendNullValueChoice" : {
					"deleted" : "6.7.0",
					"deletionMessage" : null
				},
				"requestHeaderHandling" : {
					"required" : {
						"currentValue" : true
					}
				},
				"requestBodyHandling" : {
					"required" : {
						"currentValue" : true
					}
				},
				"resultHandling" : {
					"required" : {
						"currentValue" : true
					}
				},
				"httpConfiguration" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsActionActivity() { return super.getContainerAs<ActionActivity>(ActionActivity); }

		private __importedWebService: internal.ByNameReferenceProperty<webservices.IImportedWebService> =
			new internal.ByNameReferenceProperty<webservices.IImportedWebService>(WebServiceCallAction, this, "importedWebService", null, "WebServices$ImportedWebService");
		public get importedWebService(): webservices.IImportedWebService { return this.__importedWebService.get(); }
		public set importedWebService(newValue: webservices.IImportedWebService) { this.__importedWebService.set(newValue); }
		get importedWebServiceQualifiedName(): string { return this.__importedWebService.qualifiedName(); }
		private __serviceName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceCallAction, this, "serviceName", "", internal.PrimitiveTypeEnum.String);
		public get serviceName(): string { return this.__serviceName.get(); }
		public set serviceName(newValue: string) { this.__serviceName.set(newValue); }
		private __operationName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceCallAction, this, "operationName", "", internal.PrimitiveTypeEnum.String);
		public get operationName(): string { return this.__operationName.get(); }
		public set operationName(newValue: string) { this.__operationName.set(newValue); }
		private __useRequestTimeOut: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebServiceCallAction, this, "useRequestTimeOut", false, internal.PrimitiveTypeEnum.Boolean);
		public get useRequestTimeOut(): boolean { return this.__useRequestTimeOut.get(); }
		public set useRequestTimeOut(newValue: boolean) { this.__useRequestTimeOut.set(newValue); }
		private __timeOut: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(WebServiceCallAction, this, "timeOut", 0, internal.PrimitiveTypeEnum.Integer);
		public get timeOut(): number { return this.__timeOut.get(); }
		public set timeOut(newValue: number) { this.__timeOut.set(newValue); }
		private __sendNullValueChoice: internal.EnumProperty<NullValueOption> =
			new internal.EnumProperty<NullValueOption>(WebServiceCallAction, this, "sendNullValueChoice", NullValueOption.LeaveOutElement, NullValueOption);
		/**
		 * In version 6.7.0: deleted
		 */
		public get sendNullValueChoice(): NullValueOption { return this.__sendNullValueChoice.get(); }
		public set sendNullValueChoice(newValue: NullValueOption) { this.__sendNullValueChoice.set(newValue); }
		private __requestHeaderHandling: internal.PartProperty<RequestHandling> =
			new internal.PartProperty<RequestHandling>(WebServiceCallAction, this, "requestHeaderHandling", null, true);
		public get requestHeaderHandling(): RequestHandling { return this.__requestHeaderHandling.get(); }
		public set requestHeaderHandling(newValue: RequestHandling) { this.__requestHeaderHandling.set(newValue); }
		private __requestBodyHandling: internal.PartProperty<RequestHandling> =
			new internal.PartProperty<RequestHandling>(WebServiceCallAction, this, "requestBodyHandling", null, true);
		public get requestBodyHandling(): RequestHandling { return this.__requestBodyHandling.get(); }
		public set requestBodyHandling(newValue: RequestHandling) { this.__requestBodyHandling.set(newValue); }
		private __resultHandling: internal.PartProperty<ResultHandling> =
			new internal.PartProperty<ResultHandling>(WebServiceCallAction, this, "resultHandling", null, true);
		public get resultHandling(): ResultHandling { return this.__resultHandling.get(); }
		public set resultHandling(newValue: ResultHandling) { this.__resultHandling.set(newValue); }
		private __httpConfiguration: internal.PartProperty<HttpConfiguration> =
			new internal.PartProperty<HttpConfiguration>(WebServiceCallAction, this, "httpConfiguration", null, true);
		public get httpConfiguration(): HttpConfiguration { return this.__httpConfiguration.get(); }
		public set httpConfiguration(newValue: HttpConfiguration) { this.__httpConfiguration.set(newValue); }
		private __isValidationRequired: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebServiceCallAction, this, "isValidationRequired", false, internal.PrimitiveTypeEnum.Boolean);
		public get isValidationRequired(): boolean { return this.__isValidationRequired.get(); }
		public set isValidationRequired(newValue: boolean) { this.__isValidationRequired.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new WebServiceCallAction() cannot be invoked directly, please use 'model.microflows.createWebServiceCallAction()'"
				);
			}
		}

		/**
		 * Creates and returns a new WebServiceCallAction instance in the SDK and on the server.
		 * The new WebServiceCallAction will be automatically stored in the 'action' property
		 * of the parent ActionActivity element passed as argument.
		 */
		public static createIn(container: ActionActivity): WebServiceCallAction {
			return internal.instancehelpers.createElement(container, WebServiceCallAction, "action", false);
		}

		/**
		 * Creates and returns a new WebServiceCallAction instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): WebServiceCallAction {
			return internal.instancehelpers.createElement(model, WebServiceCallAction);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.httpConfiguration = HttpConfiguration.create(this.model);
			this.requestBodyHandling = SimpleRequestHandling.create(this.model);
			this.requestHeaderHandling = SimpleRequestHandling.create(this.model);
			this.resultHandling = ResultHandling.create(this.model);
			if (this.__sendNullValueChoice.isAvailable) {
				this.sendNullValueChoice = NullValueOption.LeaveOutElement;
			}
			this.timeOut = 30;
		}

	}

	/**
	 * In version 6.3.0: introduced
	 */
	export interface IWebServiceOperationParameterMapping extends internal.IElement {
		model: IModel;
		containerAsAdvancedRequestHandling: IAdvancedRequestHandling;
		containerAsSimpleRequestHandling: ISimpleRequestHandling;
		load(): WebServiceOperationParameterMapping;
		load(callback: (element: WebServiceOperationParameterMapping) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

	 *
	 * In version 6.3.0: introduced
	 */
	export abstract class WebServiceOperationParameterMapping extends internal.Element implements IWebServiceOperationParameterMapping {
		public static typeName: string = "Microflows$WebServiceOperationParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.3.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAdvancedRequestHandling() { return super.getContainerAs<AdvancedRequestHandling>(AdvancedRequestHandling); }
		get containerAsSimpleRequestHandling() { return super.getContainerAs<SimpleRequestHandling>(SimpleRequestHandling); }

		private __isChecked: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebServiceOperationParameterMapping, this, "isChecked", false, internal.PrimitiveTypeEnum.Boolean);
		public get isChecked(): boolean { return this.__isChecked.get(); }
		public set isChecked(newValue: boolean) { this.__isChecked.set(newValue); }
		private __parameterName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceOperationParameterMapping, this, "parameterName", "", internal.PrimitiveTypeEnum.String);
		public get parameterName(): string { return this.__parameterName.get(); }
		public set parameterName(newValue: string) { this.__parameterName.set(newValue); }
		private __argument: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceOperationParameterMapping, this, "argument", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
		 */
		public get argument(): string { return this.__argument.get(); }
		public set argument(newValue: string) { this.__argument.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new WebServiceOperationParameterMapping() cannot be invoked directly, please use 'model.microflows.createWebServiceOperationParameterMapping()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.isChecked = true;
		}

	}

	/**
	 * TODO
	 */
	export interface IWebServiceOperationAdvancedParameterMapping extends IWebServiceOperationParameterMapping {
		model: IModel;
		containerAsAdvancedRequestHandling: IAdvancedRequestHandling;
		load(): WebServiceOperationAdvancedParameterMapping;
		load(callback: (element: WebServiceOperationAdvancedParameterMapping) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class WebServiceOperationAdvancedParameterMapping extends WebServiceOperationParameterMapping implements IWebServiceOperationAdvancedParameterMapping {
		public static typeName: string = "Microflows$WebServiceOperationAdvancedParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsAdvancedRequestHandling() { return super.getContainerAs<AdvancedRequestHandling>(AdvancedRequestHandling); }

		private __mapping: internal.ByNameReferenceProperty<exportmappings.IExportMapping> =
			new internal.ByNameReferenceProperty<exportmappings.IExportMapping>(WebServiceOperationAdvancedParameterMapping, this, "mapping", null, "ExportMappings$ExportMapping");
		public get mapping(): exportmappings.IExportMapping { return this.__mapping.get(); }
		public set mapping(newValue: exportmappings.IExportMapping) { this.__mapping.set(newValue); }
		get mappingQualifiedName(): string { return this.__mapping.qualifiedName(); }
		private __mappingArgumentVariableName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceOperationAdvancedParameterMapping, this, "mappingArgumentVariableName", "", internal.PrimitiveTypeEnum.String);
		public get mappingArgumentVariableName(): string { return this.__mappingArgumentVariableName.get(); }
		public set mappingArgumentVariableName(newValue: string) { this.__mappingArgumentVariableName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new WebServiceOperationAdvancedParameterMapping() cannot be invoked directly, please use 'model.microflows.createWebServiceOperationAdvancedParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new WebServiceOperationAdvancedParameterMapping instance in the SDK and on the server.
		 * The new WebServiceOperationAdvancedParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent AdvancedRequestHandling element passed as argument.
		 */
		public static createIn(container: AdvancedRequestHandling): WebServiceOperationAdvancedParameterMapping {
			return internal.instancehelpers.createElement(container, WebServiceOperationAdvancedParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new WebServiceOperationAdvancedParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): WebServiceOperationAdvancedParameterMapping {
			return internal.instancehelpers.createElement(model, WebServiceOperationAdvancedParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * TODO
	 */
	export interface IWebServiceOperationSimpleParameterMapping extends IWebServiceOperationParameterMapping {
		model: IModel;
		containerAsSimpleRequestHandling: ISimpleRequestHandling;
		load(): WebServiceOperationSimpleParameterMapping;
		load(callback: (element: WebServiceOperationSimpleParameterMapping) => void, forceRefresh?: boolean);
	}

	/**
	 * TODO
	 */
	export class WebServiceOperationSimpleParameterMapping extends WebServiceOperationParameterMapping implements IWebServiceOperationSimpleParameterMapping {
		public static typeName: string = "Microflows$WebServiceOperationSimpleParameterMapping";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsSimpleRequestHandling() { return super.getContainerAs<SimpleRequestHandling>(SimpleRequestHandling); }

		private __parameterPath: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebServiceOperationSimpleParameterMapping, this, "parameterPath", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type mappings.ElementPath.
		 */
		public get parameterPath(): string { return this.__parameterPath.get(); }
		public set parameterPath(newValue: string) { this.__parameterPath.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new WebServiceOperationSimpleParameterMapping() cannot be invoked directly, please use 'model.microflows.createWebServiceOperationSimpleParameterMapping()'"
				);
			}
		}

		/**
		 * Creates and returns a new WebServiceOperationSimpleParameterMapping instance in the SDK and on the server.
		 * The new WebServiceOperationSimpleParameterMapping will be automatically stored in the 'parameterMappings' property
		 * of the parent SimpleRequestHandling element passed as argument.
		 */
		public static createIn(container: SimpleRequestHandling): WebServiceOperationSimpleParameterMapping {
			return internal.instancehelpers.createElement(container, WebServiceOperationSimpleParameterMapping, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new WebServiceOperationSimpleParameterMapping instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): WebServiceOperationSimpleParameterMapping {
			return internal.instancehelpers.createElement(model, WebServiceOperationSimpleParameterMapping);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}
}

import {appservices} from "./appservices";
import {documenttemplates} from "./documenttemplates";
import {domainmodels} from "./domainmodels";
import {exportmappings} from "./exportmappings";
import {importmappings} from "./importmappings";
import {javaactions} from "./javaactions";
import {pages} from "./pages";
import {security} from "./security";
import {texts} from "./texts";
import {webservices} from "./webservices";

import {IModel} from "./base-model";
