/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;

import {projects} from "./projects";

export namespace datasets {

	export class DateTimeIntervalLength extends internal.IEnum {
		public static Day: DateTimeIntervalLength = new DateTimeIntervalLength("Day", { });
		public static Week: DateTimeIntervalLength = new DateTimeIntervalLength("Week", { });
		public static Period: DateTimeIntervalLength = new DateTimeIntervalLength("Period", { });
		public static Month: DateTimeIntervalLength = new DateTimeIntervalLength("Month", { });
		public static Quarter: DateTimeIntervalLength = new DateTimeIntervalLength("Quarter", { });
		public static Year: DateTimeIntervalLength = new DateTimeIntervalLength("Year", { });
		protected qualifiedTsTypeName: string = "datasets.DateTimeIntervalLength";
	}

	export class DateTimeIntervalModifier extends internal.IEnum {
		public static Last: DateTimeIntervalModifier = new DateTimeIntervalModifier("Last", { });
		public static This: DateTimeIntervalModifier = new DateTimeIntervalModifier("This", { });
		public static Next: DateTimeIntervalModifier = new DateTimeIntervalModifier("Next", { });
		public static Past: DateTimeIntervalModifier = new DateTimeIntervalModifier("Past", { });
		public static Future: DateTimeIntervalModifier = new DateTimeIntervalModifier("Future", { });
		public static Always: DateTimeIntervalModifier = new DateTimeIntervalModifier("Always", { });
		protected qualifiedTsTypeName: string = "datasets.DateTimeIntervalModifier";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `DataSets`.
	 */


	/**
	 * See: {@link https://docs.mendix.com/refguide7/data-sets relevant section in reference guide}
	 */
	export interface IDataSet extends projects.IDocument {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		parameters: internal.IList<IDataSetParameter>;
		load(): DataSet;
		load(callback: (element: DataSet) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/data-sets relevant section in reference guide}
	 */
	export class DataSet extends projects.Document implements IDataSet {
		public static typeName: string = "DataSets$DataSet";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"source" : {
					"required" : {
						"currentValue" : true
					}
				},
				"parameters" : {
					"public" : {
						"currentValue" : true
					}
				},
				"dataSetAccess" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }

		private __source: internal.PartProperty<DataSetSource> =
			new internal.PartProperty<DataSetSource>(DataSet, this, "source", null, true);
		public get source(): DataSetSource { return this.__source.get(); }
		public set source(newValue: DataSetSource) { this.__source.set(newValue); }
		private __parameters: internal.PartListProperty<DataSetParameter> =
			new internal.PartListProperty<DataSetParameter>(DataSet, this, "parameters", []);
		public get parameters(): internal.IList<DataSetParameter> { return this.__parameters.get(); }
		public set parameters(newValue: internal.IList<DataSetParameter>) { this.__parameters.set(newValue); }
		private __dataSetAccess: internal.PartProperty<DataSetAccess> =
			new internal.PartProperty<DataSetAccess>(DataSet, this, "dataSetAccess", null, true);
		public get dataSetAccess(): DataSetAccess { return this.__dataSetAccess.get(); }
		public set dataSetAccess(newValue: DataSetAccess) { this.__dataSetAccess.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "documents";
		}

		/**
		 * Creates a new DataSet unit in the SDK and on the server.
		 * Expects one argument, the projects.IFolderBase in which this unit is contained.
		 */
		public static createIn(container: projects.IFolderBase): DataSet {
			return internal.instancehelpers.createUnit(container, DataSet);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataSetAccess = DataSetAccess.create(this.model);
			this.source = OqlDataSetSource.create(this.model);
		}

	}

	export interface IDataSetAccess extends internal.IElement {
		model: IModel;
		containerAsDataSet: IDataSet;
		load(): DataSetAccess;
		load(callback: (element: DataSetAccess) => void, forceRefresh?: boolean);
	}

	export class DataSetAccess extends internal.Element implements IDataSetAccess {
		public static typeName: string = "DataSets$DataSetAccess";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSet() { return super.getContainerAs<DataSet>(DataSet); }

		private __moduleRoleAccessList: internal.PartListProperty<DataSetModuleRoleAccess> =
			new internal.PartListProperty<DataSetModuleRoleAccess>(DataSetAccess, this, "moduleRoleAccessList", []);
		public get moduleRoleAccessList(): internal.IList<DataSetModuleRoleAccess> { return this.__moduleRoleAccessList.get(); }
		public set moduleRoleAccessList(newValue: internal.IList<DataSetModuleRoleAccess>) { this.__moduleRoleAccessList.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetAccess() cannot be invoked directly, please use 'model.datasets.createDataSetAccess()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetAccess instance in the SDK and on the server.
		 * The new DataSetAccess will be automatically stored in the 'dataSetAccess' property
		 * of the parent DataSet element passed as argument.
		 */
		public static createIn(container: DataSet): DataSetAccess {
			return internal.instancehelpers.createElement(container, DataSetAccess, "dataSetAccess", false);
		}

		/**
		 * Creates and returns a new DataSetAccess instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetAccess {
			return internal.instancehelpers.createElement(model, DataSetAccess);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetColumn extends internal.IElement {
		model: IModel;
		containerAsJavaDataSetSource: IJavaDataSetSource;
		load(): DataSetColumn;
		load(callback: (element: DataSetColumn) => void, forceRefresh?: boolean);
	}

	export class DataSetColumn extends internal.Element implements IDataSetColumn {
		public static typeName: string = "DataSets$DataSetColumn";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsJavaDataSetSource() { return super.getContainerAs<JavaDataSetSource>(JavaDataSetSource); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetColumn, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __type: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetColumn, this, "type", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get type(): string { return this.__type.get(); }
		public set type(newValue: string) { this.__type.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetColumn() cannot be invoked directly, please use 'model.datasets.createDataSetColumn()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetColumn instance in the SDK and on the server.
		 * The new DataSetColumn will be automatically stored in the 'columns' property
		 * of the parent JavaDataSetSource element passed as argument.
		 */
		public static createIn(container: JavaDataSetSource): DataSetColumn {
			return internal.instancehelpers.createElement(container, DataSetColumn, "columns", true);
		}

		/**
		 * Creates and returns a new DataSetColumn instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetColumn {
			return internal.instancehelpers.createElement(model, DataSetColumn);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.name = "Column";
			this.type = "String";
		}

	}

	export interface IDataSetConstraintAccess extends internal.IElement {
		model: IModel;
		containerAsDataSetParameterAccess: IDataSetParameterAccess;
		load(): DataSetConstraintAccess;
		load(callback: (element: DataSetConstraintAccess) => void, forceRefresh?: boolean);
	}

	export class DataSetConstraintAccess extends internal.Element implements IDataSetConstraintAccess {
		public static typeName: string = "DataSets$DataSetConstraintAccess";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetParameterAccess() { return super.getContainerAs<DataSetParameterAccess>(DataSetParameterAccess); }

		private __constraintText: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetConstraintAccess, this, "constraintText", "", internal.PrimitiveTypeEnum.String);
		public get constraintText(): string { return this.__constraintText.get(); }
		public set constraintText(newValue: string) { this.__constraintText.set(newValue); }
		private __enabled: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DataSetConstraintAccess, this, "enabled", false, internal.PrimitiveTypeEnum.Boolean);
		public get enabled(): boolean { return this.__enabled.get(); }
		public set enabled(newValue: boolean) { this.__enabled.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetConstraintAccess() cannot be invoked directly, please use 'model.datasets.createDataSetConstraintAccess()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetConstraintAccess instance in the SDK and on the server.
		 * The new DataSetConstraintAccess will be automatically stored in the 'constraintAccessList' property
		 * of the parent DataSetParameterAccess element passed as argument.
		 */
		public static createIn(container: DataSetParameterAccess): DataSetConstraintAccess {
			return internal.instancehelpers.createElement(container, DataSetConstraintAccess, "constraintAccessList", true);
		}

		/**
		 * Creates and returns a new DataSetConstraintAccess instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetConstraintAccess {
			return internal.instancehelpers.createElement(model, DataSetConstraintAccess);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetParameterConstraint extends internal.IElement {
		model: IModel;
		containerAsDataSetParameter: IDataSetParameter;
		load(): DataSetParameterConstraint;
		load(callback: (element: DataSetParameterConstraint) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class DataSetParameterConstraint extends internal.Element implements IDataSetParameterConstraint {
		public static typeName: string = "DataSets$DataSetParameterConstraint";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetParameter() { return super.getContainerAs<DataSetParameter>(DataSetParameter); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetParameterConstraint() cannot be invoked directly, please use 'model.datasets.createDataSetParameterConstraint()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetDateTimeConstraint extends IDataSetParameterConstraint {
		model: IModel;
		containerAsDataSetParameter: IDataSetParameter;
		load(): DataSetDateTimeConstraint;
		load(callback: (element: DataSetDateTimeConstraint) => void, forceRefresh?: boolean);
	}

	export class DataSetDateTimeConstraint extends DataSetParameterConstraint implements IDataSetDateTimeConstraint {
		public static typeName: string = "DataSets$DataSetDateTimeConstraint";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetParameter() { return super.getContainerAs<DataSetParameter>(DataSetParameter); }

		private __modifier: internal.EnumProperty<DateTimeIntervalModifier> =
			new internal.EnumProperty<DateTimeIntervalModifier>(DataSetDateTimeConstraint, this, "modifier", DateTimeIntervalModifier.Last, DateTimeIntervalModifier);
		public get modifier(): DateTimeIntervalModifier { return this.__modifier.get(); }
		public set modifier(newValue: DateTimeIntervalModifier) { this.__modifier.set(newValue); }
		private __length: internal.EnumProperty<DateTimeIntervalLength> =
			new internal.EnumProperty<DateTimeIntervalLength>(DataSetDateTimeConstraint, this, "length", DateTimeIntervalLength.Month, DateTimeIntervalLength);
		public get length(): DateTimeIntervalLength { return this.__length.get(); }
		public set length(newValue: DateTimeIntervalLength) { this.__length.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetDateTimeConstraint() cannot be invoked directly, please use 'model.datasets.createDataSetDateTimeConstraint()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetDateTimeConstraint instance in the SDK and on the server.
		 * The new DataSetDateTimeConstraint will be automatically stored in the 'constraints' property
		 * of the parent DataSetParameter element passed as argument.
		 */
		public static createIn(container: DataSetParameter): DataSetDateTimeConstraint {
			return internal.instancehelpers.createElement(container, DataSetDateTimeConstraint, "constraints", true);
		}

		/**
		 * Creates and returns a new DataSetDateTimeConstraint instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetDateTimeConstraint {
			return internal.instancehelpers.createElement(model, DataSetDateTimeConstraint);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.length = DateTimeIntervalLength.Month;
			this.modifier = DateTimeIntervalModifier.Last;
		}

	}

	export interface IDataSetModuleRoleAccess extends internal.IElement {
		model: IModel;
		containerAsDataSetAccess: IDataSetAccess;
		load(): DataSetModuleRoleAccess;
		load(callback: (element: DataSetModuleRoleAccess) => void, forceRefresh?: boolean);
	}

	export class DataSetModuleRoleAccess extends internal.Element implements IDataSetModuleRoleAccess {
		public static typeName: string = "DataSets$DataSetModuleRoleAccess";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetAccess() { return super.getContainerAs<DataSetAccess>(DataSetAccess); }

		private __parameterAccessList: internal.PartListProperty<DataSetParameterAccess> =
			new internal.PartListProperty<DataSetParameterAccess>(DataSetModuleRoleAccess, this, "parameterAccessList", []);
		public get parameterAccessList(): internal.IList<DataSetParameterAccess> { return this.__parameterAccessList.get(); }
		public set parameterAccessList(newValue: internal.IList<DataSetParameterAccess>) { this.__parameterAccessList.set(newValue); }
		private __moduleRole: internal.ByNameReferenceProperty<security.IModuleRole> =
			new internal.ByNameReferenceProperty<security.IModuleRole>(DataSetModuleRoleAccess, this, "moduleRole", null, "Security$ModuleRole");
		public get moduleRole(): security.IModuleRole { return this.__moduleRole.get(); }
		public set moduleRole(newValue: security.IModuleRole) { this.__moduleRole.set(newValue); }
		get moduleRoleQualifiedName(): string { return this.__moduleRole.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetModuleRoleAccess() cannot be invoked directly, please use 'model.datasets.createDataSetModuleRoleAccess()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetModuleRoleAccess instance in the SDK and on the server.
		 * The new DataSetModuleRoleAccess will be automatically stored in the 'moduleRoleAccessList' property
		 * of the parent DataSetAccess element passed as argument.
		 */
		public static createIn(container: DataSetAccess): DataSetModuleRoleAccess {
			return internal.instancehelpers.createElement(container, DataSetModuleRoleAccess, "moduleRoleAccessList", true);
		}

		/**
		 * Creates and returns a new DataSetModuleRoleAccess instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetModuleRoleAccess {
			return internal.instancehelpers.createElement(model, DataSetModuleRoleAccess);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetNumericConstraint extends IDataSetParameterConstraint {
		model: IModel;
		containerAsDataSetParameter: IDataSetParameter;
		load(): DataSetNumericConstraint;
		load(callback: (element: DataSetNumericConstraint) => void, forceRefresh?: boolean);
	}

	export class DataSetNumericConstraint extends DataSetParameterConstraint implements IDataSetNumericConstraint {
		public static typeName: string = "DataSets$DataSetNumericConstraint";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetParameter() { return super.getContainerAs<DataSetParameter>(DataSetParameter); }

		private __begin: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetNumericConstraint, this, "begin", "", internal.PrimitiveTypeEnum.String);
		public get begin(): string { return this.__begin.get(); }
		public set begin(newValue: string) { this.__begin.set(newValue); }
		private __applyBegin: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DataSetNumericConstraint, this, "applyBegin", false, internal.PrimitiveTypeEnum.Boolean);
		public get applyBegin(): boolean { return this.__applyBegin.get(); }
		public set applyBegin(newValue: boolean) { this.__applyBegin.set(newValue); }
		private __end: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetNumericConstraint, this, "end", "", internal.PrimitiveTypeEnum.String);
		public get end(): string { return this.__end.get(); }
		public set end(newValue: string) { this.__end.set(newValue); }
		private __applyEnd: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DataSetNumericConstraint, this, "applyEnd", false, internal.PrimitiveTypeEnum.Boolean);
		public get applyEnd(): boolean { return this.__applyEnd.get(); }
		public set applyEnd(newValue: boolean) { this.__applyEnd.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetNumericConstraint() cannot be invoked directly, please use 'model.datasets.createDataSetNumericConstraint()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetNumericConstraint instance in the SDK and on the server.
		 * The new DataSetNumericConstraint will be automatically stored in the 'constraints' property
		 * of the parent DataSetParameter element passed as argument.
		 */
		public static createIn(container: DataSetParameter): DataSetNumericConstraint {
			return internal.instancehelpers.createElement(container, DataSetNumericConstraint, "constraints", true);
		}

		/**
		 * Creates and returns a new DataSetNumericConstraint instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetNumericConstraint {
			return internal.instancehelpers.createElement(model, DataSetNumericConstraint);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.applyBegin = true;
			this.applyEnd = true;
			this.begin = "0";
			this.end = "0";
		}

	}

	export interface IDataSetObjectConstraint extends IDataSetParameterConstraint {
		model: IModel;
		containerAsDataSetParameter: IDataSetParameter;
		load(): DataSetObjectConstraint;
		load(callback: (element: DataSetObjectConstraint) => void, forceRefresh?: boolean);
	}

	export class DataSetObjectConstraint extends DataSetParameterConstraint implements IDataSetObjectConstraint {
		public static typeName: string = "DataSets$DataSetObjectConstraint";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetParameter() { return super.getContainerAs<DataSetParameter>(DataSetParameter); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetObjectConstraint, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __constraint: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetObjectConstraint, this, "constraint", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
		 */
		public get constraint(): string { return this.__constraint.get(); }
		public set constraint(newValue: string) { this.__constraint.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetObjectConstraint() cannot be invoked directly, please use 'model.datasets.createDataSetObjectConstraint()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetObjectConstraint instance in the SDK and on the server.
		 * The new DataSetObjectConstraint will be automatically stored in the 'constraints' property
		 * of the parent DataSetParameter element passed as argument.
		 */
		public static createIn(container: DataSetParameter): DataSetObjectConstraint {
			return internal.instancehelpers.createElement(container, DataSetObjectConstraint, "constraints", true);
		}

		/**
		 * Creates and returns a new DataSetObjectConstraint instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetObjectConstraint {
			return internal.instancehelpers.createElement(model, DataSetObjectConstraint);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetParameter extends internal.IElement {
		model: IModel;
		containerAsDataSet: IDataSet;
		name: string;
		load(): DataSetParameter;
		load(callback: (element: DataSetParameter) => void, forceRefresh?: boolean);
	}

	export class DataSetParameter extends internal.Element implements IDataSetParameter {
		public static typeName: string = "DataSets$DataSetParameter";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSet() { return super.getContainerAs<DataSet>(DataSet); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetParameter, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __type: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetParameter, this, "type", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get type(): string { return this.__type.get(); }
		public set type(newValue: string) { this.__type.set(newValue); }
		private __constraints: internal.PartListProperty<DataSetParameterConstraint> =
			new internal.PartListProperty<DataSetParameterConstraint>(DataSetParameter, this, "constraints", []);
		public get constraints(): internal.IList<DataSetParameterConstraint> { return this.__constraints.get(); }
		public set constraints(newValue: internal.IList<DataSetParameterConstraint>) { this.__constraints.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetParameter() cannot be invoked directly, please use 'model.datasets.createDataSetParameter()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetParameter instance in the SDK and on the server.
		 * The new DataSetParameter will be automatically stored in the 'parameters' property
		 * of the parent DataSet element passed as argument.
		 */
		public static createIn(container: DataSet): DataSetParameter {
			return internal.instancehelpers.createElement(container, DataSetParameter, "parameters", true);
		}

		/**
		 * Creates and returns a new DataSetParameter instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetParameter {
			return internal.instancehelpers.createElement(model, DataSetParameter);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = "Unknown";
		}

	}

	export interface IDataSetParameterAccess extends internal.IElement {
		model: IModel;
		containerAsDataSetModuleRoleAccess: IDataSetModuleRoleAccess;
		load(): DataSetParameterAccess;
		load(callback: (element: DataSetParameterAccess) => void, forceRefresh?: boolean);
	}

	export class DataSetParameterAccess extends internal.Element implements IDataSetParameterAccess {
		public static typeName: string = "DataSets$DataSetParameterAccess";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSetModuleRoleAccess() { return super.getContainerAs<DataSetModuleRoleAccess>(DataSetModuleRoleAccess); }

		private __parameterName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DataSetParameterAccess, this, "parameterName", "", internal.PrimitiveTypeEnum.String);
		public get parameterName(): string { return this.__parameterName.get(); }
		public set parameterName(newValue: string) { this.__parameterName.set(newValue); }
		private __constraintAccessList: internal.PartListProperty<DataSetConstraintAccess> =
			new internal.PartListProperty<DataSetConstraintAccess>(DataSetParameterAccess, this, "constraintAccessList", []);
		public get constraintAccessList(): internal.IList<DataSetConstraintAccess> { return this.__constraintAccessList.get(); }
		public set constraintAccessList(newValue: internal.IList<DataSetConstraintAccess>) { this.__constraintAccessList.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetParameterAccess() cannot be invoked directly, please use 'model.datasets.createDataSetParameterAccess()'"
				);
			}
		}

		/**
		 * Creates and returns a new DataSetParameterAccess instance in the SDK and on the server.
		 * The new DataSetParameterAccess will be automatically stored in the 'parameterAccessList' property
		 * of the parent DataSetModuleRoleAccess element passed as argument.
		 */
		public static createIn(container: DataSetModuleRoleAccess): DataSetParameterAccess {
			return internal.instancehelpers.createElement(container, DataSetParameterAccess, "parameterAccessList", true);
		}

		/**
		 * Creates and returns a new DataSetParameterAccess instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DataSetParameterAccess {
			return internal.instancehelpers.createElement(model, DataSetParameterAccess);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDataSetSource extends internal.IElement {
		model: IModel;
		containerAsDataSet: IDataSet;
		load(): DataSetSource;
		load(callback: (element: DataSetSource) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class DataSetSource extends internal.Element implements IDataSetSource {
		public static typeName: string = "DataSets$DataSetSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSet() { return super.getContainerAs<DataSet>(DataSet); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DataSetSource() cannot be invoked directly, please use 'model.datasets.createDataSetSource()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IJavaDataSetSource extends IDataSetSource {
		model: IModel;
		containerAsDataSet: IDataSet;
		load(): JavaDataSetSource;
		load(callback: (element: JavaDataSetSource) => void, forceRefresh?: boolean);
	}

	export class JavaDataSetSource extends DataSetSource implements IJavaDataSetSource {
		public static typeName: string = "DataSets$JavaDataSetSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSet() { return super.getContainerAs<DataSet>(DataSet); }

		private __columns: internal.PartListProperty<DataSetColumn> =
			new internal.PartListProperty<DataSetColumn>(JavaDataSetSource, this, "columns", []);
		public get columns(): internal.IList<DataSetColumn> { return this.__columns.get(); }
		public set columns(newValue: internal.IList<DataSetColumn>) { this.__columns.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new JavaDataSetSource() cannot be invoked directly, please use 'model.datasets.createJavaDataSetSource()'"
				);
			}
		}

		/**
		 * Creates and returns a new JavaDataSetSource instance in the SDK and on the server.
		 * The new JavaDataSetSource will be automatically stored in the 'source' property
		 * of the parent DataSet element passed as argument.
		 */
		public static createIn(container: DataSet): JavaDataSetSource {
			return internal.instancehelpers.createElement(container, JavaDataSetSource, "source", false);
		}

		/**
		 * Creates and returns a new JavaDataSetSource instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): JavaDataSetSource {
			return internal.instancehelpers.createElement(model, JavaDataSetSource);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IOqlDataSetSource extends IDataSetSource {
		model: IModel;
		containerAsDataSet: IDataSet;
		load(): OqlDataSetSource;
		load(callback: (element: OqlDataSetSource) => void, forceRefresh?: boolean);
	}

	export class OqlDataSetSource extends DataSetSource implements IOqlDataSetSource {
		public static typeName: string = "DataSets$OqlDataSetSource";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDataSet() { return super.getContainerAs<DataSet>(DataSet); }

		private __query: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(OqlDataSetSource, this, "query", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type oql.OqlQuery.
		 */
		public get query(): string { return this.__query.get(); }
		public set query(newValue: string) { this.__query.set(newValue); }
		private __ignoreErrorsInQuery: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(OqlDataSetSource, this, "ignoreErrorsInQuery", false, internal.PrimitiveTypeEnum.Boolean);
		public get ignoreErrorsInQuery(): boolean { return this.__ignoreErrorsInQuery.get(); }
		public set ignoreErrorsInQuery(newValue: boolean) { this.__ignoreErrorsInQuery.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new OqlDataSetSource() cannot be invoked directly, please use 'model.datasets.createOqlDataSetSource()'"
				);
			}
		}

		/**
		 * Creates and returns a new OqlDataSetSource instance in the SDK and on the server.
		 * The new OqlDataSetSource will be automatically stored in the 'source' property
		 * of the parent DataSet element passed as argument.
		 */
		public static createIn(container: DataSet): OqlDataSetSource {
			return internal.instancehelpers.createElement(container, OqlDataSetSource, "source", false);
		}

		/**
		 * Creates and returns a new OqlDataSetSource instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): OqlDataSetSource {
			return internal.instancehelpers.createElement(model, OqlDataSetSource);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}
}

import {security} from "./security";

import {IModel} from "./base-model";
