/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import {utils} from "../sdk/utils";

import {projects} from "./projects";

export namespace security {

	export class SecurityLevel extends internal.IEnum {
		public static CheckNothing: SecurityLevel = new SecurityLevel("CheckNothing", { });
		public static CheckFormsAndMicroflows: SecurityLevel = new SecurityLevel("CheckFormsAndMicroflows", { });
		public static CheckEverything: SecurityLevel = new SecurityLevel("CheckEverything", { });
		protected qualifiedTsTypeName: string = "security.SecurityLevel";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Security`.
	 */


	export interface IAccessRuleContainerBase extends internal.IElement {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		load(): AccessRuleContainerBase;
		load(callback: (element: AccessRuleContainerBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class AccessRuleContainerBase extends internal.Element implements IAccessRuleContainerBase {
		public static typeName: string = "Security$AccessRuleContainerBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }

		private __accessRules: internal.PartListProperty<domainmodels.AccessRule> =
			new internal.PartListProperty<domainmodels.AccessRule>(AccessRuleContainerBase, this, "accessRules", []);
		public get accessRules(): internal.IList<domainmodels.AccessRule> { return this.__accessRules.get(); }
		public set accessRules(newValue: internal.IList<domainmodels.AccessRule>) { this.__accessRules.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AccessRuleContainerBase() cannot be invoked directly, please use 'model.security.createAccessRuleContainerBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/demo-users relevant section in reference guide}
	 */
	export interface IDemoUser extends internal.IElement {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		load(): DemoUser;
		load(callback: (element: DemoUser) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/demo-users relevant section in reference guide}
	 */
	export class DemoUser extends internal.Element implements IDemoUser {
		public static typeName: string = "Security$DemoUser";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }

		private __userName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DemoUser, this, "userName", "", internal.PrimitiveTypeEnum.String);
		public get userName(): string { return this.__userName.get(); }
		public set userName(newValue: string) { this.__userName.set(newValue); }
		private __password: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DemoUser, this, "password", "", internal.PrimitiveTypeEnum.String);
		public get password(): string { return this.__password.get(); }
		public set password(newValue: string) { this.__password.set(newValue); }
		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(DemoUser, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }
		private __userRoles: internal.ByNameReferenceListProperty<IUserRole> =
			new internal.ByNameReferenceListProperty<IUserRole>(DemoUser, this, "userRoles", [], "Security$UserRole");
		public get userRoles(): internal.IList<IUserRole> { return this.__userRoles.get(); }
		public set userRoles(newValue: internal.IList<IUserRole>) { this.__userRoles.set(newValue); }
		get userRolesQualifiedNames(): string[] { return this.__userRoles.qualifiedNames(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DemoUser() cannot be invoked directly, please use 'model.security.createDemoUser()'"
				);
			}
		}

		/**
		 * Creates and returns a new DemoUser instance in the SDK and on the server.
		 * The new DemoUser will be automatically stored in the 'demoUsers' property
		 * of the parent ProjectSecurity element passed as argument.
		 */
		public static createIn(container: ProjectSecurity): DemoUser {
			return internal.instancehelpers.createElement(container, DemoUser, "demoUsers", true);
		}

		/**
		 * Creates and returns a new DemoUser instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DemoUser {
			return internal.instancehelpers.createElement(model, DemoUser);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFileDocumentAccessRuleContainer extends IAccessRuleContainerBase {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		load(): FileDocumentAccessRuleContainer;
		load(callback: (element: FileDocumentAccessRuleContainer) => void, forceRefresh?: boolean);
	}

	export class FileDocumentAccessRuleContainer extends AccessRuleContainerBase implements IFileDocumentAccessRuleContainer {
		public static typeName: string = "Security$FileDocumentAccessRuleContainer";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new FileDocumentAccessRuleContainer() cannot be invoked directly, please use 'model.security.createFileDocumentAccessRuleContainer()'"
				);
			}
		}

		/**
		 * Creates and returns a new FileDocumentAccessRuleContainer instance in the SDK and on the server.
		 * The new FileDocumentAccessRuleContainer will be automatically stored in the 'fileDocumentAccess' property
		 * of the parent ProjectSecurity element passed as argument.
		 */
		public static createIn(container: ProjectSecurity): FileDocumentAccessRuleContainer {
			return internal.instancehelpers.createElement(container, FileDocumentAccessRuleContainer, "fileDocumentAccess", false);
		}

		/**
		 * Creates and returns a new FileDocumentAccessRuleContainer instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): FileDocumentAccessRuleContainer {
			return internal.instancehelpers.createElement(model, FileDocumentAccessRuleContainer);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IImageAccessRuleContainer extends IAccessRuleContainerBase {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		load(): ImageAccessRuleContainer;
		load(callback: (element: ImageAccessRuleContainer) => void, forceRefresh?: boolean);
	}

	export class ImageAccessRuleContainer extends AccessRuleContainerBase implements IImageAccessRuleContainer {
		public static typeName: string = "Security$ImageAccessRuleContainer";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ImageAccessRuleContainer() cannot be invoked directly, please use 'model.security.createImageAccessRuleContainer()'"
				);
			}
		}

		/**
		 * Creates and returns a new ImageAccessRuleContainer instance in the SDK and on the server.
		 * The new ImageAccessRuleContainer will be automatically stored in the 'imageAccess' property
		 * of the parent ProjectSecurity element passed as argument.
		 */
		public static createIn(container: ProjectSecurity): ImageAccessRuleContainer {
			return internal.instancehelpers.createElement(container, ImageAccessRuleContainer, "imageAccess", false);
		}

		/**
		 * Creates and returns a new ImageAccessRuleContainer instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ImageAccessRuleContainer {
			return internal.instancehelpers.createElement(model, ImageAccessRuleContainer);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/module-role relevant section in reference guide}
	 */
	export interface IModuleRole extends internal.IElement {
		model: IModel;
		containerAsModuleSecurity: IModuleSecurity;
		name: string;
		load(): ModuleRole;
		load(callback: (element: ModuleRole) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/module-role relevant section in reference guide}
	 */
	export class ModuleRole extends internal.Element implements IModuleRole {
		public static typeName: string = "Security$ModuleRole";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsModuleSecurity() { return super.getContainerAs<ModuleSecurity>(ModuleSecurity); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ModuleRole, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __description: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ModuleRole, this, "description", "", internal.PrimitiveTypeEnum.String);
		public get description(): string { return this.__description.get(); }
		public set description(newValue: string) { this.__description.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ModuleRole() cannot be invoked directly, please use 'model.security.createModuleRole()'"
				);
			}
		}

		/**
		 * Creates and returns a new ModuleRole instance in the SDK and on the server.
		 * The new ModuleRole will be automatically stored in the 'moduleRoles' property
		 * of the parent ModuleSecurity element passed as argument.
		 */
		public static createIn(container: ModuleSecurity): ModuleRole {
			return internal.instancehelpers.createElement(container, ModuleRole, "moduleRoles", true);
		}

		/**
		 * Creates and returns a new ModuleRole instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ModuleRole {
			return internal.instancehelpers.createElement(model, ModuleRole);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/module-security relevant section in reference guide}
	 */
	export interface IModuleSecurity extends internal.IModelUnit {
		model: IModel;
		containerAsModule: projects.IModule;
		moduleRoles: internal.IList<IModuleRole>;
		load(): ModuleSecurity;
		load(callback: (element: ModuleSecurity) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/module-security relevant section in reference guide}
	 */
	export class ModuleSecurity extends internal.ModelUnit implements IModuleSecurity {
		public static typeName: string = "Security$ModuleSecurity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"moduleRoles" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsModule() { return super.getContainerAs<projects.Module>(projects.Module); }

		private __moduleRoles: internal.PartListProperty<ModuleRole> =
			new internal.PartListProperty<ModuleRole>(ModuleSecurity, this, "moduleRoles", []);
		public get moduleRoles(): internal.IList<ModuleRole> { return this.__moduleRoles.get(); }
		public set moduleRoles(newValue: internal.IList<ModuleRole>) { this.__moduleRoles.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IModule) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "moduleSecurity";
		}

		/**
		 * Creates a new ModuleSecurity unit in the SDK and on the server.
		 * Expects one argument, the projects.IModule in which this unit is contained.
		 */
		public static createIn(container: projects.IModule): ModuleSecurity {
			return internal.instancehelpers.createUnit(container, ModuleSecurity);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/password-policy relevant section in reference guide}
	 */
	export interface IPasswordPolicySettings extends internal.IElement {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		load(): PasswordPolicySettings;
		load(callback: (element: PasswordPolicySettings) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/password-policy relevant section in reference guide}
	 */
	export class PasswordPolicySettings extends internal.Element implements IPasswordPolicySettings {
		public static typeName: string = "Security$PasswordPolicySettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }

		private __minimumLength: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(PasswordPolicySettings, this, "minimumLength", 0, internal.PrimitiveTypeEnum.Integer);
		public get minimumLength(): number { return this.__minimumLength.get(); }
		public set minimumLength(newValue: number) { this.__minimumLength.set(newValue); }
		private __requireMixedCase: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(PasswordPolicySettings, this, "requireMixedCase", false, internal.PrimitiveTypeEnum.Boolean);
		public get requireMixedCase(): boolean { return this.__requireMixedCase.get(); }
		public set requireMixedCase(newValue: boolean) { this.__requireMixedCase.set(newValue); }
		private __requireSymbol: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(PasswordPolicySettings, this, "requireSymbol", false, internal.PrimitiveTypeEnum.Boolean);
		public get requireSymbol(): boolean { return this.__requireSymbol.get(); }
		public set requireSymbol(newValue: boolean) { this.__requireSymbol.set(newValue); }
		private __requireDigit: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(PasswordPolicySettings, this, "requireDigit", false, internal.PrimitiveTypeEnum.Boolean);
		public get requireDigit(): boolean { return this.__requireDigit.get(); }
		public set requireDigit(newValue: boolean) { this.__requireDigit.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new PasswordPolicySettings() cannot be invoked directly, please use 'model.security.createPasswordPolicySettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new PasswordPolicySettings instance in the SDK and on the server.
		 * The new PasswordPolicySettings will be automatically stored in the 'passwordPolicySettings' property
		 * of the parent ProjectSecurity element passed as argument.
		 */
		public static createIn(container: ProjectSecurity): PasswordPolicySettings {
			return internal.instancehelpers.createElement(container, PasswordPolicySettings, "passwordPolicySettings", false);
		}

		/**
		 * Creates and returns a new PasswordPolicySettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): PasswordPolicySettings {
			return internal.instancehelpers.createElement(model, PasswordPolicySettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.minimumLength = 8;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project-security relevant section in reference guide}
	 */
	export interface IProjectSecurity extends projects.IProjectDocument {
		model: IModel;
		containerAsProject: projects.IProject;
		userRoles: internal.IList<IUserRole>;
		load(): ProjectSecurity;
		load(callback: (element: ProjectSecurity) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project-security relevant section in reference guide}
	 */
	export class ProjectSecurity extends projects.ProjectDocument implements IProjectSecurity {
		public static typeName: string = "Security$ProjectSecurity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"userRoles" : {
					"public" : {
						"currentValue" : true
					}
				},
				"passwordPolicySettings" : {
					"required" : {
						"currentValue" : true
					}
				},
				"fileDocumentAccess" : {
					"deprecated" : "6.0.0",
					"deprecationMessage" : "Specifying project-level access rules for entity 'System.FileDocument' is deprecated. Please create a specialized entity for each use case and configure access rules for those entities instead.",
					"required" : {
						"currentValue" : true
					}
				},
				"imageAccess" : {
					"deprecated" : "6.0.0",
					"deprecationMessage" : "Specifying project-level access rules for entity 'System.Image' is deprecated. Please create a specialized entity for each use case and configure access rules for those entities instead.",
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<projects.Project>(projects.Project); }

		private __securityLevel: internal.EnumProperty<SecurityLevel> =
			new internal.EnumProperty<SecurityLevel>(ProjectSecurity, this, "securityLevel", SecurityLevel.CheckNothing, SecurityLevel);
		public get securityLevel(): SecurityLevel { return this.__securityLevel.get(); }
		public set securityLevel(newValue: SecurityLevel) { this.__securityLevel.set(newValue); }
		private __checkSecurity: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ProjectSecurity, this, "checkSecurity", false, internal.PrimitiveTypeEnum.Boolean);
		public get checkSecurity(): boolean { return this.__checkSecurity.get(); }
		public set checkSecurity(newValue: boolean) { this.__checkSecurity.set(newValue); }
		private __userRoles: internal.PartListProperty<UserRole> =
			new internal.PartListProperty<UserRole>(ProjectSecurity, this, "userRoles", []);
		public get userRoles(): internal.IList<UserRole> { return this.__userRoles.get(); }
		public set userRoles(newValue: internal.IList<UserRole>) { this.__userRoles.set(newValue); }
		private __adminUserName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ProjectSecurity, this, "adminUserName", "", internal.PrimitiveTypeEnum.String);
		public get adminUserName(): string { return this.__adminUserName.get(); }
		public set adminUserName(newValue: string) { this.__adminUserName.set(newValue); }
		private __adminPassword: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ProjectSecurity, this, "adminPassword", "", internal.PrimitiveTypeEnum.String);
		public get adminPassword(): string { return this.__adminPassword.get(); }
		public set adminPassword(newValue: string) { this.__adminPassword.set(newValue); }
		private __adminUserRoleName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ProjectSecurity, this, "adminUserRoleName", "", internal.PrimitiveTypeEnum.String);
		public get adminUserRoleName(): string { return this.__adminUserRoleName.get(); }
		public set adminUserRoleName(newValue: string) { this.__adminUserRoleName.set(newValue); }
		private __enableDemoUsers: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ProjectSecurity, this, "enableDemoUsers", false, internal.PrimitiveTypeEnum.Boolean);
		public get enableDemoUsers(): boolean { return this.__enableDemoUsers.get(); }
		public set enableDemoUsers(newValue: boolean) { this.__enableDemoUsers.set(newValue); }
		private __demoUsers: internal.PartListProperty<DemoUser> =
			new internal.PartListProperty<DemoUser>(ProjectSecurity, this, "demoUsers", []);
		public get demoUsers(): internal.IList<DemoUser> { return this.__demoUsers.get(); }
		public set demoUsers(newValue: internal.IList<DemoUser>) { this.__demoUsers.set(newValue); }
		private __enableGuestAccess: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ProjectSecurity, this, "enableGuestAccess", false, internal.PrimitiveTypeEnum.Boolean);
		public get enableGuestAccess(): boolean { return this.__enableGuestAccess.get(); }
		public set enableGuestAccess(newValue: boolean) { this.__enableGuestAccess.set(newValue); }
		private __guestUserRoleName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ProjectSecurity, this, "guestUserRoleName", "", internal.PrimitiveTypeEnum.String);
		public get guestUserRoleName(): string { return this.__guestUserRoleName.get(); }
		public set guestUserRoleName(newValue: string) { this.__guestUserRoleName.set(newValue); }
		private __signInMicroflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(ProjectSecurity, this, "signInMicroflow", null, "Microflows$Microflow");
		public get signInMicroflow(): microflows.IMicroflow { return this.__signInMicroflow.get(); }
		public set signInMicroflow(newValue: microflows.IMicroflow) { this.__signInMicroflow.set(newValue); }
		get signInMicroflowQualifiedName(): string { return this.__signInMicroflow.qualifiedName(); }
		private __passwordPolicySettings: internal.PartProperty<PasswordPolicySettings> =
			new internal.PartProperty<PasswordPolicySettings>(ProjectSecurity, this, "passwordPolicySettings", null, true);
		public get passwordPolicySettings(): PasswordPolicySettings { return this.__passwordPolicySettings.get(); }
		public set passwordPolicySettings(newValue: PasswordPolicySettings) { this.__passwordPolicySettings.set(newValue); }
		private __fileDocumentAccess: internal.PartProperty<FileDocumentAccessRuleContainer> =
			new internal.PartProperty<FileDocumentAccessRuleContainer>(ProjectSecurity, this, "fileDocumentAccess", null, true);
		/**
		 * In version 6.0.0: deprecated
		 */
		public get fileDocumentAccess(): FileDocumentAccessRuleContainer { return this.__fileDocumentAccess.get(); }
		public set fileDocumentAccess(newValue: FileDocumentAccessRuleContainer) { this.__fileDocumentAccess.set(newValue); }
		private __imageAccess: internal.PartProperty<ImageAccessRuleContainer> =
			new internal.PartProperty<ImageAccessRuleContainer>(ProjectSecurity, this, "imageAccess", null, true);
		/**
		 * In version 6.0.0: deprecated
		 */
		public get imageAccess(): ImageAccessRuleContainer { return this.__imageAccess.get(); }
		public set imageAccess(newValue: ImageAccessRuleContainer) { this.__imageAccess.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IProject) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "projectDocuments";
		}

		/**
		 * Creates a new ProjectSecurity unit in the SDK and on the server.
		 * Expects one argument, the projects.IProject in which this unit is contained.
		 */
		public static createIn(container: projects.IProject): ProjectSecurity {
			return internal.instancehelpers.createUnit(container, ProjectSecurity);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.adminUserName = "MxAdmin";
			this.checkSecurity = true;
			this.fileDocumentAccess = FileDocumentAccessRuleContainer.create(this.model);
			this.imageAccess = ImageAccessRuleContainer.create(this.model);
			this.passwordPolicySettings = PasswordPolicySettings.create(this.model);
			this.securityLevel = SecurityLevel.CheckNothing;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/user-role relevant section in reference guide}
	 */
	export interface IUserRole extends internal.IElement {
		model: IModel;
		containerAsProjectSecurity: IProjectSecurity;
		name: string;
		load(): UserRole;
		load(callback: (element: UserRole) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/user-role relevant section in reference guide}
	 */
	export class UserRole extends internal.Element implements IUserRole {
		public static typeName: string = "Security$UserRole";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSecurity() { return super.getContainerAs<ProjectSecurity>(ProjectSecurity); }

		private __guid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UserRole, this, "guid", "", internal.PrimitiveTypeEnum.Guid);
		public get guid(): string { return this.__guid.get(); }
		public set guid(newValue: string) { this.__guid.set(newValue); }
		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UserRole, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __description: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UserRole, this, "description", "", internal.PrimitiveTypeEnum.String);
		public get description(): string { return this.__description.get(); }
		public set description(newValue: string) { this.__description.set(newValue); }
		private __moduleRoles: internal.ByNameReferenceListProperty<IModuleRole> =
			new internal.ByNameReferenceListProperty<IModuleRole>(UserRole, this, "moduleRoles", [], "Security$ModuleRole");
		public get moduleRoles(): internal.IList<IModuleRole> { return this.__moduleRoles.get(); }
		public set moduleRoles(newValue: internal.IList<IModuleRole>) { this.__moduleRoles.set(newValue); }
		get moduleRolesQualifiedNames(): string[] { return this.__moduleRoles.qualifiedNames(); }
		private __manageAllRoles: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(UserRole, this, "manageAllRoles", false, internal.PrimitiveTypeEnum.Boolean);
		public get manageAllRoles(): boolean { return this.__manageAllRoles.get(); }
		public set manageAllRoles(newValue: boolean) { this.__manageAllRoles.set(newValue); }
		private __manageableRoles: internal.ByNameReferenceListProperty<IUserRole> =
			new internal.ByNameReferenceListProperty<IUserRole>(UserRole, this, "manageableRoles", [], "Security$UserRole");
		public get manageableRoles(): internal.IList<IUserRole> { return this.__manageableRoles.get(); }
		public set manageableRoles(newValue: internal.IList<IUserRole>) { this.__manageableRoles.set(newValue); }
		get manageableRolesQualifiedNames(): string[] { return this.__manageableRoles.qualifiedNames(); }
		private __manageUsersWithoutRoles: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(UserRole, this, "manageUsersWithoutRoles", false, internal.PrimitiveTypeEnum.Boolean);
		public get manageUsersWithoutRoles(): boolean { return this.__manageUsersWithoutRoles.get(); }
		public set manageUsersWithoutRoles(newValue: boolean) { this.__manageUsersWithoutRoles.set(newValue); }
		private __checkSecurity: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(UserRole, this, "checkSecurity", false, internal.PrimitiveTypeEnum.Boolean);
		public get checkSecurity(): boolean { return this.__checkSecurity.get(); }
		public set checkSecurity(newValue: boolean) { this.__checkSecurity.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new UserRole() cannot be invoked directly, please use 'model.security.createUserRole()'"
				);
			}
		}

		/**
		 * Creates and returns a new UserRole instance in the SDK and on the server.
		 * The new UserRole will be automatically stored in the 'userRoles' property
		 * of the parent ProjectSecurity element passed as argument.
		 */
		public static createIn(container: ProjectSecurity): UserRole {
			return internal.instancehelpers.createElement(container, UserRole, "userRoles", true);
		}

		/**
		 * Creates and returns a new UserRole instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): UserRole {
			return internal.instancehelpers.createElement(model, UserRole);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.checkSecurity = true;
			this.guid = utils.randomUuid();
		}

	}
}

import {domainmodels} from "./domainmodels";
import {microflows} from "./microflows";

import {IModel} from "./base-model";
