/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;

import {projects} from "./projects";

export namespace settings {

	export class CertificateType extends internal.IEnum {
		public static Authority: CertificateType = new CertificateType("Authority", { });
		public static Client: CertificateType = new CertificateType("Client", { });
		protected qualifiedTsTypeName: string = "settings.CertificateType";
	}

	export class DatabaseType extends internal.IEnum {
		public static Hsqldb: DatabaseType = new DatabaseType("Hsqldb", { });
		public static Db2: DatabaseType = new DatabaseType("Db2", {
			"introduced" : "6.7.0"
		});
		public static SqlServer: DatabaseType = new DatabaseType("SqlServer", { });
		public static MySql: DatabaseType = new DatabaseType("MySql", { });
		public static Oracle: DatabaseType = new DatabaseType("Oracle", { });
		public static PostgreSql: DatabaseType = new DatabaseType("PostgreSql", { });
		protected qualifiedTsTypeName: string = "settings.DatabaseType";
	}

	export class FirstDayOfWeekEnum extends internal.IEnum {
		public static Default: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Default", { });
		public static Sunday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Sunday", { });
		public static Monday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Monday", { });
		public static Tuesday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Tuesday", { });
		public static Wednesday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Wednesday", { });
		public static Thursday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Thursday", { });
		public static Friday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Friday", { });
		public static Saturday: FirstDayOfWeekEnum = new FirstDayOfWeekEnum("Saturday", { });
		protected qualifiedTsTypeName: string = "settings.FirstDayOfWeekEnum";
	}

	export class HashAlgorithmType extends internal.IEnum {
		public static BCrypt: HashAlgorithmType = new HashAlgorithmType("BCrypt", { });
		public static SSHA256: HashAlgorithmType = new HashAlgorithmType("SSHA256", { });
		public static SHA256: HashAlgorithmType = new HashAlgorithmType("SHA256", { });
		public static MD5: HashAlgorithmType = new HashAlgorithmType("MD5", { });
		protected qualifiedTsTypeName: string = "settings.HashAlgorithmType";
	}

	export class RoundingMode extends internal.IEnum {
		public static HalfUp: RoundingMode = new RoundingMode("HalfUp", { });
		public static HalfEven: RoundingMode = new RoundingMode("HalfEven", { });
		protected qualifiedTsTypeName: string = "settings.RoundingMode";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Settings`.
	 */


	export interface ICertificate extends internal.IElement {
		model: IModel;
		containerAsCertificateSettings: ICertificateSettings;
		load(): Certificate;
		load(callback: (element: Certificate) => void, forceRefresh?: boolean);
	}

	export class Certificate extends internal.Element implements ICertificate {
		public static typeName: string = "Settings$Certificate";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsCertificateSettings() { return super.getContainerAs<CertificateSettings>(CertificateSettings); }

		private __type: internal.EnumProperty<CertificateType> =
			new internal.EnumProperty<CertificateType>(Certificate, this, "type", CertificateType.Authority, CertificateType);
		public get type(): CertificateType { return this.__type.get(); }
		public set type(newValue: CertificateType) { this.__type.set(newValue); }
		private __data: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Certificate, this, "data", null, internal.PrimitiveTypeEnum.Blob);
		public get data(): string { return this.__data.get(); }
		public set data(newValue: string) { this.__data.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Certificate() cannot be invoked directly, please use 'model.settings.createCertificate()'"
				);
			}
		}

		/**
		 * Creates and returns a new Certificate instance in the SDK and on the server.
		 * The new Certificate will be automatically stored in the 'certificates' property
		 * of the parent CertificateSettings element passed as argument.
		 */
		public static createIn(container: CertificateSettings): Certificate {
			return internal.instancehelpers.createElement(container, Certificate, "certificates", true);
		}

		/**
		 * Creates and returns a new Certificate instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Certificate {
			return internal.instancehelpers.createElement(model, Certificate);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = CertificateType.Authority;
		}

	}

	export interface IProjectSettingsPart extends internal.IElement {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): ProjectSettingsPart;
		load(callback: (element: ProjectSettingsPart) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ProjectSettingsPart extends internal.Element implements IProjectSettingsPart {
		public static typeName: string = "Settings$ProjectSettingsPart";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ProjectSettingsPart() cannot be invoked directly, please use 'model.settings.createProjectSettingsPart()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ICertificateSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): CertificateSettings;
		load(callback: (element: CertificateSettings) => void, forceRefresh?: boolean);
	}

	export class CertificateSettings extends ProjectSettingsPart implements ICertificateSettings {
		public static typeName: string = "Settings$CertificateSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __certificates: internal.PartListProperty<Certificate> =
			new internal.PartListProperty<Certificate>(CertificateSettings, this, "certificates", []);
		public get certificates(): internal.IList<Certificate> { return this.__certificates.get(); }
		public set certificates(newValue: internal.IList<Certificate>) { this.__certificates.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CertificateSettings() cannot be invoked directly, please use 'model.settings.createCertificateSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new CertificateSettings instance in the SDK and on the server.
		 * The new CertificateSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): CertificateSettings {
			return internal.instancehelpers.createElement(container, CertificateSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new CertificateSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CertificateSettings {
			return internal.instancehelpers.createElement(model, CertificateSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/configuration relevant section in reference guide}
	 */
	export interface IConfiguration extends internal.IElement {
		model: IModel;
		containerAsConfigurationSettings: IConfigurationSettings;
		load(): Configuration;
		load(callback: (element: Configuration) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/configuration relevant section in reference guide}
	 */
	export class Configuration extends internal.Element implements IConfiguration {
		public static typeName: string = "Settings$Configuration";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsConfigurationSettings() { return super.getContainerAs<ConfigurationSettings>(ConfigurationSettings); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __applicationRootUrl: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "applicationRootUrl", "", internal.PrimitiveTypeEnum.String);
		public get applicationRootUrl(): string { return this.__applicationRootUrl.get(); }
		public set applicationRootUrl(newValue: string) { this.__applicationRootUrl.set(newValue); }
		private __runtimePortNumber: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Configuration, this, "runtimePortNumber", 0, internal.PrimitiveTypeEnum.Integer);
		public get runtimePortNumber(): number { return this.__runtimePortNumber.get(); }
		public set runtimePortNumber(newValue: number) { this.__runtimePortNumber.set(newValue); }
		private __adminPortNumber: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Configuration, this, "adminPortNumber", 0, internal.PrimitiveTypeEnum.Integer);
		public get adminPortNumber(): number { return this.__adminPortNumber.get(); }
		public set adminPortNumber(newValue: number) { this.__adminPortNumber.set(newValue); }
		private __runtimePortOnlyLocal: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Configuration, this, "runtimePortOnlyLocal", false, internal.PrimitiveTypeEnum.Boolean);
		public get runtimePortOnlyLocal(): boolean { return this.__runtimePortOnlyLocal.get(); }
		public set runtimePortOnlyLocal(newValue: boolean) { this.__runtimePortOnlyLocal.set(newValue); }
		private __adminPortOnlyLocal: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Configuration, this, "adminPortOnlyLocal", false, internal.PrimitiveTypeEnum.Boolean);
		public get adminPortOnlyLocal(): boolean { return this.__adminPortOnlyLocal.get(); }
		public set adminPortOnlyLocal(newValue: boolean) { this.__adminPortOnlyLocal.set(newValue); }
		private __maxJavaHeapSize: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Configuration, this, "maxJavaHeapSize", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxJavaHeapSize(): number { return this.__maxJavaHeapSize.get(); }
		public set maxJavaHeapSize(newValue: number) { this.__maxJavaHeapSize.set(newValue); }
		private __emulateCloudSecurity: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Configuration, this, "emulateCloudSecurity", false, internal.PrimitiveTypeEnum.Boolean);
		public get emulateCloudSecurity(): boolean { return this.__emulateCloudSecurity.get(); }
		public set emulateCloudSecurity(newValue: boolean) { this.__emulateCloudSecurity.set(newValue); }
		private __extraJvmParameters: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "extraJvmParameters", "", internal.PrimitiveTypeEnum.String);
		public get extraJvmParameters(): string { return this.__extraJvmParameters.get(); }
		public set extraJvmParameters(newValue: string) { this.__extraJvmParameters.set(newValue); }
		private __databaseType: internal.EnumProperty<DatabaseType> =
			new internal.EnumProperty<DatabaseType>(Configuration, this, "databaseType", DatabaseType.Hsqldb, DatabaseType);
		public get databaseType(): DatabaseType { return this.__databaseType.get(); }
		public set databaseType(newValue: DatabaseType) { this.__databaseType.set(newValue); }
		private __databaseUrl: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "databaseUrl", "", internal.PrimitiveTypeEnum.String);
		public get databaseUrl(): string { return this.__databaseUrl.get(); }
		public set databaseUrl(newValue: string) { this.__databaseUrl.set(newValue); }
		private __databaseName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "databaseName", "", internal.PrimitiveTypeEnum.String);
		public get databaseName(): string { return this.__databaseName.get(); }
		public set databaseName(newValue: string) { this.__databaseName.set(newValue); }
		private __databaseUseIntegratedSecurity: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Configuration, this, "databaseUseIntegratedSecurity", false, internal.PrimitiveTypeEnum.Boolean);
		public get databaseUseIntegratedSecurity(): boolean { return this.__databaseUseIntegratedSecurity.get(); }
		public set databaseUseIntegratedSecurity(newValue: boolean) { this.__databaseUseIntegratedSecurity.set(newValue); }
		private __databaseUserName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "databaseUserName", "", internal.PrimitiveTypeEnum.String);
		public get databaseUserName(): string { return this.__databaseUserName.get(); }
		public set databaseUserName(newValue: string) { this.__databaseUserName.set(newValue); }
		private __databasePassword: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Configuration, this, "databasePassword", "", internal.PrimitiveTypeEnum.String);
		public get databasePassword(): string { return this.__databasePassword.get(); }
		public set databasePassword(newValue: string) { this.__databasePassword.set(newValue); }
		private __customSettings: internal.PartListProperty<CustomSetting> =
			new internal.PartListProperty<CustomSetting>(Configuration, this, "customSettings", []);
		public get customSettings(): internal.IList<CustomSetting> { return this.__customSettings.get(); }
		public set customSettings(newValue: internal.IList<CustomSetting>) { this.__customSettings.set(newValue); }
		private __constantValues: internal.PartListProperty<ConstantValue> =
			new internal.PartListProperty<ConstantValue>(Configuration, this, "constantValues", []);
		public get constantValues(): internal.IList<ConstantValue> { return this.__constantValues.get(); }
		public set constantValues(newValue: internal.IList<ConstantValue>) { this.__constantValues.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Configuration() cannot be invoked directly, please use 'model.settings.createConfiguration()'"
				);
			}
		}

		/**
		 * Creates and returns a new Configuration instance in the SDK and on the server.
		 * The new Configuration will be automatically stored in the 'configurations' property
		 * of the parent ConfigurationSettings element passed as argument.
		 */
		public static createIn(container: ConfigurationSettings): Configuration {
			return internal.instancehelpers.createElement(container, Configuration, "configurations", true);
		}

		/**
		 * Creates and returns a new Configuration instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Configuration {
			return internal.instancehelpers.createElement(model, Configuration);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.adminPortNumber = 8090;
			this.adminPortOnlyLocal = true;
			this.applicationRootUrl = "http://localhost:8080/";
			this.databaseName = "default";
			this.databaseType = DatabaseType.Hsqldb;
			this.emulateCloudSecurity = true;
			this.runtimePortNumber = 8080;
			this.runtimePortOnlyLocal = false;
		}

	}

	export interface IConfigurationSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): ConfigurationSettings;
		load(callback: (element: ConfigurationSettings) => void, forceRefresh?: boolean);
	}

	export class ConfigurationSettings extends ProjectSettingsPart implements IConfigurationSettings {
		public static typeName: string = "Settings$ConfigurationSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __configurations: internal.PartListProperty<Configuration> =
			new internal.PartListProperty<Configuration>(ConfigurationSettings, this, "configurations", []);
		public get configurations(): internal.IList<Configuration> { return this.__configurations.get(); }
		public set configurations(newValue: internal.IList<Configuration>) { this.__configurations.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ConfigurationSettings() cannot be invoked directly, please use 'model.settings.createConfigurationSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new ConfigurationSettings instance in the SDK and on the server.
		 * The new ConfigurationSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): ConfigurationSettings {
			return internal.instancehelpers.createElement(container, ConfigurationSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new ConfigurationSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ConfigurationSettings {
			return internal.instancehelpers.createElement(model, ConfigurationSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.configurations.replace([ ((configuration:Configuration) => {
				configuration.name = "Default";
				return configuration;
			})(Configuration.create(this.model)) ]);
		}

	}

	export interface IConstantValue extends internal.IElement {
		model: IModel;
		containerAsConfiguration: IConfiguration;
		load(): ConstantValue;
		load(callback: (element: ConstantValue) => void, forceRefresh?: boolean);
	}

	export class ConstantValue extends internal.Element implements IConstantValue {
		public static typeName: string = "Settings$ConstantValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"constant" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsConfiguration() { return super.getContainerAs<Configuration>(Configuration); }

		private __constant: internal.ByNameReferenceProperty<constants.IConstant> =
			new internal.ByNameReferenceProperty<constants.IConstant>(ConstantValue, this, "constant", null, "Constants$Constant");
		public get constant(): constants.IConstant { return this.__constant.get(); }
		public set constant(newValue: constants.IConstant) { this.__constant.set(newValue); }
		get constantQualifiedName(): string { return this.__constant.qualifiedName(); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ConstantValue, this, "value", "", internal.PrimitiveTypeEnum.String);
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ConstantValue() cannot be invoked directly, please use 'model.settings.createConstantValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new ConstantValue instance in the SDK and on the server.
		 * The new ConstantValue will be automatically stored in the 'constantValues' property
		 * of the parent Configuration element passed as argument.
		 */
		public static createIn(container: Configuration): ConstantValue {
			return internal.instancehelpers.createElement(container, ConstantValue, "constantValues", true);
		}

		/**
		 * Creates and returns a new ConstantValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ConstantValue {
			return internal.instancehelpers.createElement(model, ConstantValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ICustomSetting extends internal.IElement {
		model: IModel;
		containerAsConfiguration: IConfiguration;
		load(): CustomSetting;
		load(callback: (element: CustomSetting) => void, forceRefresh?: boolean);
	}

	export class CustomSetting extends internal.Element implements ICustomSetting {
		public static typeName: string = "Settings$CustomSetting";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsConfiguration() { return super.getContainerAs<Configuration>(Configuration); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CustomSetting, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __value: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(CustomSetting, this, "value", "", internal.PrimitiveTypeEnum.String);
		public get value(): string { return this.__value.get(); }
		public set value(newValue: string) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CustomSetting() cannot be invoked directly, please use 'model.settings.createCustomSetting()'"
				);
			}
		}

		/**
		 * Creates and returns a new CustomSetting instance in the SDK and on the server.
		 * The new CustomSetting will be automatically stored in the 'customSettings' property
		 * of the parent Configuration element passed as argument.
		 */
		public static createIn(container: Configuration): CustomSetting {
			return internal.instancehelpers.createElement(container, CustomSetting, "customSettings", true);
		}

		/**
		 * Creates and returns a new CustomSetting instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CustomSetting {
			return internal.instancehelpers.createElement(model, CustomSetting);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IIntegrationProjectSettingsPart extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): IntegrationProjectSettingsPart;
		load(callback: (element: IntegrationProjectSettingsPart) => void, forceRefresh?: boolean);
	}

	export class IntegrationProjectSettingsPart extends ProjectSettingsPart implements IIntegrationProjectSettingsPart {
		public static typeName: string = "Settings$IntegrationProjectSettingsPart";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new IntegrationProjectSettingsPart() cannot be invoked directly, please use 'model.settings.createIntegrationProjectSettingsPart()'"
				);
			}
		}

		/**
		 * Creates and returns a new IntegrationProjectSettingsPart instance in the SDK and on the server.
		 * The new IntegrationProjectSettingsPart will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): IntegrationProjectSettingsPart {
			return internal.instancehelpers.createElement(container, IntegrationProjectSettingsPart, "settingsParts", true);
		}

		/**
		 * Creates and returns a new IntegrationProjectSettingsPart instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): IntegrationProjectSettingsPart {
			return internal.instancehelpers.createElement(model, IntegrationProjectSettingsPart);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.9.0: introduced
	 */
	export interface IJavaActionsSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): JavaActionsSettings;
		load(callback: (element: JavaActionsSettings) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.9.0: introduced
	 */
	export class JavaActionsSettings extends ProjectSettingsPart implements IJavaActionsSettings {
		public static typeName: string = "Settings$JavaActionsSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.9.0",
			"experimental" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __generatePostfixesForParameters: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(JavaActionsSettings, this, "generatePostfixesForParameters", false, internal.PrimitiveTypeEnum.Boolean);
		public get generatePostfixesForParameters(): boolean { return this.__generatePostfixesForParameters.get(); }
		public set generatePostfixesForParameters(newValue: boolean) { this.__generatePostfixesForParameters.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new JavaActionsSettings() cannot be invoked directly, please use 'model.settings.createJavaActionsSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new JavaActionsSettings instance in the SDK and on the server.
		 * The new JavaActionsSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.9.0, 6.10.0, 7.0.0, 7.0.1
		 */
		public static createIn(container: ProjectSettings): JavaActionsSettings {
			internal.createInVersionCheck(container.model, JavaActionsSettings.typeName,
				["6.9.0", "6.10.0", "7.0.0", "7.0.1"]
			);
			return internal.instancehelpers.createElement(container, JavaActionsSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new JavaActionsSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): JavaActionsSettings {
			return internal.instancehelpers.createElement(model, JavaActionsSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ILanguage extends internal.IElement {
		model: IModel;
		containerAsLanguageSettings: ILanguageSettings;
		load(): Language;
		load(callback: (element: Language) => void, forceRefresh?: boolean);
	}

	export class Language extends internal.Element implements ILanguage {
		public static typeName: string = "Settings$Language";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsLanguageSettings() { return super.getContainerAs<LanguageSettings>(LanguageSettings); }

		private __code: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Language, this, "code", "", internal.PrimitiveTypeEnum.String);
		public get code(): string { return this.__code.get(); }
		public set code(newValue: string) { this.__code.set(newValue); }
		private __checkCompleteness: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Language, this, "checkCompleteness", false, internal.PrimitiveTypeEnum.Boolean);
		public get checkCompleteness(): boolean { return this.__checkCompleteness.get(); }
		public set checkCompleteness(newValue: boolean) { this.__checkCompleteness.set(newValue); }
		private __customDateFormat: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Language, this, "customDateFormat", "", internal.PrimitiveTypeEnum.String);
		public get customDateFormat(): string { return this.__customDateFormat.get(); }
		public set customDateFormat(newValue: string) { this.__customDateFormat.set(newValue); }
		private __customTimeFormat: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Language, this, "customTimeFormat", "", internal.PrimitiveTypeEnum.String);
		public get customTimeFormat(): string { return this.__customTimeFormat.get(); }
		public set customTimeFormat(newValue: string) { this.__customTimeFormat.set(newValue); }
		private __customDateTimeFormat: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Language, this, "customDateTimeFormat", "", internal.PrimitiveTypeEnum.String);
		public get customDateTimeFormat(): string { return this.__customDateTimeFormat.get(); }
		public set customDateTimeFormat(newValue: string) { this.__customDateTimeFormat.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Language() cannot be invoked directly, please use 'model.settings.createLanguage()'"
				);
			}
		}

		/**
		 * Creates and returns a new Language instance in the SDK and on the server.
		 * The new Language will be automatically stored in the 'languages' property
		 * of the parent LanguageSettings element passed as argument.
		 */
		public static createIn(container: LanguageSettings): Language {
			return internal.instancehelpers.createElement(container, Language, "languages", true);
		}

		/**
		 * Creates and returns a new Language instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Language {
			return internal.instancehelpers.createElement(model, Language);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ILanguageSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): LanguageSettings;
		load(callback: (element: LanguageSettings) => void, forceRefresh?: boolean);
	}

	export class LanguageSettings extends ProjectSettingsPart implements ILanguageSettings {
		public static typeName: string = "Settings$LanguageSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __defaultLanguageCode: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(LanguageSettings, this, "defaultLanguageCode", "", internal.PrimitiveTypeEnum.String);
		public get defaultLanguageCode(): string { return this.__defaultLanguageCode.get(); }
		public set defaultLanguageCode(newValue: string) { this.__defaultLanguageCode.set(newValue); }
		private __languages: internal.PartListProperty<Language> =
			new internal.PartListProperty<Language>(LanguageSettings, this, "languages", []);
		public get languages(): internal.IList<Language> { return this.__languages.get(); }
		public set languages(newValue: internal.IList<Language>) { this.__languages.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new LanguageSettings() cannot be invoked directly, please use 'model.settings.createLanguageSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new LanguageSettings instance in the SDK and on the server.
		 * The new LanguageSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): LanguageSettings {
			return internal.instancehelpers.createElement(container, LanguageSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new LanguageSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): LanguageSettings {
			return internal.instancehelpers.createElement(model, LanguageSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.defaultLanguageCode = "en_US";
			this.languages.replace([ ((language:Language) => {
				language.code = "en_US";
				return language;
			})(Language.create(this.model)) ]);
		}

	}

	export interface IModelerSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): ModelerSettings;
		load(callback: (element: ModelerSettings) => void, forceRefresh?: boolean);
	}

	export class ModelerSettings extends ProjectSettingsPart implements IModelerSettings {
		public static typeName: string = "Settings$ModelerSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __lowerCaseMicroflowVariables: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ModelerSettings, this, "lowerCaseMicroflowVariables", false, internal.PrimitiveTypeEnum.Boolean);
		public get lowerCaseMicroflowVariables(): boolean { return this.__lowerCaseMicroflowVariables.get(); }
		public set lowerCaseMicroflowVariables(newValue: boolean) { this.__lowerCaseMicroflowVariables.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ModelerSettings() cannot be invoked directly, please use 'model.settings.createModelerSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new ModelerSettings instance in the SDK and on the server.
		 * The new ModelerSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): ModelerSettings {
			return internal.instancehelpers.createElement(container, ModelerSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new ModelerSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ModelerSettings {
			return internal.instancehelpers.createElement(model, ModelerSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project-settings relevant section in reference guide}
	 */
	export interface IProjectSettings extends projects.IProjectDocument {
		model: IModel;
		containerAsProject: projects.IProject;
		load(): ProjectSettings;
		load(callback: (element: ProjectSettings) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project-settings relevant section in reference guide}
	 */
	export class ProjectSettings extends projects.ProjectDocument implements IProjectSettings {
		public static typeName: string = "Settings$ProjectSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<projects.Project>(projects.Project); }

		private __settingsParts: internal.PartListProperty<ProjectSettingsPart> =
			new internal.PartListProperty<ProjectSettingsPart>(ProjectSettings, this, "settingsParts", []);
		public get settingsParts(): internal.IList<ProjectSettingsPart> { return this.__settingsParts.get(); }
		public set settingsParts(newValue: internal.IList<ProjectSettingsPart>) { this.__settingsParts.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IProject) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "projectDocuments";
		}

		/**
		 * Creates a new ProjectSettings unit in the SDK and on the server.
		 * Expects one argument, the projects.IProject in which this unit is contained.
		 */
		public static createIn(container: projects.IProject): ProjectSettings {
			return internal.instancehelpers.createUnit(container, ProjectSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IRuntimeSettings extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): RuntimeSettings;
		load(callback: (element: RuntimeSettings) => void, forceRefresh?: boolean);
	}

	export class RuntimeSettings extends ProjectSettingsPart implements IRuntimeSettings {
		public static typeName: string = "Settings$RuntimeSettings";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __afterStartupMicroflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(RuntimeSettings, this, "afterStartupMicroflow", null, "Microflows$Microflow");
		public get afterStartupMicroflow(): microflows.IMicroflow { return this.__afterStartupMicroflow.get(); }
		public set afterStartupMicroflow(newValue: microflows.IMicroflow) { this.__afterStartupMicroflow.set(newValue); }
		get afterStartupMicroflowQualifiedName(): string { return this.__afterStartupMicroflow.qualifiedName(); }
		private __beforeShutdownMicroflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(RuntimeSettings, this, "beforeShutdownMicroflow", null, "Microflows$Microflow");
		public get beforeShutdownMicroflow(): microflows.IMicroflow { return this.__beforeShutdownMicroflow.get(); }
		public set beforeShutdownMicroflow(newValue: microflows.IMicroflow) { this.__beforeShutdownMicroflow.set(newValue); }
		get beforeShutdownMicroflowQualifiedName(): string { return this.__beforeShutdownMicroflow.qualifiedName(); }
		private __healthCheckMicroflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(RuntimeSettings, this, "healthCheckMicroflow", null, "Microflows$Microflow");
		public get healthCheckMicroflow(): microflows.IMicroflow { return this.__healthCheckMicroflow.get(); }
		public set healthCheckMicroflow(newValue: microflows.IMicroflow) { this.__healthCheckMicroflow.set(newValue); }
		get healthCheckMicroflowQualifiedName(): string { return this.__healthCheckMicroflow.qualifiedName(); }
		private __firstDayOfWeek: internal.EnumProperty<FirstDayOfWeekEnum> =
			new internal.EnumProperty<FirstDayOfWeekEnum>(RuntimeSettings, this, "firstDayOfWeek", FirstDayOfWeekEnum.Default, FirstDayOfWeekEnum);
		public get firstDayOfWeek(): FirstDayOfWeekEnum { return this.__firstDayOfWeek.get(); }
		public set firstDayOfWeek(newValue: FirstDayOfWeekEnum) { this.__firstDayOfWeek.set(newValue); }
		private __defaultTimeZoneCode: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RuntimeSettings, this, "defaultTimeZoneCode", "", internal.PrimitiveTypeEnum.String);
		public get defaultTimeZoneCode(): string { return this.__defaultTimeZoneCode.get(); }
		public set defaultTimeZoneCode(newValue: string) { this.__defaultTimeZoneCode.set(newValue); }
		private __scheduledEventTimeZoneCode: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RuntimeSettings, this, "scheduledEventTimeZoneCode", "", internal.PrimitiveTypeEnum.String);
		public get scheduledEventTimeZoneCode(): string { return this.__scheduledEventTimeZoneCode.get(); }
		public set scheduledEventTimeZoneCode(newValue: string) { this.__scheduledEventTimeZoneCode.set(newValue); }
		private __hashAlgorithm: internal.EnumProperty<HashAlgorithmType> =
			new internal.EnumProperty<HashAlgorithmType>(RuntimeSettings, this, "hashAlgorithm", HashAlgorithmType.BCrypt, HashAlgorithmType);
		public get hashAlgorithm(): HashAlgorithmType { return this.__hashAlgorithm.get(); }
		public set hashAlgorithm(newValue: HashAlgorithmType) { this.__hashAlgorithm.set(newValue); }
		private __roundingMode: internal.EnumProperty<RoundingMode> =
			new internal.EnumProperty<RoundingMode>(RuntimeSettings, this, "roundingMode", RoundingMode.HalfUp, RoundingMode);
		public get roundingMode(): RoundingMode { return this.__roundingMode.get(); }
		public set roundingMode(newValue: RoundingMode) { this.__roundingMode.set(newValue); }
		private __allowUserMultipleSessions: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(RuntimeSettings, this, "allowUserMultipleSessions", false, internal.PrimitiveTypeEnum.Boolean);
		public get allowUserMultipleSessions(): boolean { return this.__allowUserMultipleSessions.get(); }
		public set allowUserMultipleSessions(newValue: boolean) { this.__allowUserMultipleSessions.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuntimeSettings() cannot be invoked directly, please use 'model.settings.createRuntimeSettings()'"
				);
			}
		}

		/**
		 * Creates and returns a new RuntimeSettings instance in the SDK and on the server.
		 * The new RuntimeSettings will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): RuntimeSettings {
			return internal.instancehelpers.createElement(container, RuntimeSettings, "settingsParts", true);
		}

		/**
		 * Creates and returns a new RuntimeSettings instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RuntimeSettings {
			return internal.instancehelpers.createElement(model, RuntimeSettings);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.firstDayOfWeek = FirstDayOfWeekEnum.Default;
			this.hashAlgorithm = HashAlgorithmType.BCrypt;
			this.roundingMode = RoundingMode.HalfUp;
			this.scheduledEventTimeZoneCode = "Etc/UTC";
		}

	}

	export interface IWebUIProjectSettingsPart extends IProjectSettingsPart {
		model: IModel;
		containerAsProjectSettings: IProjectSettings;
		load(): WebUIProjectSettingsPart;
		load(callback: (element: WebUIProjectSettingsPart) => void, forceRefresh?: boolean);
	}

	export class WebUIProjectSettingsPart extends ProjectSettingsPart implements IWebUIProjectSettingsPart {
		public static typeName: string = "Settings$WebUIProjectSettingsPart";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"feedbackWidgetUpdated" : {
					"deleted" : "6.2.0",
					"deletionMessage" : null
				},
				"enableDownloadResources" : {
					"introduced" : "6.6.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectSettings() { return super.getContainerAs<ProjectSettings>(ProjectSettings); }

		private __theme: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(WebUIProjectSettingsPart, this, "theme", "", internal.PrimitiveTypeEnum.String);
		public get theme(): string { return this.__theme.get(); }
		public set theme(newValue: string) { this.__theme.set(newValue); }
		private __feedbackWidgetUpdated: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebUIProjectSettingsPart, this, "feedbackWidgetUpdated", false, internal.PrimitiveTypeEnum.Boolean);
		/**
		 * In version 6.2.0: deleted
		 */
		public get feedbackWidgetUpdated(): boolean { return this.__feedbackWidgetUpdated.get(); }
		public set feedbackWidgetUpdated(newValue: boolean) { this.__feedbackWidgetUpdated.set(newValue); }
		private __enableWidgetBundling: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebUIProjectSettingsPart, this, "enableWidgetBundling", false, internal.PrimitiveTypeEnum.Boolean);
		public get enableWidgetBundling(): boolean { return this.__enableWidgetBundling.get(); }
		public set enableWidgetBundling(newValue: boolean) { this.__enableWidgetBundling.set(newValue); }
		private __enableDownloadResources: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(WebUIProjectSettingsPart, this, "enableDownloadResources", false, internal.PrimitiveTypeEnum.Boolean);
		/**
		 * In version 6.6.0: introduced
		 */
		public get enableDownloadResources(): boolean { return this.__enableDownloadResources.get(); }
		public set enableDownloadResources(newValue: boolean) { this.__enableDownloadResources.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new WebUIProjectSettingsPart() cannot be invoked directly, please use 'model.settings.createWebUIProjectSettingsPart()'"
				);
			}
		}

		/**
		 * Creates and returns a new WebUIProjectSettingsPart instance in the SDK and on the server.
		 * The new WebUIProjectSettingsPart will be automatically stored in the 'settingsParts' property
		 * of the parent ProjectSettings element passed as argument.
		 */
		public static createIn(container: ProjectSettings): WebUIProjectSettingsPart {
			return internal.instancehelpers.createElement(container, WebUIProjectSettingsPart, "settingsParts", true);
		}

		/**
		 * Creates and returns a new WebUIProjectSettingsPart instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): WebUIProjectSettingsPart {
			return internal.instancehelpers.createElement(model, WebUIProjectSettingsPart);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.theme = "(Default)";
		}

	}
}

import {constants} from "./constants";
import {microflows} from "./microflows";

import {IModel} from "./base-model";
