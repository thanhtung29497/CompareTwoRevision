/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import {utils} from "../sdk/utils";
import {common} from "../common";

import {projects} from "./projects";

export namespace domainmodels {

	export class ActionMoment extends internal.IEnum {
		public static Before: ActionMoment = new ActionMoment("Before", { });
		public static After: ActionMoment = new ActionMoment("After", { });
		protected qualifiedTsTypeName: string = "domainmodels.ActionMoment";
	}

	export class AssociationOwner extends internal.IEnum {
		public static Default: AssociationOwner = new AssociationOwner("Default", { });
		public static Both: AssociationOwner = new AssociationOwner("Both", { });
		protected qualifiedTsTypeName: string = "domainmodels.AssociationOwner";
	}

	export class AssociationType extends internal.IEnum {
		public static Reference: AssociationType = new AssociationType("Reference", { });
		public static ReferenceSet: AssociationType = new AssociationType("ReferenceSet", { });
		protected qualifiedTsTypeName: string = "domainmodels.AssociationType";
	}

	export class DeletingBehavior extends internal.IEnum {
		public static DeleteMeAndReferences: DeletingBehavior = new DeletingBehavior("DeleteMeAndReferences", { });
		public static DeleteMeButKeepReferences: DeletingBehavior = new DeletingBehavior("DeleteMeButKeepReferences", { });
		public static DeleteMeIfNoReferences: DeletingBehavior = new DeletingBehavior("DeleteMeIfNoReferences", { });
		protected qualifiedTsTypeName: string = "domainmodels.DeletingBehavior";
	}

	export class EventType extends internal.IEnum {
		public static Create: EventType = new EventType("Create", { });
		public static Commit: EventType = new EventType("Commit", { });
		public static Delete: EventType = new EventType("Delete", { });
		public static RollBack: EventType = new EventType("RollBack", { });
		protected qualifiedTsTypeName: string = "domainmodels.EventType";
	}

	export class IndexedAttributeType extends internal.IEnum {
		public static Normal: IndexedAttributeType = new IndexedAttributeType("Normal", { });
		public static CreatedDate: IndexedAttributeType = new IndexedAttributeType("CreatedDate", { });
		public static ChangedDate: IndexedAttributeType = new IndexedAttributeType("ChangedDate", { });
		protected qualifiedTsTypeName: string = "domainmodels.IndexedAttributeType";
	}

	export class MemberAccessRights extends internal.IEnum {
		public static None: MemberAccessRights = new MemberAccessRights("None", { });
		public static ReadOnly: MemberAccessRights = new MemberAccessRights("ReadOnly", { });
		public static ReadWrite: MemberAccessRights = new MemberAccessRights("ReadWrite", { });
		protected qualifiedTsTypeName: string = "domainmodels.MemberAccessRights";
	}

	export class RangeType extends internal.IEnum {
		public static GreaterThanOrEqualTo: RangeType = new RangeType("GreaterThanOrEqualTo", { });
		public static SmallerThanOrEqualTo: RangeType = new RangeType("SmallerThanOrEqualTo", { });
		public static Between: RangeType = new RangeType("Between", { });
		protected qualifiedTsTypeName: string = "domainmodels.RangeType";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `DomainModels`.
	 */


	/**
	 * See: {@link https://docs.mendix.com/refguide7/access-rules relevant section in reference guide}
	 */
	export interface IAccessRule extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		containerAsAccessRuleContainerBase: security.IAccessRuleContainerBase;
		load(): AccessRule;
		load(callback: (element: AccessRule) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/access-rules relevant section in reference guide}
	 */
	export class AccessRule extends internal.Element implements IAccessRule {
		public static typeName: string = "DomainModels$AccessRule";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }
		get containerAsAccessRuleContainerBase() { return super.getContainerAs<security.AccessRuleContainerBase>(security.AccessRuleContainerBase); }

		private __memberAccesses: internal.PartListProperty<MemberAccess> =
			new internal.PartListProperty<MemberAccess>(AccessRule, this, "memberAccesses", []);
		public get memberAccesses(): internal.IList<MemberAccess> { return this.__memberAccesses.get(); }
		public set memberAccesses(newValue: internal.IList<MemberAccess>) { this.__memberAccesses.set(newValue); }
		private __moduleRoles: internal.ByNameReferenceListProperty<security.IModuleRole> =
			new internal.ByNameReferenceListProperty<security.IModuleRole>(AccessRule, this, "moduleRoles", [], "Security$ModuleRole");
		public get moduleRoles(): internal.IList<security.IModuleRole> { return this.__moduleRoles.get(); }
		public set moduleRoles(newValue: internal.IList<security.IModuleRole>) { this.__moduleRoles.set(newValue); }
		get moduleRolesQualifiedNames(): string[] { return this.__moduleRoles.qualifiedNames(); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AccessRule, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __allowCreate: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(AccessRule, this, "allowCreate", false, internal.PrimitiveTypeEnum.Boolean);
		public get allowCreate(): boolean { return this.__allowCreate.get(); }
		public set allowCreate(newValue: boolean) { this.__allowCreate.set(newValue); }
		private __allowDelete: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(AccessRule, this, "allowDelete", false, internal.PrimitiveTypeEnum.Boolean);
		public get allowDelete(): boolean { return this.__allowDelete.get(); }
		public set allowDelete(newValue: boolean) { this.__allowDelete.set(newValue); }
		private __defaultMemberAccessRights: internal.EnumProperty<MemberAccessRights> =
			new internal.EnumProperty<MemberAccessRights>(AccessRule, this, "defaultMemberAccessRights", MemberAccessRights.None, MemberAccessRights);
		public get defaultMemberAccessRights(): MemberAccessRights { return this.__defaultMemberAccessRights.get(); }
		public set defaultMemberAccessRights(newValue: MemberAccessRights) { this.__defaultMemberAccessRights.set(newValue); }
		private __xPathConstraint: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AccessRule, this, "xPathConstraint", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
		 */
		public get xPathConstraint(): string { return this.__xPathConstraint.get(); }
		public set xPathConstraint(newValue: string) { this.__xPathConstraint.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AccessRule() cannot be invoked directly, please use 'model.domainmodels.createAccessRule()'"
				);
			}
		}


		/**
		 * Creates and returns a new AccessRule instance in the SDK and on the server.
		 * The new AccessRule will be automatically stored in the 'accessRules' property
		 * of the parent Entity element passed as argument.
		 */
		public static createInEntityUnderAccessRules(container: Entity): AccessRule {
			return internal.instancehelpers.createElement(container, AccessRule, "accessRules", true);
		}

		/**
		 * Creates and returns a new AccessRule instance in the SDK and on the server.
		 * The new AccessRule will be automatically stored in the 'accessRules' property
		 * of the parent security.AccessRuleContainerBase element passed as argument.
		 */
		public static createInAccessRuleContainerBaseUnderAccessRules(container: security.AccessRuleContainerBase): AccessRule {
			return internal.instancehelpers.createElement(container, AccessRule, "accessRules", true);
		}

		/**
		 * Creates and returns a new AccessRule instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AccessRule {
			return internal.instancehelpers.createElement(model, AccessRule);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.defaultMemberAccessRights = MemberAccessRights.None;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotations relevant section in reference guide}
	 */
	export interface IAnnotation extends internal.IElement {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		load(): Annotation;
		load(callback: (element: Annotation) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/annotations relevant section in reference guide}
	 */
	export class Annotation extends internal.Element implements IAnnotation {
		public static typeName: string = "DomainModels$Annotation";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __caption: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Annotation, this, "caption", "", internal.PrimitiveTypeEnum.String);
		public get caption(): string { return this.__caption.get(); }
		public set caption(newValue: string) { this.__caption.set(newValue); }
		private __location: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(Annotation, this, "location", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get location(): common.IPoint { return this.__location.get(); }
		public set location(newValue: common.IPoint) { this.__location.set(newValue); }
		private __width: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Annotation, this, "width", 0, internal.PrimitiveTypeEnum.Integer);
		public get width(): number { return this.__width.get(); }
		public set width(newValue: number) { this.__width.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Annotation() cannot be invoked directly, please use 'model.domainmodels.createAnnotation()'"
				);
			}
		}

		/**
		 * Creates and returns a new Annotation instance in the SDK and on the server.
		 * The new Annotation will be automatically stored in the 'annotations' property
		 * of the parent DomainModel element passed as argument.
		 */
		public static createIn(container: DomainModel): Annotation {
			return internal.instancehelpers.createElement(container, Annotation, "annotations", true);
		}

		/**
		 * Creates and returns a new Annotation instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Annotation {
			return internal.instancehelpers.createElement(model, Annotation);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.width = 250;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/associations TODO: This is whre it belongs, but the word AssociationBase is never used}
	 */
	export interface IAssociationBase extends internal.IElement {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		name: string;
		type: AssociationType;
		owner: AssociationOwner;
		/**
		 * This property is required and cannot be set to null.
		 */
		parent: IEntity;
		load(): AssociationBase;
		load(callback: (element: AssociationBase) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/associations TODO: This is whre it belongs, but the word AssociationBase is never used}
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class AssociationBase extends internal.Element implements IAssociationBase {
		public static typeName: string = "DomainModels$AssociationBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"type" : {
					"public" : {
						"currentValue" : true
					}
				},
				"owner" : {
					"public" : {
						"currentValue" : true
					}
				},
				"deleteBehavior" : {
					"required" : {
						"currentValue" : true
					}
				},
				"parent" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AssociationBase, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __dataStorageGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AssociationBase, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
		public get dataStorageGuid(): string { return this.__dataStorageGuid.get(); }
		public set dataStorageGuid(newValue: string) { this.__dataStorageGuid.set(newValue); }
		private __type: internal.EnumProperty<AssociationType> =
			new internal.EnumProperty<AssociationType>(AssociationBase, this, "type", AssociationType.Reference, AssociationType);
		public get type(): AssociationType { return this.__type.get(); }
		public set type(newValue: AssociationType) { this.__type.set(newValue); }
		private __owner: internal.EnumProperty<AssociationOwner> =
			new internal.EnumProperty<AssociationOwner>(AssociationBase, this, "owner", AssociationOwner.Default, AssociationOwner);
		public get owner(): AssociationOwner { return this.__owner.get(); }
		public set owner(newValue: AssociationOwner) { this.__owner.set(newValue); }
		private __deleteBehavior: internal.PartProperty<AssociationDeleteBehavior> =
			new internal.PartProperty<AssociationDeleteBehavior>(AssociationBase, this, "deleteBehavior", null, true);
		public get deleteBehavior(): AssociationDeleteBehavior { return this.__deleteBehavior.get(); }
		public set deleteBehavior(newValue: AssociationDeleteBehavior) { this.__deleteBehavior.set(newValue); }
		private __parent: internal.ByIdReferenceProperty<Entity> =
			new internal.ByIdReferenceProperty<Entity>(AssociationBase, this, "parent", null);
		public get parent(): Entity { return this.__parent.get(); }
		public set parent(newValue: Entity) { this.__parent.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(AssociationBase, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AssociationBase() cannot be invoked directly, please use 'model.domainmodels.createAssociationBase()'"
				);
			}
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataStorageGuid = utils.randomUuid();
			this.deleteBehavior = AssociationDeleteBehavior.create(this.model);
			this.owner = AssociationOwner.Default;
			this.type = AssociationType.Reference;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/associations relevant section in reference guide}
	 */
	export interface IAssociation extends IAssociationBase {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		/**
		 * This property is required and cannot be set to null.
		 */
		child: IEntity;
		load(): Association;
		load(callback: (element: Association) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/associations relevant section in reference guide}
	 */
	export class Association extends AssociationBase implements IAssociation {
		public static typeName: string = "DomainModels$Association";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"child" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __child: internal.ByIdReferenceProperty<Entity> =
			new internal.ByIdReferenceProperty<Entity>(Association, this, "child", null);
		public get child(): Entity { return this.__child.get(); }
		public set child(newValue: Entity) { this.__child.set(newValue); }
		private __parentConnection: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(Association, this, "parentConnection", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get parentConnection(): common.IPoint { return this.__parentConnection.get(); }
		public set parentConnection(newValue: common.IPoint) { this.__parentConnection.set(newValue); }
		private __childConnection: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(Association, this, "childConnection", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get childConnection(): common.IPoint { return this.__childConnection.get(); }
		public set childConnection(newValue: common.IPoint) { this.__childConnection.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Association() cannot be invoked directly, please use 'model.domainmodels.createAssociation()'"
				);
			}
		}

		/**
		 * Creates and returns a new Association instance in the SDK and on the server.
		 * The new Association will be automatically stored in the 'associations' property
		 * of the parent DomainModel element passed as argument.
		 */
		public static createIn(container: DomainModel): Association {
			return internal.instancehelpers.createElement(container, Association, "associations", true);
		}

		/**
		 * Creates and returns a new Association instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Association {
			return internal.instancehelpers.createElement(model, Association);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IAssociationDeleteBehavior extends internal.IElement {
		model: IModel;
		containerAsAssociationBase: IAssociationBase;
		load(): AssociationDeleteBehavior;
		load(callback: (element: AssociationDeleteBehavior) => void, forceRefresh?: boolean);
	}

	export class AssociationDeleteBehavior extends internal.Element implements IAssociationDeleteBehavior {
		public static typeName: string = "DomainModels$AssociationDeleteBehavior";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsAssociationBase() { return super.getContainerAs<AssociationBase>(AssociationBase); }

		private __parentDeleteBehavior: internal.EnumProperty<DeletingBehavior> =
			new internal.EnumProperty<DeletingBehavior>(AssociationDeleteBehavior, this, "parentDeleteBehavior", DeletingBehavior.DeleteMeButKeepReferences, DeletingBehavior);
		public get parentDeleteBehavior(): DeletingBehavior { return this.__parentDeleteBehavior.get(); }
		public set parentDeleteBehavior(newValue: DeletingBehavior) { this.__parentDeleteBehavior.set(newValue); }
		private __childDeleteBehavior: internal.EnumProperty<DeletingBehavior> =
			new internal.EnumProperty<DeletingBehavior>(AssociationDeleteBehavior, this, "childDeleteBehavior", DeletingBehavior.DeleteMeButKeepReferences, DeletingBehavior);
		public get childDeleteBehavior(): DeletingBehavior { return this.__childDeleteBehavior.get(); }
		public set childDeleteBehavior(newValue: DeletingBehavior) { this.__childDeleteBehavior.set(newValue); }
		private __parentErrorMessage: internal.PartProperty<texts.Text> =
			new internal.PartProperty<texts.Text>(AssociationDeleteBehavior, this, "parentErrorMessage", null, false);
		public get parentErrorMessage(): texts.Text { return this.__parentErrorMessage.get(); }
		public set parentErrorMessage(newValue: texts.Text) { this.__parentErrorMessage.set(newValue); }
		private __childErrorMessage: internal.PartProperty<texts.Text> =
			new internal.PartProperty<texts.Text>(AssociationDeleteBehavior, this, "childErrorMessage", null, false);
		public get childErrorMessage(): texts.Text { return this.__childErrorMessage.get(); }
		public set childErrorMessage(newValue: texts.Text) { this.__childErrorMessage.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AssociationDeleteBehavior() cannot be invoked directly, please use 'model.domainmodels.createAssociationDeleteBehavior()'"
				);
			}
		}

		/**
		 * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
		 * The new AssociationDeleteBehavior will be automatically stored in the 'deleteBehavior' property
		 * of the parent AssociationBase element passed as argument.
		 */
		public static createIn(container: AssociationBase): AssociationDeleteBehavior {
			return internal.instancehelpers.createElement(container, AssociationDeleteBehavior, "deleteBehavior", false);
		}

		/**
		 * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AssociationDeleteBehavior {
			return internal.instancehelpers.createElement(model, AssociationDeleteBehavior);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.childDeleteBehavior = DeletingBehavior.DeleteMeButKeepReferences;
			this.parentDeleteBehavior = DeletingBehavior.DeleteMeButKeepReferences;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/attributes relevant section in reference guide}
	 */
	export interface IAttribute extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		name: string;
		/**
		 * This property is required and cannot be set to null.
		 */
		type: IAttributeType;
		/**
		 * This property is required and cannot be set to null.
		 *
		 * In version 6.6.0: added public
		 */
		value: IValueType;
		load(): Attribute;
		load(callback: (element: Attribute) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/attributes relevant section in reference guide}
	 */
	export class Attribute extends internal.Element implements IAttribute {
		public static typeName: string = "DomainModels$Attribute";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"type" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				},
				"value" : {
					"public" : {
						"currentValue" : true,
						"changedIn" : [
							"6.6.0"
						]
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Attribute, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __dataStorageGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Attribute, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
		public get dataStorageGuid(): string { return this.__dataStorageGuid.get(); }
		public set dataStorageGuid(newValue: string) { this.__dataStorageGuid.set(newValue); }
		private __type: internal.PartProperty<AttributeType> =
			new internal.PartProperty<AttributeType>(Attribute, this, "type", null, true);
		public get type(): AttributeType { return this.__type.get(); }
		public set type(newValue: AttributeType) { this.__type.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Attribute, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __value: internal.PartProperty<ValueType> =
			new internal.PartProperty<ValueType>(Attribute, this, "value", null, true);
		/**
		 * In version 6.6.0: added public
		 */
		public get value(): ValueType { return this.__value.get(); }
		public set value(newValue: ValueType) { this.__value.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Attribute() cannot be invoked directly, please use 'model.domainmodels.createAttribute()'"
				);
			}
		}

		/**
		 * Creates and returns a new Attribute instance in the SDK and on the server.
		 * The new Attribute will be automatically stored in the 'attributes' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): Attribute {
			return internal.instancehelpers.createElement(container, Attribute, "attributes", true);
		}

		/**
		 * Creates and returns a new Attribute instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Attribute {
			return internal.instancehelpers.createElement(model, Attribute);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataStorageGuid = utils.randomUuid();
			this.type = StringAttributeType.create(this.model);
			this.value = StoredValue.create(this.model);
		}

	}

	export interface IAttributeType extends internal.IElement {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): AttributeType;
		load(callback: (element: AttributeType) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class AttributeType extends internal.Element implements IAttributeType {
		public static typeName: string = "DomainModels$AttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AttributeType() cannot be invoked directly, please use 'model.domainmodels.createAttributeType()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface INumericAttributeTypeBase extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): NumericAttributeTypeBase;
		load(callback: (element: NumericAttributeTypeBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class NumericAttributeTypeBase extends AttributeType implements INumericAttributeTypeBase {
		public static typeName: string = "DomainModels$NumericAttributeTypeBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new NumericAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createNumericAttributeTypeBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IIntegerAttributeTypeBase extends INumericAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): IntegerAttributeTypeBase;
		load(callback: (element: IntegerAttributeTypeBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class IntegerAttributeTypeBase extends NumericAttributeTypeBase implements IIntegerAttributeTypeBase {
		public static typeName: string = "DomainModels$IntegerAttributeTypeBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new IntegerAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createIntegerAttributeTypeBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IAutoNumberAttributeType extends IIntegerAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): AutoNumberAttributeType;
		load(callback: (element: AutoNumberAttributeType) => void, forceRefresh?: boolean);
	}

	export class AutoNumberAttributeType extends IntegerAttributeTypeBase implements IAutoNumberAttributeType {
		public static typeName: string = "DomainModels$AutoNumberAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AutoNumberAttributeType() cannot be invoked directly, please use 'model.domainmodels.createAutoNumberAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
		 * The new AutoNumberAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): AutoNumberAttributeType {
			return internal.instancehelpers.createElement(container, AutoNumberAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): AutoNumberAttributeType {
			return internal.instancehelpers.createElement(model, AutoNumberAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IBinaryAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): BinaryAttributeType;
		load(callback: (element: BinaryAttributeType) => void, forceRefresh?: boolean);
	}

	export class BinaryAttributeType extends AttributeType implements IBinaryAttributeType {
		public static typeName: string = "DomainModels$BinaryAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BinaryAttributeType() cannot be invoked directly, please use 'model.domainmodels.createBinaryAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
		 * The new BinaryAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): BinaryAttributeType {
			return internal.instancehelpers.createElement(container, BinaryAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BinaryAttributeType {
			return internal.instancehelpers.createElement(model, BinaryAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IBooleanAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): BooleanAttributeType;
		load(callback: (element: BooleanAttributeType) => void, forceRefresh?: boolean);
	}

	export class BooleanAttributeType extends AttributeType implements IBooleanAttributeType {
		public static typeName: string = "DomainModels$BooleanAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BooleanAttributeType() cannot be invoked directly, please use 'model.domainmodels.createBooleanAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
		 * The new BooleanAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): BooleanAttributeType {
			return internal.instancehelpers.createElement(container, BooleanAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BooleanAttributeType {
			return internal.instancehelpers.createElement(model, BooleanAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.6.0: added public
	 */
	export interface IValueType extends internal.IElement {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): ValueType;
		load(callback: (element: ValueType) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

	 *
	 * In version 6.6.0: added public
	 */
	export abstract class ValueType extends internal.Element implements IValueType {
		public static typeName: string = "DomainModels$ValueType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true,
				"changedIn" : [
					"6.6.0"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ValueType() cannot be invoked directly, please use 'model.domainmodels.createValueType()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.6.0: added public
	 */
	export interface ICalculatedValue extends IValueType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): CalculatedValue;
		load(callback: (element: CalculatedValue) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.6.0: added public
	 */
	export class CalculatedValue extends ValueType implements ICalculatedValue {
		public static typeName: string = "DomainModels$CalculatedValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true,
				"changedIn" : [
					"6.6.0"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }

		private __microflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(CalculatedValue, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): microflows.IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: microflows.IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }
		private __passEntity: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(CalculatedValue, this, "passEntity", false, internal.PrimitiveTypeEnum.Boolean);
		public get passEntity(): boolean { return this.__passEntity.get(); }
		public set passEntity(newValue: boolean) { this.__passEntity.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CalculatedValue() cannot be invoked directly, please use 'model.domainmodels.createCalculatedValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new CalculatedValue instance in the SDK and on the server.
		 * The new CalculatedValue will be automatically stored in the 'value' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): CalculatedValue {
			return internal.instancehelpers.createElement(container, CalculatedValue, "value", false);
		}

		/**
		 * Creates and returns a new CalculatedValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CalculatedValue {
			return internal.instancehelpers.createElement(model, CalculatedValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.passEntity = true;
		}

	}

	export interface ICrossAssociation extends IAssociationBase {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		/**
		 * This property is required and cannot be set to null.
		 */
		child: IEntity;
		childQualifiedName: string;
		load(): CrossAssociation;
		load(callback: (element: CrossAssociation) => void, forceRefresh?: boolean);
	}

	export class CrossAssociation extends AssociationBase implements ICrossAssociation {
		public static typeName: string = "DomainModels$CrossAssociation";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"child" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __child: internal.ByNameReferenceProperty<IEntity> =
			new internal.ByNameReferenceProperty<IEntity>(CrossAssociation, this, "child", null, "DomainModels$Entity");
		public get child(): IEntity { return this.__child.get(); }
		public set child(newValue: IEntity) { this.__child.set(newValue); }
		get childQualifiedName(): string { return this.__child.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CrossAssociation() cannot be invoked directly, please use 'model.domainmodels.createCrossAssociation()'"
				);
			}
		}

		/**
		 * Creates and returns a new CrossAssociation instance in the SDK and on the server.
		 * The new CrossAssociation will be automatically stored in the 'crossAssociations' property
		 * of the parent DomainModel element passed as argument.
		 */
		public static createIn(container: DomainModel): CrossAssociation {
			return internal.instancehelpers.createElement(container, CrossAssociation, "crossAssociations", true);
		}

		/**
		 * Creates and returns a new CrossAssociation instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CrossAssociation {
			return internal.instancehelpers.createElement(model, CrossAssociation);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDecimalAttributeTypeBase extends INumericAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): DecimalAttributeTypeBase;
		load(callback: (element: DecimalAttributeTypeBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class DecimalAttributeTypeBase extends NumericAttributeTypeBase implements IDecimalAttributeTypeBase {
		public static typeName: string = "DomainModels$DecimalAttributeTypeBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DecimalAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createDecimalAttributeTypeBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFloatAttributeTypeBase extends IDecimalAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): FloatAttributeTypeBase;
		load(callback: (element: FloatAttributeTypeBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class FloatAttributeTypeBase extends DecimalAttributeTypeBase implements IFloatAttributeTypeBase {
		public static typeName: string = "DomainModels$FloatAttributeTypeBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new FloatAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createFloatAttributeTypeBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.0.0: deprecated
	 */
	export interface ICurrencyAttributeType extends IFloatAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): CurrencyAttributeType;
		load(callback: (element: CurrencyAttributeType) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.0: deprecated
	 */
	export class CurrencyAttributeType extends FloatAttributeTypeBase implements ICurrencyAttributeType {
		public static typeName: string = "DomainModels$CurrencyAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"deprecated" : "6.0.0",
			"deprecationMessage" : "CurrencyAttributeType has been deprecated. Please use DecimalAttributeType instead.",
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new CurrencyAttributeType() cannot be invoked directly, please use 'model.domainmodels.createCurrencyAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
		 * The new CurrencyAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): CurrencyAttributeType {
			return internal.instancehelpers.createElement(container, CurrencyAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): CurrencyAttributeType {
			return internal.instancehelpers.createElement(model, CurrencyAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDateTimeAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): DateTimeAttributeType;
		load(callback: (element: DateTimeAttributeType) => void, forceRefresh?: boolean);
	}

	export class DateTimeAttributeType extends AttributeType implements IDateTimeAttributeType {
		public static typeName: string = "DomainModels$DateTimeAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }

		private __localizeDate: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DateTimeAttributeType, this, "localizeDate", false, internal.PrimitiveTypeEnum.Boolean);
		public get localizeDate(): boolean { return this.__localizeDate.get(); }
		public set localizeDate(newValue: boolean) { this.__localizeDate.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DateTimeAttributeType() cannot be invoked directly, please use 'model.domainmodels.createDateTimeAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
		 * The new DateTimeAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): DateTimeAttributeType {
			return internal.instancehelpers.createElement(container, DateTimeAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DateTimeAttributeType {
			return internal.instancehelpers.createElement(model, DateTimeAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.localizeDate = true;
		}

	}

	export interface IDecimalAttributeType extends IDecimalAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): DecimalAttributeType;
		load(callback: (element: DecimalAttributeType) => void, forceRefresh?: boolean);
	}

	export class DecimalAttributeType extends DecimalAttributeTypeBase implements IDecimalAttributeType {
		public static typeName: string = "DomainModels$DecimalAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DecimalAttributeType() cannot be invoked directly, please use 'model.domainmodels.createDecimalAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
		 * The new DecimalAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): DecimalAttributeType {
			return internal.instancehelpers.createElement(container, DecimalAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DecimalAttributeType {
			return internal.instancehelpers.createElement(model, DecimalAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/domain-model relevant section in reference guide}
	 */
	export interface IDomainModel extends projects.IModuleDocument {
		model: IModel;
		containerAsModule: projects.IModule;
		entities: internal.IList<IEntity>;
		associations: internal.IList<IAssociation>;
		crossAssociations: internal.IList<ICrossAssociation>;
		load(): DomainModel;
		load(callback: (element: DomainModel) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/domain-model relevant section in reference guide}
	 */
	export class DomainModel extends projects.ModuleDocument implements IDomainModel {
		public static typeName: string = "DomainModels$DomainModel";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"entities" : {
					"public" : {
						"currentValue" : true
					}
				},
				"associations" : {
					"public" : {
						"currentValue" : true
					}
				},
				"crossAssociations" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsModule() { return super.getContainerAs<projects.Module>(projects.Module); }

		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DomainModel, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __entities: internal.PartListProperty<Entity> =
			new internal.PartListProperty<Entity>(DomainModel, this, "entities", []);
		public get entities(): internal.IList<Entity> { return this.__entities.get(); }
		public set entities(newValue: internal.IList<Entity>) { this.__entities.set(newValue); }
		private __annotations: internal.PartListProperty<Annotation> =
			new internal.PartListProperty<Annotation>(DomainModel, this, "annotations", []);
		public get annotations(): internal.IList<Annotation> { return this.__annotations.get(); }
		public set annotations(newValue: internal.IList<Annotation>) { this.__annotations.set(newValue); }
		private __associations: internal.PartListProperty<Association> =
			new internal.PartListProperty<Association>(DomainModel, this, "associations", []);
		public get associations(): internal.IList<Association> { return this.__associations.get(); }
		public set associations(newValue: internal.IList<Association>) { this.__associations.set(newValue); }
		private __crossAssociations: internal.PartListProperty<CrossAssociation> =
			new internal.PartListProperty<CrossAssociation>(DomainModel, this, "crossAssociations", []);
		public get crossAssociations(): internal.IList<CrossAssociation> { return this.__crossAssociations.get(); }
		public set crossAssociations(newValue: internal.IList<CrossAssociation>) { this.__crossAssociations.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IModule) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "domainModel";
		}

		/**
		 * Creates a new DomainModel unit in the SDK and on the server.
		 * Expects one argument, the projects.IModule in which this unit is contained.
		 */
		public static createIn(container: projects.IModule): DomainModel {
			return internal.instancehelpers.createUnit(container, DomainModel);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/entities relevant section in reference guide}
	 */
	export interface IEntity extends internal.IElement {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		name: string;
		/**
		 * This property is required and cannot be set to null.
		 */
		generalization: IGeneralizationBase;
		attributes: internal.IList<IAttribute>;
		load(): Entity;
		load(callback: (element: Entity) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/entities relevant section in reference guide}
	 */
	export class Entity extends internal.Element implements IEntity {
		public static typeName: string = "DomainModels$Entity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"generalization" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				},
				"attributes" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Entity, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __dataStorageGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Entity, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
		public get dataStorageGuid(): string { return this.__dataStorageGuid.get(); }
		public set dataStorageGuid(newValue: string) { this.__dataStorageGuid.set(newValue); }
		private __location: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(Entity, this, "location", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get location(): common.IPoint { return this.__location.get(); }
		public set location(newValue: common.IPoint) { this.__location.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Entity, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __generalization: internal.PartProperty<GeneralizationBase> =
			new internal.PartProperty<GeneralizationBase>(Entity, this, "generalization", null, true);
		public get generalization(): GeneralizationBase { return this.__generalization.get(); }
		public set generalization(newValue: GeneralizationBase) { this.__generalization.set(newValue); }
		private __attributes: internal.PartListProperty<Attribute> =
			new internal.PartListProperty<Attribute>(Entity, this, "attributes", []);
		public get attributes(): internal.IList<Attribute> { return this.__attributes.get(); }
		public set attributes(newValue: internal.IList<Attribute>) { this.__attributes.set(newValue); }
		private __validationRules: internal.PartListProperty<ValidationRule> =
			new internal.PartListProperty<ValidationRule>(Entity, this, "validationRules", []);
		public get validationRules(): internal.IList<ValidationRule> { return this.__validationRules.get(); }
		public set validationRules(newValue: internal.IList<ValidationRule>) { this.__validationRules.set(newValue); }
		private __eventHandlers: internal.PartListProperty<EventHandler> =
			new internal.PartListProperty<EventHandler>(Entity, this, "eventHandlers", []);
		public get eventHandlers(): internal.IList<EventHandler> { return this.__eventHandlers.get(); }
		public set eventHandlers(newValue: internal.IList<EventHandler>) { this.__eventHandlers.set(newValue); }
		private __indexes: internal.PartListProperty<Index> =
			new internal.PartListProperty<Index>(Entity, this, "indexes", []);
		public get indexes(): internal.IList<Index> { return this.__indexes.get(); }
		public set indexes(newValue: internal.IList<Index>) { this.__indexes.set(newValue); }
		private __accessRules: internal.PartListProperty<AccessRule> =
			new internal.PartListProperty<AccessRule>(Entity, this, "accessRules", []);
		public get accessRules(): internal.IList<AccessRule> { return this.__accessRules.get(); }
		public set accessRules(newValue: internal.IList<AccessRule>) { this.__accessRules.set(newValue); }
		private __image: internal.ByNameReferenceProperty<images.IImage> =
			new internal.ByNameReferenceProperty<images.IImage>(Entity, this, "image", null, "Images$Image");
		public get image(): images.IImage { return this.__image.get(); }
		public set image(newValue: images.IImage) { this.__image.set(newValue); }
		get imageQualifiedName(): string { return this.__image.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Entity() cannot be invoked directly, please use 'model.domainmodels.createEntity()'"
				);
			}
			this._declaredAsNamespace = true;
		}

		/**
		 * Creates and returns a new Entity instance in the SDK and on the server.
		 * The new Entity will be automatically stored in the 'entities' property
		 * of the parent DomainModel element passed as argument.
		 */
		public static createIn(container: DomainModel): Entity {
			return internal.instancehelpers.createElement(container, Entity, "entities", true);
		}

		/**
		 * Creates and returns a new Entity instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Entity {
			return internal.instancehelpers.createElement(model, Entity);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataStorageGuid = utils.randomUuid();
			this.generalization = NoGeneralization.create(this.model);
		}

	}

	export interface IEnumerationAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		/**
		 * This property is required and cannot be set to null.
		 */
		enumeration: enumerations.IEnumeration;
		enumerationQualifiedName: string;
		load(): EnumerationAttributeType;
		load(callback: (element: EnumerationAttributeType) => void, forceRefresh?: boolean);
	}

	export class EnumerationAttributeType extends AttributeType implements IEnumerationAttributeType {
		public static typeName: string = "DomainModels$EnumerationAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"enumeration" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }

		private __enumeration: internal.ByNameReferenceProperty<enumerations.IEnumeration> =
			new internal.ByNameReferenceProperty<enumerations.IEnumeration>(EnumerationAttributeType, this, "enumeration", null, "Enumerations$Enumeration");
		public get enumeration(): enumerations.IEnumeration { return this.__enumeration.get(); }
		public set enumeration(newValue: enumerations.IEnumeration) { this.__enumeration.set(newValue); }
		get enumerationQualifiedName(): string { return this.__enumeration.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EnumerationAttributeType() cannot be invoked directly, please use 'model.domainmodels.createEnumerationAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
		 * The new EnumerationAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): EnumerationAttributeType {
			return internal.instancehelpers.createElement(container, EnumerationAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EnumerationAttributeType {
			return internal.instancehelpers.createElement(model, EnumerationAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IRuleInfo extends internal.IElement {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): RuleInfo;
		load(callback: (element: RuleInfo) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class RuleInfo extends internal.Element implements IRuleInfo {
		public static typeName: string = "DomainModels$RuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRuleInfo()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IEqualsToRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): EqualsToRuleInfo;
		load(callback: (element: EqualsToRuleInfo) => void, forceRefresh?: boolean);
	}

	export class EqualsToRuleInfo extends RuleInfo implements IEqualsToRuleInfo {
		public static typeName: string = "DomainModels$EqualsToRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }

		private __useValue: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(EqualsToRuleInfo, this, "useValue", false, internal.PrimitiveTypeEnum.Boolean);
		public get useValue(): boolean { return this.__useValue.get(); }
		public set useValue(newValue: boolean) { this.__useValue.set(newValue); }
		private __equalsToValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(EqualsToRuleInfo, this, "equalsToValue", "", internal.PrimitiveTypeEnum.String);
		public get equalsToValue(): string { return this.__equalsToValue.get(); }
		public set equalsToValue(newValue: string) { this.__equalsToValue.set(newValue); }
		private __equalsToAttribute: internal.ByNameReferenceProperty<IAttribute> =
			new internal.ByNameReferenceProperty<IAttribute>(EqualsToRuleInfo, this, "equalsToAttribute", null, "DomainModels$Attribute");
		public get equalsToAttribute(): IAttribute { return this.__equalsToAttribute.get(); }
		public set equalsToAttribute(newValue: IAttribute) { this.__equalsToAttribute.set(newValue); }
		get equalsToAttributeQualifiedName(): string { return this.__equalsToAttribute.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EqualsToRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createEqualsToRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
		 * The new EqualsToRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): EqualsToRuleInfo {
			return internal.instancehelpers.createElement(container, EqualsToRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EqualsToRuleInfo {
			return internal.instancehelpers.createElement(model, EqualsToRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.useValue = true;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/event-handlers relevant section in reference guide}
	 */
	export interface IEventHandler extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): EventHandler;
		load(callback: (element: EventHandler) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/event-handlers relevant section in reference guide}
	 */
	export class EventHandler extends internal.Element implements IEventHandler {
		public static typeName: string = "DomainModels$EventHandler";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __moment: internal.EnumProperty<ActionMoment> =
			new internal.EnumProperty<ActionMoment>(EventHandler, this, "moment", ActionMoment.After, ActionMoment);
		public get moment(): ActionMoment { return this.__moment.get(); }
		public set moment(newValue: ActionMoment) { this.__moment.set(newValue); }
		private __event: internal.EnumProperty<EventType> =
			new internal.EnumProperty<EventType>(EventHandler, this, "event", EventType.Commit, EventType);
		public get event(): EventType { return this.__event.get(); }
		public set event(newValue: EventType) { this.__event.set(newValue); }
		private __microflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(EventHandler, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): microflows.IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: microflows.IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }
		private __raiseErrorOnFalse: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(EventHandler, this, "raiseErrorOnFalse", false, internal.PrimitiveTypeEnum.Boolean);
		public get raiseErrorOnFalse(): boolean { return this.__raiseErrorOnFalse.get(); }
		public set raiseErrorOnFalse(newValue: boolean) { this.__raiseErrorOnFalse.set(newValue); }
		private __passEventObject: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(EventHandler, this, "passEventObject", false, internal.PrimitiveTypeEnum.Boolean);
		public get passEventObject(): boolean { return this.__passEventObject.get(); }
		public set passEventObject(newValue: boolean) { this.__passEventObject.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new EventHandler() cannot be invoked directly, please use 'model.domainmodels.createEventHandler()'"
				);
			}
		}

		/**
		 * Creates and returns a new EventHandler instance in the SDK and on the server.
		 * The new EventHandler will be automatically stored in the 'eventHandlers' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): EventHandler {
			return internal.instancehelpers.createElement(container, EventHandler, "eventHandlers", true);
		}

		/**
		 * Creates and returns a new EventHandler instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): EventHandler {
			return internal.instancehelpers.createElement(model, EventHandler);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.event = EventType.Commit;
			this.moment = ActionMoment.After;
			this.passEventObject = true;
			this.raiseErrorOnFalse = true;
		}

	}

	/**
	 * In version 6.0.0: deprecated
	 */
	export interface IFloatAttributeType extends IFloatAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): FloatAttributeType;
		load(callback: (element: FloatAttributeType) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.0: deprecated
	 */
	export class FloatAttributeType extends FloatAttributeTypeBase implements IFloatAttributeType {
		public static typeName: string = "DomainModels$FloatAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"deprecated" : "6.0.0",
			"deprecationMessage" : "FloatAttributeType has been deprecated. Please use DecimalAttributeType instead.",
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new FloatAttributeType() cannot be invoked directly, please use 'model.domainmodels.createFloatAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
		 * The new FloatAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): FloatAttributeType {
			return internal.instancehelpers.createElement(container, FloatAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): FloatAttributeType {
			return internal.instancehelpers.createElement(model, FloatAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IGeneralizationBase extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): GeneralizationBase;
		load(callback: (element: GeneralizationBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class GeneralizationBase extends internal.Element implements IGeneralizationBase {
		public static typeName: string = "DomainModels$GeneralizationBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new GeneralizationBase() cannot be invoked directly, please use 'model.domainmodels.createGeneralizationBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IGeneralization extends IGeneralizationBase {
		model: IModel;
		containerAsEntity: IEntity;
		/**
		 * This property is required and cannot be set to null.
		 */
		generalization: IEntity;
		generalizationQualifiedName: string;
		load(): Generalization;
		load(callback: (element: Generalization) => void, forceRefresh?: boolean);
	}

	export class Generalization extends GeneralizationBase implements IGeneralization {
		public static typeName: string = "DomainModels$Generalization";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"generalization" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __generalization: internal.ByNameReferenceProperty<IEntity> =
			new internal.ByNameReferenceProperty<IEntity>(Generalization, this, "generalization", null, "DomainModels$Entity");
		public get generalization(): IEntity { return this.__generalization.get(); }
		public set generalization(newValue: IEntity) { this.__generalization.set(newValue); }
		get generalizationQualifiedName(): string { return this.__generalization.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Generalization() cannot be invoked directly, please use 'model.domainmodels.createGeneralization()'"
				);
			}
		}

		/**
		 * Creates and returns a new Generalization instance in the SDK and on the server.
		 * The new Generalization will be automatically stored in the 'generalization' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): Generalization {
			return internal.instancehelpers.createElement(container, Generalization, "generalization", false);
		}

		/**
		 * Creates and returns a new Generalization instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Generalization {
			return internal.instancehelpers.createElement(model, Generalization);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IHashedStringAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): HashedStringAttributeType;
		load(callback: (element: HashedStringAttributeType) => void, forceRefresh?: boolean);
	}

	export class HashedStringAttributeType extends AttributeType implements IHashedStringAttributeType {
		public static typeName: string = "DomainModels$HashedStringAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new HashedStringAttributeType() cannot be invoked directly, please use 'model.domainmodels.createHashedStringAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
		 * The new HashedStringAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): HashedStringAttributeType {
			return internal.instancehelpers.createElement(container, HashedStringAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): HashedStringAttributeType {
			return internal.instancehelpers.createElement(model, HashedStringAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/indexes relevant section in reference guide}
	 */
	export interface IIndex extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): Index;
		load(callback: (element: Index) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/indexes relevant section in reference guide}
	 */
	export class Index extends internal.Element implements IIndex {
		public static typeName: string = "DomainModels$Index";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __dataStorageGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Index, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
		public get dataStorageGuid(): string { return this.__dataStorageGuid.get(); }
		public set dataStorageGuid(newValue: string) { this.__dataStorageGuid.set(newValue); }
		private __attributes: internal.PartListProperty<IndexedAttribute> =
			new internal.PartListProperty<IndexedAttribute>(Index, this, "attributes", []);
		public get attributes(): internal.IList<IndexedAttribute> { return this.__attributes.get(); }
		public set attributes(newValue: internal.IList<IndexedAttribute>) { this.__attributes.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Index() cannot be invoked directly, please use 'model.domainmodels.createIndex()'"
				);
			}
		}

		/**
		 * Creates and returns a new Index instance in the SDK and on the server.
		 * The new Index will be automatically stored in the 'indexes' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): Index {
			return internal.instancehelpers.createElement(container, Index, "indexes", true);
		}

		/**
		 * Creates and returns a new Index instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Index {
			return internal.instancehelpers.createElement(model, Index);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataStorageGuid = utils.randomUuid();
		}

	}

	export interface IIndexedAttribute extends internal.IElement {
		model: IModel;
		containerAsIndex: IIndex;
		load(): IndexedAttribute;
		load(callback: (element: IndexedAttribute) => void, forceRefresh?: boolean);
	}

	export class IndexedAttribute extends internal.Element implements IIndexedAttribute {
		public static typeName: string = "DomainModels$IndexedAttribute";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsIndex() { return super.getContainerAs<Index>(Index); }

		private __type: internal.EnumProperty<IndexedAttributeType> =
			new internal.EnumProperty<IndexedAttributeType>(IndexedAttribute, this, "type", IndexedAttributeType.Normal, IndexedAttributeType);
		public get type(): IndexedAttributeType { return this.__type.get(); }
		public set type(newValue: IndexedAttributeType) { this.__type.set(newValue); }
		private __attribute: internal.ByIdReferenceProperty<Attribute> =
			new internal.ByIdReferenceProperty<Attribute>(IndexedAttribute, this, "attribute", null);
		public get attribute(): Attribute { return this.__attribute.get(); }
		public set attribute(newValue: Attribute) { this.__attribute.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new IndexedAttribute() cannot be invoked directly, please use 'model.domainmodels.createIndexedAttribute()'"
				);
			}
		}

		/**
		 * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
		 * The new IndexedAttribute will be automatically stored in the 'attributes' property
		 * of the parent Index element passed as argument.
		 */
		public static createIn(container: Index): IndexedAttribute {
			return internal.instancehelpers.createElement(container, IndexedAttribute, "attributes", true);
		}

		/**
		 * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): IndexedAttribute {
			return internal.instancehelpers.createElement(model, IndexedAttribute);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.type = IndexedAttributeType.Normal;
		}

	}

	export interface IIntegerAttributeType extends IIntegerAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): IntegerAttributeType;
		load(callback: (element: IntegerAttributeType) => void, forceRefresh?: boolean);
	}

	export class IntegerAttributeType extends IntegerAttributeTypeBase implements IIntegerAttributeType {
		public static typeName: string = "DomainModels$IntegerAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new IntegerAttributeType() cannot be invoked directly, please use 'model.domainmodels.createIntegerAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
		 * The new IntegerAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): IntegerAttributeType {
			return internal.instancehelpers.createElement(container, IntegerAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): IntegerAttributeType {
			return internal.instancehelpers.createElement(model, IntegerAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ILongAttributeType extends IIntegerAttributeTypeBase {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): LongAttributeType;
		load(callback: (element: LongAttributeType) => void, forceRefresh?: boolean);
	}

	export class LongAttributeType extends IntegerAttributeTypeBase implements ILongAttributeType {
		public static typeName: string = "DomainModels$LongAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new LongAttributeType() cannot be invoked directly, please use 'model.domainmodels.createLongAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new LongAttributeType instance in the SDK and on the server.
		 * The new LongAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): LongAttributeType {
			return internal.instancehelpers.createElement(container, LongAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new LongAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): LongAttributeType {
			return internal.instancehelpers.createElement(model, LongAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMaxLengthRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): MaxLengthRuleInfo;
		load(callback: (element: MaxLengthRuleInfo) => void, forceRefresh?: boolean);
	}

	export class MaxLengthRuleInfo extends RuleInfo implements IMaxLengthRuleInfo {
		public static typeName: string = "DomainModels$MaxLengthRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }

		private __maxLength: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(MaxLengthRuleInfo, this, "maxLength", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxLength(): number { return this.__maxLength.get(); }
		public set maxLength(newValue: number) { this.__maxLength.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MaxLengthRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createMaxLengthRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
		 * The new MaxLengthRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): MaxLengthRuleInfo {
			return internal.instancehelpers.createElement(container, MaxLengthRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MaxLengthRuleInfo {
			return internal.instancehelpers.createElement(model, MaxLengthRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMemberAccess extends internal.IElement {
		model: IModel;
		containerAsAccessRule: IAccessRule;
		load(): MemberAccess;
		load(callback: (element: MemberAccess) => void, forceRefresh?: boolean);
	}

	export class MemberAccess extends internal.Element implements IMemberAccess {
		public static typeName: string = "DomainModels$MemberAccess";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsAccessRule() { return super.getContainerAs<AccessRule>(AccessRule); }

		private __attribute: internal.ByNameReferenceProperty<IAttribute> =
			new internal.ByNameReferenceProperty<IAttribute>(MemberAccess, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __association: internal.ByNameReferenceProperty<IAssociationBase> =
			new internal.ByNameReferenceProperty<IAssociationBase>(MemberAccess, this, "association", null, "DomainModels$AssociationBase");
		public get association(): IAssociationBase { return this.__association.get(); }
		public set association(newValue: IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }
		private __accessRights: internal.EnumProperty<MemberAccessRights> =
			new internal.EnumProperty<MemberAccessRights>(MemberAccess, this, "accessRights", MemberAccessRights.None, MemberAccessRights);
		public get accessRights(): MemberAccessRights { return this.__accessRights.get(); }
		public set accessRights(newValue: MemberAccessRights) { this.__accessRights.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MemberAccess() cannot be invoked directly, please use 'model.domainmodels.createMemberAccess()'"
				);
			}
		}

		/**
		 * Creates and returns a new MemberAccess instance in the SDK and on the server.
		 * The new MemberAccess will be automatically stored in the 'memberAccesses' property
		 * of the parent AccessRule element passed as argument.
		 */
		public static createIn(container: AccessRule): MemberAccess {
			return internal.instancehelpers.createElement(container, MemberAccess, "memberAccesses", true);
		}

		/**
		 * Creates and returns a new MemberAccess instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MemberAccess {
			return internal.instancehelpers.createElement(model, MemberAccess);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.accessRights = MemberAccessRights.None;
		}

	}

	export interface INoGeneralization extends IGeneralizationBase {
		model: IModel;
		containerAsEntity: IEntity;
		persistable: boolean;
		load(): NoGeneralization;
		load(callback: (element: NoGeneralization) => void, forceRefresh?: boolean);
	}

	export class NoGeneralization extends GeneralizationBase implements INoGeneralization {
		public static typeName: string = "DomainModels$NoGeneralization";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"persistable" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __hasChangedDate: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(NoGeneralization, this, "hasChangedDate", false, internal.PrimitiveTypeEnum.Boolean);
		public get hasChangedDate(): boolean { return this.__hasChangedDate.get(); }
		public set hasChangedDate(newValue: boolean) { this.__hasChangedDate.set(newValue); }
		private __hasCreatedDate: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(NoGeneralization, this, "hasCreatedDate", false, internal.PrimitiveTypeEnum.Boolean);
		public get hasCreatedDate(): boolean { return this.__hasCreatedDate.get(); }
		public set hasCreatedDate(newValue: boolean) { this.__hasCreatedDate.set(newValue); }
		private __hasOwner: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(NoGeneralization, this, "hasOwner", false, internal.PrimitiveTypeEnum.Boolean);
		public get hasOwner(): boolean { return this.__hasOwner.get(); }
		public set hasOwner(newValue: boolean) { this.__hasOwner.set(newValue); }
		private __hasChangedBy: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(NoGeneralization, this, "hasChangedBy", false, internal.PrimitiveTypeEnum.Boolean);
		public get hasChangedBy(): boolean { return this.__hasChangedBy.get(); }
		public set hasChangedBy(newValue: boolean) { this.__hasChangedBy.set(newValue); }
		private __persistable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(NoGeneralization, this, "persistable", false, internal.PrimitiveTypeEnum.Boolean);
		public get persistable(): boolean { return this.__persistable.get(); }
		public set persistable(newValue: boolean) { this.__persistable.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new NoGeneralization() cannot be invoked directly, please use 'model.domainmodels.createNoGeneralization()'"
				);
			}
		}

		/**
		 * Creates and returns a new NoGeneralization instance in the SDK and on the server.
		 * The new NoGeneralization will be automatically stored in the 'generalization' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): NoGeneralization {
			return internal.instancehelpers.createElement(container, NoGeneralization, "generalization", false);
		}

		/**
		 * Creates and returns a new NoGeneralization instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): NoGeneralization {
			return internal.instancehelpers.createElement(model, NoGeneralization);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.persistable = true;
		}

	}

	export interface IRangeRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): RangeRuleInfo;
		load(callback: (element: RangeRuleInfo) => void, forceRefresh?: boolean);
	}

	export class RangeRuleInfo extends RuleInfo implements IRangeRuleInfo {
		public static typeName: string = "DomainModels$RangeRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }

		private __typeOfRange: internal.EnumProperty<RangeType> =
			new internal.EnumProperty<RangeType>(RangeRuleInfo, this, "typeOfRange", RangeType.Between, RangeType);
		public get typeOfRange(): RangeType { return this.__typeOfRange.get(); }
		public set typeOfRange(newValue: RangeType) { this.__typeOfRange.set(newValue); }
		private __useMinValue: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(RangeRuleInfo, this, "useMinValue", false, internal.PrimitiveTypeEnum.Boolean);
		public get useMinValue(): boolean { return this.__useMinValue.get(); }
		public set useMinValue(newValue: boolean) { this.__useMinValue.set(newValue); }
		private __useMaxValue: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(RangeRuleInfo, this, "useMaxValue", false, internal.PrimitiveTypeEnum.Boolean);
		public get useMaxValue(): boolean { return this.__useMaxValue.get(); }
		public set useMaxValue(newValue: boolean) { this.__useMaxValue.set(newValue); }
		private __minValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RangeRuleInfo, this, "minValue", "", internal.PrimitiveTypeEnum.String);
		public get minValue(): string { return this.__minValue.get(); }
		public set minValue(newValue: string) { this.__minValue.set(newValue); }
		private __maxValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(RangeRuleInfo, this, "maxValue", "", internal.PrimitiveTypeEnum.String);
		public get maxValue(): string { return this.__maxValue.get(); }
		public set maxValue(newValue: string) { this.__maxValue.set(newValue); }
		private __minAttribute: internal.ByNameReferenceProperty<IAttribute> =
			new internal.ByNameReferenceProperty<IAttribute>(RangeRuleInfo, this, "minAttribute", null, "DomainModels$Attribute");
		public get minAttribute(): IAttribute { return this.__minAttribute.get(); }
		public set minAttribute(newValue: IAttribute) { this.__minAttribute.set(newValue); }
		get minAttributeQualifiedName(): string { return this.__minAttribute.qualifiedName(); }
		private __maxAttribute: internal.ByNameReferenceProperty<IAttribute> =
			new internal.ByNameReferenceProperty<IAttribute>(RangeRuleInfo, this, "maxAttribute", null, "DomainModels$Attribute");
		public get maxAttribute(): IAttribute { return this.__maxAttribute.get(); }
		public set maxAttribute(newValue: IAttribute) { this.__maxAttribute.set(newValue); }
		get maxAttributeQualifiedName(): string { return this.__maxAttribute.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RangeRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRangeRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
		 * The new RangeRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): RangeRuleInfo {
			return internal.instancehelpers.createElement(container, RangeRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RangeRuleInfo {
			return internal.instancehelpers.createElement(model, RangeRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.typeOfRange = RangeType.Between;
			this.useMaxValue = true;
			this.useMinValue = true;
		}

	}

	export interface IRegExRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): RegExRuleInfo;
		load(callback: (element: RegExRuleInfo) => void, forceRefresh?: boolean);
	}

	export class RegExRuleInfo extends RuleInfo implements IRegExRuleInfo {
		public static typeName: string = "DomainModels$RegExRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }

		private __regularExpression: internal.ByNameReferenceProperty<regularexpressions.IRegularExpression> =
			new internal.ByNameReferenceProperty<regularexpressions.IRegularExpression>(RegExRuleInfo, this, "regularExpression", null, "RegularExpressions$RegularExpression");
		public get regularExpression(): regularexpressions.IRegularExpression { return this.__regularExpression.get(); }
		public set regularExpression(newValue: regularexpressions.IRegularExpression) { this.__regularExpression.set(newValue); }
		get regularExpressionQualifiedName(): string { return this.__regularExpression.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RegExRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRegExRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
		 * The new RegExRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): RegExRuleInfo {
			return internal.instancehelpers.createElement(container, RegExRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RegExRuleInfo {
			return internal.instancehelpers.createElement(model, RegExRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IRequiredRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): RequiredRuleInfo;
		load(callback: (element: RequiredRuleInfo) => void, forceRefresh?: boolean);
	}

	export class RequiredRuleInfo extends RuleInfo implements IRequiredRuleInfo {
		public static typeName: string = "DomainModels$RequiredRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new RequiredRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRequiredRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
		 * The new RequiredRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): RequiredRuleInfo {
			return internal.instancehelpers.createElement(container, RequiredRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): RequiredRuleInfo {
			return internal.instancehelpers.createElement(model, RequiredRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.6.0: added public
	 */
	export interface IStoredValue extends IValueType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): StoredValue;
		load(callback: (element: StoredValue) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.6.0: added public
	 */
	export class StoredValue extends ValueType implements IStoredValue {
		public static typeName: string = "DomainModels$StoredValue";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true,
				"changedIn" : [
					"6.6.0"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }

		private __defaultValue: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(StoredValue, this, "defaultValue", "", internal.PrimitiveTypeEnum.String);
		public get defaultValue(): string { return this.__defaultValue.get(); }
		public set defaultValue(newValue: string) { this.__defaultValue.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new StoredValue() cannot be invoked directly, please use 'model.domainmodels.createStoredValue()'"
				);
			}
		}

		/**
		 * Creates and returns a new StoredValue instance in the SDK and on the server.
		 * The new StoredValue will be automatically stored in the 'value' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): StoredValue {
			return internal.instancehelpers.createElement(container, StoredValue, "value", false);
		}

		/**
		 * Creates and returns a new StoredValue instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): StoredValue {
			return internal.instancehelpers.createElement(model, StoredValue);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IStringAttributeType extends IAttributeType {
		model: IModel;
		containerAsAttribute: IAttribute;
		load(): StringAttributeType;
		load(callback: (element: StringAttributeType) => void, forceRefresh?: boolean);
	}

	export class StringAttributeType extends AttributeType implements IStringAttributeType {
		public static typeName: string = "DomainModels$StringAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsAttribute() { return super.getContainerAs<Attribute>(Attribute); }

		private __length: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(StringAttributeType, this, "length", 0, internal.PrimitiveTypeEnum.Integer);
		public get length(): number { return this.__length.get(); }
		public set length(newValue: number) { this.__length.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new StringAttributeType() cannot be invoked directly, please use 'model.domainmodels.createStringAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new StringAttributeType instance in the SDK and on the server.
		 * The new StringAttributeType will be automatically stored in the 'type' property
		 * of the parent Attribute element passed as argument.
		 */
		public static createIn(container: Attribute): StringAttributeType {
			return internal.instancehelpers.createElement(container, StringAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new StringAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): StringAttributeType {
			return internal.instancehelpers.createElement(model, StringAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.length = 200;
		}

	}

	export interface IUniqueRuleInfo extends IRuleInfo {
		model: IModel;
		containerAsValidationRule: IValidationRule;
		load(): UniqueRuleInfo;
		load(callback: (element: UniqueRuleInfo) => void, forceRefresh?: boolean);
	}

	export class UniqueRuleInfo extends RuleInfo implements IUniqueRuleInfo {
		public static typeName: string = "DomainModels$UniqueRuleInfo";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsValidationRule() { return super.getContainerAs<ValidationRule>(ValidationRule); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new UniqueRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createUniqueRuleInfo()'"
				);
			}
		}

		/**
		 * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
		 * The new UniqueRuleInfo will be automatically stored in the 'ruleInfo' property
		 * of the parent ValidationRule element passed as argument.
		 */
		public static createIn(container: ValidationRule): UniqueRuleInfo {
			return internal.instancehelpers.createElement(container, UniqueRuleInfo, "ruleInfo", false);
		}

		/**
		 * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): UniqueRuleInfo {
			return internal.instancehelpers.createElement(model, UniqueRuleInfo);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/validation-rules relevant section in reference guide}
	 */
	export interface IValidationRule extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): ValidationRule;
		load(callback: (element: ValidationRule) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/validation-rules relevant section in reference guide}
	 */
	export class ValidationRule extends internal.Element implements IValidationRule {
		public static typeName: string = "DomainModels$ValidationRule";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"attribute" : {
					"required" : {
						"currentValue" : true
					}
				},
				"errorMessage" : {
					"required" : {
						"currentValue" : true
					}
				},
				"ruleInfo" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __attribute: internal.ByNameReferenceProperty<IAttribute> =
			new internal.ByNameReferenceProperty<IAttribute>(ValidationRule, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __errorMessage: internal.PartProperty<texts.Text> =
			new internal.PartProperty<texts.Text>(ValidationRule, this, "errorMessage", null, true);
		public get errorMessage(): texts.Text { return this.__errorMessage.get(); }
		public set errorMessage(newValue: texts.Text) { this.__errorMessage.set(newValue); }
		private __ruleInfo: internal.PartProperty<RuleInfo> =
			new internal.PartProperty<RuleInfo>(ValidationRule, this, "ruleInfo", null, true);
		public get ruleInfo(): RuleInfo { return this.__ruleInfo.get(); }
		public set ruleInfo(newValue: RuleInfo) { this.__ruleInfo.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ValidationRule() cannot be invoked directly, please use 'model.domainmodels.createValidationRule()'"
				);
			}
		}

		/**
		 * Creates and returns a new ValidationRule instance in the SDK and on the server.
		 * The new ValidationRule will be automatically stored in the 'validationRules' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): ValidationRule {
			return internal.instancehelpers.createElement(container, ValidationRule, "validationRules", true);
		}

		/**
		 * Creates and returns a new ValidationRule instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ValidationRule {
			return internal.instancehelpers.createElement(model, ValidationRule);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.errorMessage = texts.Text.create(this.model);
			this.ruleInfo = RequiredRuleInfo.create(this.model);
		}

	}
}

import {enumerations} from "./enumerations";
import {images} from "./images";
import {microflows} from "./microflows";
import {regularexpressions} from "./regularexpressions";
import {security} from "./security";
import {texts} from "./texts";

import {IModel} from "./base-model";
