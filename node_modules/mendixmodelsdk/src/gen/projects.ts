/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;


export namespace projects {


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Projects`.
	 */


	export interface IModuleDocument extends internal.IModelUnit {
		model: IModel;
		containerAsFolderBase: IFolderBase;
		containerAsModule: IModule;
		load(): ModuleDocument;
		load(callback: (element: ModuleDocument) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ModuleDocument extends internal.ModelUnit implements IModuleDocument {
		public static typeName: string = "Projects$ModuleDocument";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<FolderBase>(FolderBase); }
		get containerAsModule() { return super.getContainerAs<Module>(Module); }


		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IFolderBase|IModule) {
			super(model, typeName, id, isPartial, container);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDocument extends IModuleDocument {
		model: IModel;
		containerAsFolderBase: IFolderBase;
		name: string;
		load(): Document;
		load(callback: (element: Document) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Document extends ModuleDocument implements IDocument {
		public static typeName: string = "Projects$Document";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<FolderBase>(FolderBase); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Document, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Document, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __excluded: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Document, this, "excluded", false, internal.PrimitiveTypeEnum.Boolean);
		public get excluded(): boolean { return this.__excluded.get(); }
		public set excluded(newValue: boolean) { this.__excluded.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._declaredAsNamespace = true;
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFolderBase extends internal.IStructuralUnit {
		model: IModel;
		containerAsFolderBase: IFolderBase;
		containerAsProject: IProject;
		folders: internal.IList<IFolder>;
		documents: internal.IList<IDocument>;
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class FolderBase extends internal.StructuralUnit implements IFolderBase {
		public static typeName: string = "Projects$FolderBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.StructuralUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<FolderBase>(FolderBase); }
		get containerAsProject() { return super.getContainerAs<Project>(Project); }

		private __folders: internal.StructuralChildListProperty<IFolder> =
			new internal.StructuralChildListProperty<IFolder>(FolderBase, this, "folders", []);
		public get folders(): internal.IList<IFolder> { return this.__folders.get(); }
		public set folders(newValue: internal.IList<IFolder>) { this.__folders.set(newValue); }
		private __documents: internal.StructuralChildListProperty<IDocument> =
			new internal.StructuralChildListProperty<IDocument>(FolderBase, this, "documents", []);
		public get documents(): internal.IList<IDocument> { return this.__documents.get(); }
		public set documents(newValue: internal.IList<IDocument>) { this.__documents.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IFolderBase|IProject) {
			super(model, typeName, id, isPartial, container);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://world.mendix.com/display/howto50/Add+documents+to+a+module relevant section in reference guide}
	 */
	export interface IFolder extends IFolderBase {
		model: IModel;
		containerAsFolderBase: IFolderBase;
		name: string;
	}

	/**
	 * See: {@link https://world.mendix.com/display/howto50/Add+documents+to+a+module relevant section in reference guide}
	 */
	export class Folder extends FolderBase implements IFolder {
		public static typeName: string = "Projects$Folder";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.StructuralUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<FolderBase>(FolderBase); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Folder, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "folders";
		}

		/**
		 * Creates a new Folder unit in the SDK and on the server.
		 * Expects one argument, the IFolderBase in which this unit is contained.
		 */
		public static createIn(container: IFolderBase): Folder {
			return internal.instancehelpers.createUnit(container, Folder);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/modules relevant section in reference guide}
	 */
	export interface IModule extends IFolderBase {
		model: IModel;
		containerAsProject: IProject;
		/**
		 * The index of where this Module appears in the project.
		 * This property is <em>required</em>, and of type double.
		 * Also, its value needs to be unique among its siblings (meaning, in code: <tt>containerAsProject.modules</tt>) in the project.
		 * In other words: <tt>containerAsProject.modules.map(m => m.sortedIndex)</tt> (TS syntax) needs to be a list with unique values.
		 */
		sortIndex: number;
		name: string;
		/**
		 * This property is required and cannot be set to null.
		 */
		domainModel: domainmodels.IDomainModel;
		/**
		 * This property is required and cannot be set to null.
		 */
		moduleSecurity: security.IModuleSecurity;
		fromAppStore: boolean;
		appStoreGuid: string;
		appStoreVersionGuid: string;
		appStoreVersion: string;
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/modules relevant section in reference guide}
	 */
	export class Module extends FolderBase implements IModule {
		public static typeName: string = "Projects$Module";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"domainModel" : {
					"required" : {
						"currentValue" : true
					}
				},
				"moduleSecurity" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.StructuralUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<Project>(Project); }

		private __sortIndex: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Module, this, "sortIndex", 0, internal.PrimitiveTypeEnum.Double);
		/**
		 * The index of where this Module appears in the project.
		 * This property is <em>required</em>, and of type double.
		 * Also, its value needs to be unique among its siblings (meaning, in code: <tt>containerAsProject.modules</tt>) in the project.
		 * In other words: <tt>containerAsProject.modules.map(m => m.sortedIndex)</tt> (TS syntax) needs to be a list with unique values.
		 */
		public get sortIndex(): number { return this.__sortIndex.get(); }
		public set sortIndex(newValue: number) { this.__sortIndex.set(newValue); }
		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Module, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __domainModel: internal.StructuralChildProperty<domainmodels.IDomainModel> =
			new internal.StructuralChildProperty<domainmodels.IDomainModel>(Module, this, "domainModel", null);
		public get domainModel(): domainmodels.IDomainModel { return this.__domainModel.get(); }
		public set domainModel(newValue: domainmodels.IDomainModel) { this.__domainModel.set(newValue); }
		private __moduleSecurity: internal.StructuralChildProperty<security.IModuleSecurity> =
			new internal.StructuralChildProperty<security.IModuleSecurity>(Module, this, "moduleSecurity", null);
		public get moduleSecurity(): security.IModuleSecurity { return this.__moduleSecurity.get(); }
		public set moduleSecurity(newValue: security.IModuleSecurity) { this.__moduleSecurity.set(newValue); }
		private __fromAppStore: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Module, this, "fromAppStore", false, internal.PrimitiveTypeEnum.Boolean);
		public get fromAppStore(): boolean { return this.__fromAppStore.get(); }
		public set fromAppStore(newValue: boolean) { this.__fromAppStore.set(newValue); }
		private __appStoreGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Module, this, "appStoreGuid", "", internal.PrimitiveTypeEnum.String);
		public get appStoreGuid(): string { return this.__appStoreGuid.get(); }
		public set appStoreGuid(newValue: string) { this.__appStoreGuid.set(newValue); }
		private __appStoreVersionGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Module, this, "appStoreVersionGuid", "", internal.PrimitiveTypeEnum.String);
		public get appStoreVersionGuid(): string { return this.__appStoreVersionGuid.get(); }
		public set appStoreVersionGuid(newValue: string) { this.__appStoreVersionGuid.set(newValue); }
		private __appStoreVersion: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Module, this, "appStoreVersion", "", internal.PrimitiveTypeEnum.String);
		public get appStoreVersion(): string { return this.__appStoreVersion.get(); }
		public set appStoreVersion(newValue: string) { this.__appStoreVersion.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IProject) {
			super(model, typeName, id, isPartial, container);
			this._declaredAsNamespace = true;
			this._containmentName = "modules";
		}

		/**
		 * Creates a new Module unit in the SDK and on the server.
		 * Expects one argument, the IProject in which this unit is contained.
		 */
		public static createIn(container: IProject): Module {
			return internal.instancehelpers.createUnit(container, Module);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IOneTimeConversionMarker extends internal.IElement {
		model: IModel;
		containerAsProjectConversion: IProjectConversion;
		load(): OneTimeConversionMarker;
		load(callback: (element: OneTimeConversionMarker) => void, forceRefresh?: boolean);
	}

	export class OneTimeConversionMarker extends internal.Element implements IOneTimeConversionMarker {
		public static typeName: string = "Projects$OneTimeConversionMarker";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsProjectConversion() { return super.getContainerAs<ProjectConversion>(ProjectConversion); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(OneTimeConversionMarker, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new OneTimeConversionMarker() cannot be invoked directly, please use 'model.projects.createOneTimeConversionMarker()'"
				);
			}
		}

		/**
		 * Creates and returns a new OneTimeConversionMarker instance in the SDK and on the server.
		 * The new OneTimeConversionMarker will be automatically stored in the 'markers' property
		 * of the parent ProjectConversion element passed as argument.
		 */
		public static createIn(container: ProjectConversion): OneTimeConversionMarker {
			return internal.instancehelpers.createElement(container, OneTimeConversionMarker, "markers", true);
		}

		/**
		 * Creates and returns a new OneTimeConversionMarker instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): OneTimeConversionMarker {
			return internal.instancehelpers.createElement(model, OneTimeConversionMarker);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project relevant section in reference guide}
	 */
	export interface IProject extends internal.IStructuralUnit {
		model: IModel;
		projectDocuments: internal.IList<IProjectDocument>;
		modules: internal.IList<IModule>;
		/**
		 * This property is required and cannot be set to null.
		 */
		projectConversion: IProjectConversion;
		isSystemProject: boolean;
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project relevant section in reference guide}
	 */
	export class Project extends internal.StructuralUnit implements IProject {
		public static typeName: string = "Projects$Project";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"projectConversion" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.StructuralUnit);
		model: IModel;


		private __projectDocuments: internal.StructuralChildListProperty<IProjectDocument> =
			new internal.StructuralChildListProperty<IProjectDocument>(Project, this, "projectDocuments", []);
		public get projectDocuments(): internal.IList<IProjectDocument> { return this.__projectDocuments.get(); }
		public set projectDocuments(newValue: internal.IList<IProjectDocument>) { this.__projectDocuments.set(newValue); }
		private __modules: internal.StructuralChildListProperty<IModule> =
			new internal.StructuralChildListProperty<IModule>(Project, this, "modules", []);
		public get modules(): internal.IList<IModule> { return this.__modules.get(); }
		public set modules(newValue: internal.IList<IModule>) { this.__modules.set(newValue); }
		private __projectConversion: internal.StructuralChildProperty<IProjectConversion> =
			new internal.StructuralChildProperty<IProjectConversion>(Project, this, "projectConversion", null);
		public get projectConversion(): IProjectConversion { return this.__projectConversion.get(); }
		public set projectConversion(newValue: IProjectConversion) { this.__projectConversion.set(newValue); }
		private __isSystemProject: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Project, this, "isSystemProject", false, internal.PrimitiveTypeEnum.Boolean);
		public get isSystemProject(): boolean { return this.__isSystemProject.get(); }
		public set isSystemProject(newValue: boolean) { this.__isSystemProject.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: internal.IStructuralUnit) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "";
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IProjectConversion extends internal.IModelUnit {
		model: IModel;
		containerAsProject: IProject;
		load(): ProjectConversion;
		load(callback: (element: ProjectConversion) => void, forceRefresh?: boolean);
	}

	export class ProjectConversion extends internal.ModelUnit implements IProjectConversion {
		public static typeName: string = "Projects$ProjectConversion";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<Project>(Project); }

		private __markers: internal.PartListProperty<OneTimeConversionMarker> =
			new internal.PartListProperty<OneTimeConversionMarker>(ProjectConversion, this, "markers", []);
		public get markers(): internal.IList<OneTimeConversionMarker> { return this.__markers.get(); }
		public set markers(newValue: internal.IList<OneTimeConversionMarker>) { this.__markers.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IProject) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "projectConversion";
		}

		/**
		 * Creates a new ProjectConversion unit in the SDK and on the server.
		 * Expects one argument, the IProject in which this unit is contained.
		 */
		public static createIn(container: IProject): ProjectConversion {
			return internal.instancehelpers.createUnit(container, ProjectConversion);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project relevant section in reference guide}
	 */
	export interface IProjectDocument extends internal.IModelUnit {
		model: IModel;
		containerAsProject: IProject;
		load(): ProjectDocument;
		load(callback: (element: ProjectDocument) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/project relevant section in reference guide}
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ProjectDocument extends internal.ModelUnit implements IProjectDocument {
		public static typeName: string = "Projects$ProjectDocument";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<Project>(Project); }


		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: IProject) {
			super(model, typeName, id, isPartial, container);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}
}

import {domainmodels} from "./domainmodels";
import {security} from "./security";

import {IModel} from "./base-model";
