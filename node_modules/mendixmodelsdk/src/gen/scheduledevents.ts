/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;

import {projects} from "./projects";

export namespace scheduledevents {

	export class IntervalType extends internal.IEnum {
		public static Second: IntervalType = new IntervalType("Second", { });
		public static Minute: IntervalType = new IntervalType("Minute", { });
		public static Hour: IntervalType = new IntervalType("Hour", { });
		public static Day: IntervalType = new IntervalType("Day", { });
		public static Week: IntervalType = new IntervalType("Week", { });
		public static Month: IntervalType = new IntervalType("Month", { });
		public static Year: IntervalType = new IntervalType("Year", { });
		protected qualifiedTsTypeName: string = "scheduledevents.IntervalType";
	}

	export class TimeZoneEnum extends internal.IEnum {
		public static UTC: TimeZoneEnum = new TimeZoneEnum("UTC", { });
		public static Server: TimeZoneEnum = new TimeZoneEnum("Server", { });
		protected qualifiedTsTypeName: string = "scheduledevents.TimeZoneEnum";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `ScheduledEvents`.
	 */


	/**
	 * See: {@link https://docs.mendix.com/refguide7/scheduled-events relevant section in reference guide}
	 */
	export interface IScheduledEvent extends projects.IDocument {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		load(): ScheduledEvent;
		load(callback: (element: ScheduledEvent) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/scheduled-events relevant section in reference guide}
	 */
	export class ScheduledEvent extends projects.Document implements IScheduledEvent {
		public static typeName: string = "ScheduledEvents$ScheduledEvent";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }

		private __startDateTime: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ScheduledEvent, this, "startDateTime", null, internal.PrimitiveTypeEnum.DateTime);
		public get startDateTime(): string { return this.__startDateTime.get(); }
		public set startDateTime(newValue: string) { this.__startDateTime.set(newValue); }
		private __timeZone: internal.EnumProperty<TimeZoneEnum> =
			new internal.EnumProperty<TimeZoneEnum>(ScheduledEvent, this, "timeZone", TimeZoneEnum.UTC, TimeZoneEnum);
		public get timeZone(): TimeZoneEnum { return this.__timeZone.get(); }
		public set timeZone(newValue: TimeZoneEnum) { this.__timeZone.set(newValue); }
		private __interval: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(ScheduledEvent, this, "interval", 0, internal.PrimitiveTypeEnum.Integer);
		public get interval(): number { return this.__interval.get(); }
		public set interval(newValue: number) { this.__interval.set(newValue); }
		private __intervalType: internal.EnumProperty<IntervalType> =
			new internal.EnumProperty<IntervalType>(ScheduledEvent, this, "intervalType", IntervalType.Minute, IntervalType);
		public get intervalType(): IntervalType { return this.__intervalType.get(); }
		public set intervalType(newValue: IntervalType) { this.__intervalType.set(newValue); }
		private __microflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(ScheduledEvent, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): microflows.IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: microflows.IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }
		private __enabled: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ScheduledEvent, this, "enabled", false, internal.PrimitiveTypeEnum.Boolean);
		public get enabled(): boolean { return this.__enabled.get(); }
		public set enabled(newValue: boolean) { this.__enabled.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "documents";
		}

		/**
		 * Creates a new ScheduledEvent unit in the SDK and on the server.
		 * Expects one argument, the projects.IFolderBase in which this unit is contained.
		 */
		public static createIn(container: projects.IFolderBase): ScheduledEvent {
			return internal.instancehelpers.createUnit(container, ScheduledEvent);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.intervalType = IntervalType.Minute;
			this.startDateTime = "" + Date.now();
			this.timeZone = TimeZoneEnum.UTC;
		}

	}
}

import {microflows} from "./microflows";

import {IModel} from "./base-model";
