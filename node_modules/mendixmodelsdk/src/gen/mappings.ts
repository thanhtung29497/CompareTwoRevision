/* tslint:disable */

import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;

import {projects} from "./projects";

export namespace mappings {

	export class ElementType extends internal.IEnum {
		public static Undefined: ElementType = new ElementType("Undefined", { });
		public static Inheritance: ElementType = new ElementType("Inheritance", { });
		public static Choice: ElementType = new ElementType("Choice", { });
		public static Object: ElementType = new ElementType("Object", { });
		public static Value: ElementType = new ElementType("Value", { });
		public static Sequence: ElementType = new ElementType("Sequence", { });
		public static All: ElementType = new ElementType("All", { });
		public static NamedArray: ElementType = new ElementType("NamedArray", {
			"introduced" : "6.4.0",
			"deleted" : "6.6.0",
			"deletionMessage" : null
		});
		public static Array: ElementType = new ElementType("Array", {
			"introduced" : "6.6.0"
		});
		public static Wrapper: ElementType = new ElementType("Wrapper", {
			"introduced" : "6.4.0"
		});
		protected qualifiedTsTypeName: string = "mappings.ElementType";
	}

	export class ObjectHandlingBackupEnum extends internal.IEnum {
		public static Create: ObjectHandlingBackupEnum = new ObjectHandlingBackupEnum("Create", { });
		public static Ignore: ObjectHandlingBackupEnum = new ObjectHandlingBackupEnum("Ignore", { });
		public static Error: ObjectHandlingBackupEnum = new ObjectHandlingBackupEnum("Error", { });
		protected qualifiedTsTypeName: string = "mappings.ObjectHandlingBackupEnum";
	}

	export class ObjectHandlingEnum extends internal.IEnum {
		public static Create: ObjectHandlingEnum = new ObjectHandlingEnum("Create", { });
		public static Find: ObjectHandlingEnum = new ObjectHandlingEnum("Find", { });
		public static Custom: ObjectHandlingEnum = new ObjectHandlingEnum("Custom", { });
		protected qualifiedTsTypeName: string = "mappings.ObjectHandlingEnum";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Mappings`.
	 */


	/**
	 * In version 6.6.0: introduced
	 */
	export interface IElement extends internal.IElement {
		model: IModel;
		containerAsJsonStructure: jsonstructures.IJsonStructure;
		containerAsElement: IElement;
		load(): Element;
		load(callback: (element: Element) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

	 *
	 * In version 6.6.0: introduced
	 */
	export abstract class Element extends internal.Element implements IElement {
		public static typeName: string = "Mappings$Element";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.6.0"
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsJsonStructure() { return super.getContainerAs<jsonstructures.JsonStructure>(jsonstructures.JsonStructure); }
		get containerAsElement() { return super.getContainerAs<Element>(Element); }

		private __elementType: internal.EnumProperty<ElementType> =
			new internal.EnumProperty<ElementType>(Element, this, "elementType", ElementType.Value, ElementType);
		public get elementType(): ElementType { return this.__elementType.get(); }
		public set elementType(newValue: ElementType) { this.__elementType.set(newValue); }
		private __primitiveType: internal.EnumProperty<xmlschemas.XmlPrimitiveType> =
			new internal.EnumProperty<xmlschemas.XmlPrimitiveType>(Element, this, "primitiveType", xmlschemas.XmlPrimitiveType.Unknown, xmlschemas.XmlPrimitiveType);
		public get primitiveType(): xmlschemas.XmlPrimitiveType { return this.__primitiveType.get(); }
		public set primitiveType(newValue: xmlschemas.XmlPrimitiveType) { this.__primitiveType.set(newValue); }
		private __path: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Element, this, "path", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type mappings.ElementPath.
		 */
		public get path(): string { return this.__path.get(); }
		public set path(newValue: string) { this.__path.set(newValue); }
		private __isDefaultType: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Element, this, "isDefaultType", false, internal.PrimitiveTypeEnum.Boolean);
		public get isDefaultType(): boolean { return this.__isDefaultType.get(); }
		public set isDefaultType(newValue: boolean) { this.__isDefaultType.set(newValue); }
		private __minOccurs: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Element, this, "minOccurs", 0, internal.PrimitiveTypeEnum.Integer);
		public get minOccurs(): number { return this.__minOccurs.get(); }
		public set minOccurs(newValue: number) { this.__minOccurs.set(newValue); }
		private __maxOccurs: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Element, this, "maxOccurs", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxOccurs(): number { return this.__maxOccurs.get(); }
		public set maxOccurs(newValue: number) { this.__maxOccurs.set(newValue); }
		private __nillable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(Element, this, "nillable", false, internal.PrimitiveTypeEnum.Boolean);
		public get nillable(): boolean { return this.__nillable.get(); }
		public set nillable(newValue: boolean) { this.__nillable.set(newValue); }
		private __exposedName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Element, this, "exposedName", "", internal.PrimitiveTypeEnum.String);
		public get exposedName(): string { return this.__exposedName.get(); }
		public set exposedName(newValue: string) { this.__exposedName.set(newValue); }
		private __maxLength: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Element, this, "maxLength", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxLength(): number { return this.__maxLength.get(); }
		public set maxLength(newValue: number) { this.__maxLength.set(newValue); }
		private __fractionDigits: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Element, this, "fractionDigits", 0, internal.PrimitiveTypeEnum.Integer);
		public get fractionDigits(): number { return this.__fractionDigits.get(); }
		public set fractionDigits(newValue: number) { this.__fractionDigits.set(newValue); }
		private __totalDigits: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(Element, this, "totalDigits", 0, internal.PrimitiveTypeEnum.Integer);
		public get totalDigits(): number { return this.__totalDigits.get(); }
		public set totalDigits(newValue: number) { this.__totalDigits.set(newValue); }
		private __errorMessage: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Element, this, "errorMessage", "", internal.PrimitiveTypeEnum.String);
		public get errorMessage(): string { return this.__errorMessage.get(); }
		public set errorMessage(newValue: string) { this.__errorMessage.set(newValue); }
		private __warningMessage: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Element, this, "warningMessage", "", internal.PrimitiveTypeEnum.String);
		public get warningMessage(): string { return this.__warningMessage.get(); }
		public set warningMessage(newValue: string) { this.__warningMessage.set(newValue); }
		private __children: internal.PartListProperty<Element> =
			new internal.PartListProperty<Element>(Element, this, "children", []);
		public get children(): internal.IList<Element> { return this.__children.get(); }
		public set children(newValue: internal.IList<Element>) { this.__children.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Element() cannot be invoked directly, please use 'model.mappings.createElement()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.elementType = ElementType.Value;
			this.fractionDigits = -1;
			this.maxLength = -1;
			this.maxOccurs = 1;
			this.minOccurs = 1;
			this.nillable = false;
			this.primitiveType = xmlschemas.XmlPrimitiveType.Unknown;
			this.totalDigits = -1;
		}

	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/mapping-documents relevant section in reference guide}
	 */
	export interface IMappingDocument extends projects.IDocument {
		model: IModel;
		containerAsFolderBase: projects.IFolderBase;
		load(): MappingDocument;
		load(callback: (element: MappingDocument) => void, forceRefresh?: boolean);
	}

	/**
	 * See: {@link https://docs.mendix.com/refguide7/mapping-documents relevant section in reference guide}
	 *
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MappingDocument extends projects.Document implements IMappingDocument {
		public static typeName: string = "Mappings$MappingDocument";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"jsonStructure" : {
					"introduced" : "6.4.0"
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsFolderBase() { return super.getContainerAs<projects.FolderBase>(projects.FolderBase); }

		private __rootMappingElements: internal.PartListProperty<ObjectMappingElement> =
			new internal.PartListProperty<ObjectMappingElement>(MappingDocument, this, "rootMappingElements", []);
		public get rootMappingElements(): internal.IList<ObjectMappingElement> { return this.__rootMappingElements.get(); }
		public set rootMappingElements(newValue: internal.IList<ObjectMappingElement>) { this.__rootMappingElements.set(newValue); }
		private __xmlSchema: internal.ByNameReferenceProperty<xmlschemas.IXmlSchema> =
			new internal.ByNameReferenceProperty<xmlschemas.IXmlSchema>(MappingDocument, this, "xmlSchema", null, "XmlSchemas$XmlSchema");
		public get xmlSchema(): xmlschemas.IXmlSchema { return this.__xmlSchema.get(); }
		public set xmlSchema(newValue: xmlschemas.IXmlSchema) { this.__xmlSchema.set(newValue); }
		get xmlSchemaQualifiedName(): string { return this.__xmlSchema.qualifiedName(); }
		private __jsonStructure: internal.ByNameReferenceProperty<jsonstructures.IJsonStructure> =
			new internal.ByNameReferenceProperty<jsonstructures.IJsonStructure>(MappingDocument, this, "jsonStructure", null, "JsonStructures$JsonStructure");
		/**
		 * In version 6.4.0: introduced
		 */
		public get jsonStructure(): jsonstructures.IJsonStructure { return this.__jsonStructure.get(); }
		public set jsonStructure(newValue: jsonstructures.IJsonStructure) { this.__jsonStructure.set(newValue); }
		get jsonStructureQualifiedName(): string { return this.__jsonStructure.qualifiedName(); }
		private __rootElementName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingDocument, this, "rootElementName", "", internal.PrimitiveTypeEnum.String);
		public get rootElementName(): string { return this.__rootElementName.get(); }
		public set rootElementName(newValue: string) { this.__rootElementName.set(newValue); }
		private __importedWebService: internal.ByNameReferenceProperty<webservices.IImportedWebService> =
			new internal.ByNameReferenceProperty<webservices.IImportedWebService>(MappingDocument, this, "importedWebService", null, "WebServices$ImportedWebService");
		public get importedWebService(): webservices.IImportedWebService { return this.__importedWebService.get(); }
		public set importedWebService(newValue: webservices.IImportedWebService) { this.__importedWebService.set(newValue); }
		get importedWebServiceQualifiedName(): string { return this.__importedWebService.qualifiedName(); }
		private __serviceName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingDocument, this, "serviceName", "", internal.PrimitiveTypeEnum.String);
		public get serviceName(): string { return this.__serviceName.get(); }
		public set serviceName(newValue: string) { this.__serviceName.set(newValue); }
		private __operationName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingDocument, this, "operationName", "", internal.PrimitiveTypeEnum.String);
		public get operationName(): string { return this.__operationName.get(); }
		public set operationName(newValue: string) { this.__operationName.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase) {
			super(model, typeName, id, isPartial, container);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMappingElement extends internal.IElement {
		model: IModel;
		containerAsMappingDocument: IMappingDocument;
		containerAsObjectMappingElement: IObjectMappingElement;
		load(): MappingElement;
		load(callback: (element: MappingElement) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class MappingElement extends internal.Element implements IMappingElement {
		public static typeName: string = "Mappings$MappingElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"exposedName" : {
					"introduced" : "6.6.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMappingDocument() { return super.getContainerAs<MappingDocument>(MappingDocument); }
		get containerAsObjectMappingElement() { return super.getContainerAs<ObjectMappingElement>(ObjectMappingElement); }

		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingElement, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __elementType: internal.EnumProperty<ElementType> =
			new internal.EnumProperty<ElementType>(MappingElement, this, "elementType", ElementType.Undefined, ElementType);
		public get elementType(): ElementType { return this.__elementType.get(); }
		public set elementType(newValue: ElementType) { this.__elementType.set(newValue); }
		private __path: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingElement, this, "path", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type mappings.ElementPath.
		 */
		public get path(): string { return this.__path.get(); }
		public set path(newValue: string) { this.__path.set(newValue); }
		private __minOccurs: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(MappingElement, this, "minOccurs", 0, internal.PrimitiveTypeEnum.Integer);
		public get minOccurs(): number { return this.__minOccurs.get(); }
		public set minOccurs(newValue: number) { this.__minOccurs.set(newValue); }
		private __maxOccurs: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(MappingElement, this, "maxOccurs", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxOccurs(): number { return this.__maxOccurs.get(); }
		public set maxOccurs(newValue: number) { this.__maxOccurs.set(newValue); }
		private __nillable: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(MappingElement, this, "nillable", false, internal.PrimitiveTypeEnum.Boolean);
		public get nillable(): boolean { return this.__nillable.get(); }
		public set nillable(newValue: boolean) { this.__nillable.set(newValue); }
		private __exposedName: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingElement, this, "exposedName", "", internal.PrimitiveTypeEnum.String);
		/**
		 * In version 6.6.0: introduced
		 */
		public get exposedName(): string { return this.__exposedName.get(); }
		public set exposedName(newValue: string) { this.__exposedName.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MappingElement() cannot be invoked directly, please use 'model.mappings.createMappingElement()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.elementType = ElementType.Undefined;
		}

	}

	export interface IMappingMicroflowCall extends internal.IElement {
		model: IModel;
		containerAsObjectMappingElement: IObjectMappingElement;
		load(): MappingMicroflowCall;
		load(callback: (element: MappingMicroflowCall) => void, forceRefresh?: boolean);
	}

	export class MappingMicroflowCall extends internal.Element implements IMappingMicroflowCall {
		public static typeName: string = "Mappings$MappingMicroflowCall";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsObjectMappingElement() { return super.getContainerAs<ObjectMappingElement>(ObjectMappingElement); }

		private __microflow: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(MappingMicroflowCall, this, "microflow", null, "Microflows$Microflow");
		public get microflow(): microflows.IMicroflow { return this.__microflow.get(); }
		public set microflow(newValue: microflows.IMicroflow) { this.__microflow.set(newValue); }
		get microflowQualifiedName(): string { return this.__microflow.qualifiedName(); }
		private __parameterMappings: internal.PartListProperty<MappingMicroflowParameter> =
			new internal.PartListProperty<MappingMicroflowParameter>(MappingMicroflowCall, this, "parameterMappings", []);
		public get parameterMappings(): internal.IList<MappingMicroflowParameter> { return this.__parameterMappings.get(); }
		public set parameterMappings(newValue: internal.IList<MappingMicroflowParameter>) { this.__parameterMappings.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MappingMicroflowCall() cannot be invoked directly, please use 'model.mappings.createMappingMicroflowCall()'"
				);
			}
		}

		/**
		 * Creates and returns a new MappingMicroflowCall instance in the SDK and on the server.
		 * The new MappingMicroflowCall will be automatically stored in the 'mappingMicroflowCall' property
		 * of the parent ObjectMappingElement element passed as argument.
		 */
		public static createIn(container: ObjectMappingElement): MappingMicroflowCall {
			return internal.instancehelpers.createElement(container, MappingMicroflowCall, "mappingMicroflowCall", false);
		}

		/**
		 * Creates and returns a new MappingMicroflowCall instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MappingMicroflowCall {
			return internal.instancehelpers.createElement(model, MappingMicroflowCall);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMappingMicroflowParameter extends internal.IElement {
		model: IModel;
		containerAsMappingMicroflowCall: IMappingMicroflowCall;
		load(): MappingMicroflowParameter;
		load(callback: (element: MappingMicroflowParameter) => void, forceRefresh?: boolean);
	}

	export class MappingMicroflowParameter extends internal.Element implements IMappingMicroflowParameter {
		public static typeName: string = "Mappings$MappingMicroflowParameter";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMappingMicroflowCall() { return super.getContainerAs<MappingMicroflowCall>(MappingMicroflowCall); }

		private __parameter: internal.ByNameReferenceProperty<microflows.IMicroflowParameter> =
			new internal.ByNameReferenceProperty<microflows.IMicroflowParameter>(MappingMicroflowParameter, this, "parameter", null, "Microflows$MicroflowParameter");
		public get parameter(): microflows.IMicroflowParameter { return this.__parameter.get(); }
		public set parameter(newValue: microflows.IMicroflowParameter) { this.__parameter.set(newValue); }
		get parameterQualifiedName(): string { return this.__parameter.qualifiedName(); }
		private __levelOfParent: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(MappingMicroflowParameter, this, "levelOfParent", 0, internal.PrimitiveTypeEnum.Integer);
		public get levelOfParent(): number { return this.__levelOfParent.get(); }
		public set levelOfParent(newValue: number) { this.__levelOfParent.set(newValue); }
		private __valueElementPath: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(MappingMicroflowParameter, this, "valueElementPath", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type mappings.ElementPath.
		 */
		public get valueElementPath(): string { return this.__valueElementPath.get(); }
		public set valueElementPath(newValue: string) { this.__valueElementPath.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MappingMicroflowParameter() cannot be invoked directly, please use 'model.mappings.createMappingMicroflowParameter()'"
				);
			}
		}

		/**
		 * Creates and returns a new MappingMicroflowParameter instance in the SDK and on the server.
		 * The new MappingMicroflowParameter will be automatically stored in the 'parameterMappings' property
		 * of the parent MappingMicroflowCall element passed as argument.
		 */
		public static createIn(container: MappingMicroflowCall): MappingMicroflowParameter {
			return internal.instancehelpers.createElement(container, MappingMicroflowParameter, "parameterMappings", true);
		}

		/**
		 * Creates and returns a new MappingMicroflowParameter instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MappingMicroflowParameter {
			return internal.instancehelpers.createElement(model, MappingMicroflowParameter);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.levelOfParent = -1;
		}

	}

	export interface IObjectMappingElement extends IMappingElement {
		model: IModel;
		containerAsMappingDocument: IMappingDocument;
		containerAsObjectMappingElement: IObjectMappingElement;
		load(): ObjectMappingElement;
		load(callback: (element: ObjectMappingElement) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ObjectMappingElement extends MappingElement implements IObjectMappingElement {
		public static typeName: string = "Mappings$ObjectMappingElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"isDefaultType" : {
					"introduced" : "6.4.0"
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsMappingDocument() { return super.getContainerAs<MappingDocument>(MappingDocument); }
		get containerAsObjectMappingElement() { return super.getContainerAs<ObjectMappingElement>(ObjectMappingElement); }

		private __mappingMicroflowCall: internal.PartProperty<MappingMicroflowCall> =
			new internal.PartProperty<MappingMicroflowCall>(ObjectMappingElement, this, "mappingMicroflowCall", null, false);
		public get mappingMicroflowCall(): MappingMicroflowCall { return this.__mappingMicroflowCall.get(); }
		public set mappingMicroflowCall(newValue: MappingMicroflowCall) { this.__mappingMicroflowCall.set(newValue); }
		private __children: internal.PartListProperty<MappingElement> =
			new internal.PartListProperty<MappingElement>(ObjectMappingElement, this, "children", []);
		public get children(): internal.IList<MappingElement> { return this.__children.get(); }
		public set children(newValue: internal.IList<MappingElement>) { this.__children.set(newValue); }
		private __entity: internal.ByNameReferenceProperty<domainmodels.IEntity> =
			new internal.ByNameReferenceProperty<domainmodels.IEntity>(ObjectMappingElement, this, "entity", null, "DomainModels$Entity");
		public get entity(): domainmodels.IEntity { return this.__entity.get(); }
		public set entity(newValue: domainmodels.IEntity) { this.__entity.set(newValue); }
		get entityQualifiedName(): string { return this.__entity.qualifiedName(); }
		private __association: internal.ByNameReferenceProperty<domainmodels.IAssociationBase> =
			new internal.ByNameReferenceProperty<domainmodels.IAssociationBase>(ObjectMappingElement, this, "association", null, "DomainModels$AssociationBase");
		public get association(): domainmodels.IAssociationBase { return this.__association.get(); }
		public set association(newValue: domainmodels.IAssociationBase) { this.__association.set(newValue); }
		get associationQualifiedName(): string { return this.__association.qualifiedName(); }
		private __objectHandling: internal.EnumProperty<ObjectHandlingEnum> =
			new internal.EnumProperty<ObjectHandlingEnum>(ObjectMappingElement, this, "objectHandling", ObjectHandlingEnum.Create, ObjectHandlingEnum);
		public get objectHandling(): ObjectHandlingEnum { return this.__objectHandling.get(); }
		public set objectHandling(newValue: ObjectHandlingEnum) { this.__objectHandling.set(newValue); }
		private __objectHandlingBackup: internal.EnumProperty<ObjectHandlingBackupEnum> =
			new internal.EnumProperty<ObjectHandlingBackupEnum>(ObjectMappingElement, this, "objectHandlingBackup", ObjectHandlingBackupEnum.Create, ObjectHandlingBackupEnum);
		public get objectHandlingBackup(): ObjectHandlingBackupEnum { return this.__objectHandlingBackup.get(); }
		public set objectHandlingBackup(newValue: ObjectHandlingBackupEnum) { this.__objectHandlingBackup.set(newValue); }
		private __isDefaultType: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ObjectMappingElement, this, "isDefaultType", false, internal.PrimitiveTypeEnum.Boolean);
		/**
		 * In version 6.4.0: introduced
		 */
		public get isDefaultType(): boolean { return this.__isDefaultType.get(); }
		public set isDefaultType(newValue: boolean) { this.__isDefaultType.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ObjectMappingElement() cannot be invoked directly, please use 'model.mappings.createObjectMappingElement()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.objectHandling = ObjectHandlingEnum.Create;
			this.objectHandlingBackup = ObjectHandlingBackupEnum.Create;
		}

	}

	export interface IValueMappingElement extends IMappingElement {
		model: IModel;
		containerAsObjectMappingElement: IObjectMappingElement;
		load(): ValueMappingElement;
		load(callback: (element: ValueMappingElement) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ValueMappingElement extends MappingElement implements IValueMappingElement {
		public static typeName: string = "Mappings$ValueMappingElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"xmlPrimitiveType" : {
					"introduced" : "6.1.0"
				},
				"expectedContentTypes" : {
					"deleted" : "6.4.1",
					"deletionMessage" : null
				}
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsObjectMappingElement() { return super.getContainerAs<ObjectMappingElement>(ObjectMappingElement); }

		private __xmlDataType: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ValueMappingElement, this, "xmlDataType", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type dataTypes.DataType.
		 */
		public get xmlDataType(): string { return this.__xmlDataType.get(); }
		public set xmlDataType(newValue: string) { this.__xmlDataType.set(newValue); }
		private __isKey: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ValueMappingElement, this, "isKey", false, internal.PrimitiveTypeEnum.Boolean);
		public get isKey(): boolean { return this.__isKey.get(); }
		public set isKey(newValue: boolean) { this.__isKey.set(newValue); }
		private __isXmlAttribute: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ValueMappingElement, this, "isXmlAttribute", false, internal.PrimitiveTypeEnum.Boolean);
		public get isXmlAttribute(): boolean { return this.__isXmlAttribute.get(); }
		public set isXmlAttribute(newValue: boolean) { this.__isXmlAttribute.set(newValue); }
		private __xmlPrimitiveType: internal.EnumProperty<xmlschemas.XmlPrimitiveType> =
			new internal.EnumProperty<xmlschemas.XmlPrimitiveType>(ValueMappingElement, this, "xmlPrimitiveType", xmlschemas.XmlPrimitiveType.Unknown, xmlschemas.XmlPrimitiveType);
		/**
		 * In version 6.1.0: introduced
		 */
		public get xmlPrimitiveType(): xmlschemas.XmlPrimitiveType { return this.__xmlPrimitiveType.get(); }
		public set xmlPrimitiveType(newValue: xmlschemas.XmlPrimitiveType) { this.__xmlPrimitiveType.set(newValue); }
		private __isContent: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(ValueMappingElement, this, "isContent", false, internal.PrimitiveTypeEnum.Boolean);
		public get isContent(): boolean { return this.__isContent.get(); }
		public set isContent(newValue: boolean) { this.__isContent.set(newValue); }
		private __attribute: internal.ByNameReferenceProperty<domainmodels.IAttribute> =
			new internal.ByNameReferenceProperty<domainmodels.IAttribute>(ValueMappingElement, this, "attribute", null, "DomainModels$Attribute");
		public get attribute(): domainmodels.IAttribute { return this.__attribute.get(); }
		public set attribute(newValue: domainmodels.IAttribute) { this.__attribute.set(newValue); }
		get attributeQualifiedName(): string { return this.__attribute.qualifiedName(); }
		private __converter: internal.ByNameReferenceProperty<microflows.IMicroflow> =
			new internal.ByNameReferenceProperty<microflows.IMicroflow>(ValueMappingElement, this, "converter", null, "Microflows$Microflow");
		public get converter(): microflows.IMicroflow { return this.__converter.get(); }
		public set converter(newValue: microflows.IMicroflow) { this.__converter.set(newValue); }
		get converterQualifiedName(): string { return this.__converter.qualifiedName(); }
		private __expectedContentTypes: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(ValueMappingElement, this, "expectedContentTypes", "", internal.PrimitiveTypeEnum.String);
		/**
		 * In version 6.4.1: deleted
		 */
		public get expectedContentTypes(): string { return this.__expectedContentTypes.get(); }
		public set expectedContentTypes(newValue: string) { this.__expectedContentTypes.set(newValue); }
		private __maxLength: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(ValueMappingElement, this, "maxLength", 0, internal.PrimitiveTypeEnum.Integer);
		public get maxLength(): number { return this.__maxLength.get(); }
		public set maxLength(newValue: number) { this.__maxLength.set(newValue); }
		private __fractionDigits: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(ValueMappingElement, this, "fractionDigits", 0, internal.PrimitiveTypeEnum.Integer);
		public get fractionDigits(): number { return this.__fractionDigits.get(); }
		public set fractionDigits(newValue: number) { this.__fractionDigits.set(newValue); }
		private __totalDigits: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(ValueMappingElement, this, "totalDigits", 0, internal.PrimitiveTypeEnum.Integer);
		public get totalDigits(): number { return this.__totalDigits.get(); }
		public set totalDigits(newValue: number) { this.__totalDigits.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ValueMappingElement() cannot be invoked directly, please use 'model.mappings.createValueMappingElement()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.fractionDigits = -1;
			this.maxLength = -1;
			this.totalDigits = -1;
			this.xmlDataType = "Unknown";
			if (this.__xmlPrimitiveType.isAvailable) {
				this.xmlPrimitiveType = xmlschemas.XmlPrimitiveType.Unknown;
			}
		}

	}
}

import {domainmodels} from "./domainmodels";
import {jsonstructures} from "./jsonstructures";
import {microflows} from "./microflows";
import {webservices} from "./webservices";
import {xmlschemas} from "./xmlschemas";

import {IModel} from "./base-model";
