

import {assert} from "chai";
import {find} from "lodash";

import {domainmodels, IModel, projects} from "../../index";
import {CompanyExpensesStubClient, StubClient} from "../helpers/stub-model-client";
import {createSdkClient} from "../helpers/sdk-client-helper";


const domainModelUnitId = CompanyExpensesStubClient.domainModelUnitId;

describe("meta model checks", () => {

	it("should load units and domain model", done => {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			assert.equal(m.allDomainModels().length, 3);
			const d = m.allDomainModels()[1];
			assert.equal(d.qualifiedName, "Expenses");
			done();
		}, done);
	});

	it("should create texts for validation rules with default values", done => {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			assert.equal(m.allDomainModels().length, 3);
			const d = m.allDomainModels()[1];
			assert.equal(d.qualifiedName, "Expenses");
			d.load(dm => {
				const e = dm.entities[0];
				domainmodels.ValidationRule.createIn(e);

				const vr = e.validationRules[e.validationRules.length - 1];
				const er = vr.errorMessage;
				assert.ok(er);
				assert.equal(er.translations.length, 1);
				const tl = vr.errorMessage.translations[0];
				assert.equal(tl.languageCode, "en_US");
				assert.equal(tl.text, "");

				m.closeConnection(() => {
					assert.deepEqual((m["_client"] as StubClient).deltas,
						[
							{
								"deltaType": "CREATE_ELEMENT",
								"elementId": vr.id,
								"elementType": "DomainModels$ValidationRule",
								"parentId": e.id,
								"parentPropertyName": "validationRules",
								"unitId": dm.id
							},
							{
								"deltaType": "CREATE_ELEMENT",
								"elementId": er.id,
								"elementType": "Texts$Text",
								"parentId": vr.id,
								"parentPropertyName": "errorMessage",
								"unitId": dm.id
							},
							{
								"deltaType": "CREATE_ELEMENT",
								"elementId": tl.id,
								"elementType": "Texts$Translation",
								"parentId": er.id,
								"parentPropertyName": "translations",
								"unitId": dm.id
							},
							{
								"deltaType": "UPDATE_PROPERTY_VALUE",
								"elementId": tl.id,
								"mutator": {
									"mutatorType": "CHANGE",
									"value": "en_US"
								},
								"propertyName": "languageCode",
								"unitId": dm.id
							},
							{
								"deltaType": "CREATE_ELEMENT",
								"elementId": vr.ruleInfo.id,
								"elementType": "DomainModels$RequiredRuleInfo",
								"parentId": vr.id,
								"parentPropertyName": "ruleInfo",
								"unitId": dm.id
							}
						]
					);
					done();
				});
			});
		}, done);
	});

	it("should resolve references by id", done => {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			const d = m.allDomainModels()[1];
			const assoc = d.associations[0];
			assert.equal(assoc.name, "Expense_ExpenseType");
			assert.equal(assoc.parent.name, "Expense");
			assert.equal(assoc.child.name, "ExpenseType");
			done();
		}, done);
	});

	it("should generate correct qualified names for attributes", done => {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			const d = m.allDomainModels()[1];
			const e = d.entities.find(e => e.name === "Expense");
			const attr = e.attributes.find(a => a.name === "Status");
			assert.ok(attr);
			assert.equal(attr.qualifiedName, "Expenses.Expense.Status");
			done();
		}, done);
	});

	it("should resolve references by name in interfaces", function(done) {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			const d = m.allDomainModels()[1];
			assert.equal(d.qualifiedName, "Expenses");
			const assoc = d.crossAssociations[0];
			assert.equal(assoc.name, "Conversion_User");
			assert.equal(assoc.parent.name, "Conversion");

			// TODO: only available once system module is available...
			// assert.equal(assoc.child.name, "User");

			const entity: domainmodels.IEntity = m.findEntityByQualifiedName("Expenses.Expense") as domainmodels.IEntity;
			const attr = find(entity.attributes, a => a.name === "Status");
			assert.ok(attr, "attr was not found");
			assert.ok((attr.type as domainmodels.EnumerationAttributeType).enumeration, "enumeration was not resolved");
			assert.equal((attr.type as domainmodels.EnumerationAttributeType).enumeration.name, "Expense_Status");

			done();
		}, done);
	});

	it("should resolve references by name in units", function(done) {
		this.timeout(0);
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			m.loadUnitById(domainModelUnitId, false, (d: domainmodels.DomainModel) => {
				const entity: domainmodels.Entity = m.findEntityByQualifiedName("Expenses.Expense") as domainmodels.Entity;
				const attr = find(entity.attributes, a => a.name === "Status");
				assert.ok(attr, "attr was not found");
				assert.ok((attr.type as domainmodels.EnumerationAttributeType).enumeration, "enumeration was not resolved");
				assert.equal((attr.type as domainmodels.EnumerationAttributeType).enumeration.name, "Expense_Status");
				assert.equal((m["_client"] as StubClient).deltas.length, 0);
				done();
			});
		}, done);
	});

	it("should handle bynamereferencelists", function(done) {
		this.timeout(0);
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			m.allDomainModels().filter(d => d.qualifiedName === "Expenses")[0].load(dm => {
				const unitId = dm.id;
				const module = dm.containerAsModule;
				assert.equal(module.moduleSecurity.moduleRoles.length, 3);

				const managerRole = module.moduleSecurity.moduleRoles.find(mr => mr.name === "Manager");
				assert.equal(managerRole.qualifiedName, "Expenses.Manager");

				const employeeRole = module.moduleSecurity.moduleRoles.find(mr => mr.name === "Employee");
				assert.equal(employeeRole.qualifiedName, "Expenses.Employee");

				const entity = dm.entities.find(e => e.name === "ExpenseType");
				assert.equal(entity.accessRules.length, 2, "invalid amount of access rules");
				const ac = entity.accessRules[1];
				assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");

				assert.equal(ac.moduleRoles[1].qualifiedName, managerRole.qualifiedName);
				assert.equal(ac.moduleRoles[1], managerRole);

				ac.moduleRoles[0] = employeeRole;
				ac.moduleRoles.pop();
				assert.equal(ac.moduleRoles.length, 1, "invalid amount of module roles in access rule");
				ac.moduleRoles.unshift(managerRole);
				assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");

				assert.throw(() => {
					ac.moduleRoles = [employeeRole] as any;
				}, "Illegal state: cannot re-assign list property - use push or splice instead");

				const elementId = "e2c13b7d-efa3-4f56-a7aa-8441fab9f3f6";
				m.closeConnection(() => {
					assert.deepEqual((m["_client"] as StubClient).deltas, [
						{
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"elementId": elementId,
							"mutator": {
								"mutatorType": "CHANGE",
								"updateIndex": 0,
								"value": "Expenses.Employee"
							},
							"propertyName": "moduleRoles",
							"unitId": unitId
						},
						{
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"elementId": elementId,
							"mutator": {
								"mutatorType": "REMOVE",
								"removalIndex": 2
							},
							"propertyName": "moduleRoles",
							"unitId": unitId
						},
						{
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"elementId": elementId,
							"mutator": {
								"insertionIndex": 0,
								"mutatorType": "ADD",
								"value": "Expenses.Manager"
							},
							"propertyName": "moduleRoles",
							"unitId": unitId
						}
					]);
					done();
				});

			});
		}, done);
	});

	const expectedContainmentExceptionMessage = `Cannot update property of '${domainmodels.Association.typeName}', `
		+ `the given object is not yet part of a unit. Please add the object to an unit first`;

	it("should fail on references to objects not added to the tree yet", function(done) {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			m.loadUnitById(domainModelUnitId, false, (d: domainmodels.DomainModel) => {
				const entity = domainmodels.Entity.create(m);
				const assoc = domainmodels.Association.create(m);
				try {
					assoc.parent = entity;
				} catch (e) {
					assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
					return void done();
				}
				return void done(new Error("expected exception"));
			});
		}, done);
	});


	it("should handle by-name reference lists", function(done) {
		createSdkClient().openWorkingCopy("1", (m: IModel) => {
			m.loadUnitById(domainModelUnitId, false, (d: domainmodels.DomainModel) => {
				const entity = domainmodels.Entity.create(m);
				const assoc = domainmodels.Association.create(m);
				try {
					assoc.parent = entity;
				} catch (e) {
					assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
					return void done();
				}
				return void done(new Error("expected exception"));
			});
		}, done);
	});

	it("should pick up renames and deletes of elements that are refered by name", function(done) {
		createSdkClient().openWorkingCopy("1", model => {
			model.loadUnitById(domainModelUnitId, false, (d: domainmodels.DomainModel) => {
				// create a cross association (in the same module, but that's ok for now...):
				const crossAssoc = domainmodels.CrossAssociation.create(model);

				d.crossAssociations.unshift(crossAssoc);
				const tempUserEntity = find(d.entities, ent => ent.name === "TempUser");
				assert.ok(tempUserEntity);

				const amountOfEntities = d.entities.length;
				crossAssoc.parent = d.entities[0];
				crossAssoc.child = tempUserEntity; // This entity has no assocs, so can be deleted easily
				assert.equal(crossAssoc.childQualifiedName, "Expenses.TempUser");

				// rename an entity:
				tempUserEntity.name = "Renamed";
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				// delete that entity:
				tempUserEntity.delete();
				assert.equal(d.entities.length, amountOfEntities - 1);

				// name should be saved, but reference should not resolve anymore:
				assert.equal((crossAssoc as any).__child.observableValue.referenceId, "Expenses.Renamed");
				assert.equal(crossAssoc.child, null);
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				// Create new entity, reference should be picked up automatically
				const newEntity = domainmodels.Entity.createIn(d);
				assert.equal(d.entities.length, amountOfEntities);
				newEntity.name = "Renamed";

				assert.equal((crossAssoc as any).__child.observableValue.referenceId, "Expenses.Renamed");
				assert.equal(crossAssoc.child, newEntity);
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				model.findModuleByQualifiedName("Expenses").name = "Expenses2";
				assert.equal(crossAssoc.child, newEntity);
				assert.equal(crossAssoc.childQualifiedName, "Expenses2.Renamed");

				model.closeConnection(() => {
					// verify the deltas created during the process:
					const deltas = (model["_client"] as StubClient).deltas.slice();
					assert.deepEqual(deltas, [
						{
							"parentId": domainModelUnitId,
							"elementType": domainmodels.CrossAssociation.typeName,
							"parentPropertyName": "crossAssociations",
							"deltaType": "CREATE_ELEMENT",
							"unitId": domainModelUnitId,
							"elementId": crossAssoc.id
						},
						{
							"unitId": domainModelUnitId,
							"elementId": crossAssoc.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "dataStorageGuid",
							"mutator": {
								"value": crossAssoc.dataStorageGuid,
								"mutatorType": "CHANGE"
							}
						},
						{
							"parentId": crossAssoc.id,
							"elementType": domainmodels.AssociationDeleteBehavior.typeName,
							"parentPropertyName": "deleteBehavior",
							"deltaType": "CREATE_ELEMENT",
							"unitId": domainModelUnitId,
							"elementId": crossAssoc.deleteBehavior.id
						},
						{
							"deltaType": "MOVE_ELEMENT",
							elementId: crossAssoc.id,
							newIndex: 0,
							newParentId: domainModelUnitId,
							newParentPropertyName: "crossAssociations",
							unitId: domainModelUnitId
						},
						{
							"unitId": domainModelUnitId,
							"elementId": crossAssoc.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "parent",
							"mutator": {
								"value": "48345255-c0be-4304-803b-1e53c658eb93",
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": domainModelUnitId,
							"elementId": crossAssoc.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "child",
							"mutator": {
								"value": "Expenses.TempUser",
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": domainModelUnitId,
							"elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "name",
							"mutator": {
								"value": "Renamed",
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": domainModelUnitId,
							"elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
							"deltaType": "DELETE_ELEMENT"
						},
						{
							"parentId": domainModelUnitId,
							"elementType": domainmodels.Entity.typeName,
							"parentPropertyName": "entities",
							"deltaType": "CREATE_ELEMENT",
							"unitId": domainModelUnitId,
							"elementId": newEntity.id
						},
						{
							"unitId": domainModelUnitId,
							"elementId": newEntity.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "dataStorageGuid",
							"mutator": {
								"value": newEntity.dataStorageGuid,
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": domainModelUnitId,
							"parentId": newEntity.id,
							"elementType": domainmodels.NoGeneralization.typeName,
							"parentPropertyName": "generalization",
							"deltaType": "CREATE_ELEMENT",
							"elementId": newEntity.generalization.id
						},
						{
							"unitId": domainModelUnitId,
							"elementId": newEntity.generalization.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "persistable",
							"mutator": {
								"value": true,
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": domainModelUnitId,
							"elementId": newEntity.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "name",
							"mutator": {
								"value": "Renamed",
								"mutatorType": "CHANGE"
							}
						},
						{
							"unitId": d.container.id,
							"elementId": d.container.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "name",
							"mutator": {
								"value": "Expenses2",
								"mutatorType": "CHANGE"
							}
						}
					]);

					done();
				});
			});
		}, done);
	});

	it("setting an optional by-id reference to null should clear it (but not remove the referred element)", function(done) {
		this.timeout(0);	// avoid debug session being aborted
		createSdkClient().openWorkingCopy("1", model => {
			model.loadUnitById(domainModelUnitId, false, (d: domainmodels.DomainModel) => {
				const entity = d.entities[0];
				const attribute1 = entity.attributes[0];

				const index = domainmodels.Index.createIn(entity);
				const indexedAttribute = domainmodels.IndexedAttribute.createIn(index);
				indexedAttribute.attribute = attribute1;
				assert.isNotNull(indexedAttribute.attribute);

				indexedAttribute.attribute = null;
				assert.isNull(indexedAttribute.attribute);	// also: no exception thrown
				assert.ok(entity.attributes[0]);
				assert.equal(entity.attributes[0].id, attribute1.id);

				model.closeConnection(() => {
					// verify the deltas created during the process:
					const deltas = (model["_client"] as StubClient).deltas.slice();
					assert.deepEqual(deltas.slice(4), [	// look only at last ∂
						{
							"unitId": domainModelUnitId,
							"elementId": indexedAttribute.id,
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"propertyName": "attribute",
							"mutator": {
								"value": null,
								"mutatorType": "CHANGE"
							}
						}
					]);
					done();
				});
			});
		}, done);
	});

	it("should pick up broken by-name references, even when name is applied (again)", function(done) {
		createSdkClient().openWorkingCopy("1", model => {
			model.loadUnitById(domainModelUnitId, false, (dm1: domainmodels.DomainModel) => {
				// verify we have an entity e1 in dm1
				const entity1 = find(dm1.entities, ent => ent.name === "TempUser");
				assert.ok(entity1);

				// create a new module
				const module2 = projects.Module.createIn(model.root);
				module2.name = "Module2";

				// create a new domain model in that new module
				const dm2 = domainmodels.DomainModel.createIn(module2);

				// create an entity e2 there
				let entity2 = domainmodels.Entity.createIn(dm2);
				entity2.name = "Entity2";

				const entity3 = domainmodels.Entity.createIn(dm2);
				entity3.name = "Entity3";
				assert.equal(entity3.qualifiedName, "Module2.Entity3");

				// create a new cross assoc from e1 to e2
				const crossAssoc1 = domainmodels.CrossAssociation.create(model);
				crossAssoc1.name = "entity1_entity2";
				crossAssoc1.parent = entity1;
				crossAssoc1.child = entity2;
				dm1.crossAssociations.push(crossAssoc1);

				crossAssoc1.child = entity3;	// replace unbroken ref
				assert.equal(crossAssoc1.child, entity3);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity3");

				crossAssoc1.child = entity2;	// replace unbroken ref
				assert.equal(crossAssoc1.child, entity2);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");

				// delete e2
				entity2.delete();
				entity2 = null;

				// checks to see if all is as expected
				assert.equal(crossAssoc1.child, null);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");

				// recreate e2
				entity2 = domainmodels.Entity.create(model);
				// applying (same) name again:
				entity2.name = "Entity2";
				// adding the entity to its container áfter having changed the name
				dm2.entities.push(entity2);

				// see if the cross assoc is updated
				assert.equal(crossAssoc1.child, entity2);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");

				// delete e2 again:
				entity2.delete();
				entity2 = null;
				crossAssoc1.child = entity3;	// replace broken ref
				assert.equal(crossAssoc1.child, entity3);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity3");

				/* TODO: require story 641275 to be finished first
				// replace dm2 with something else
				const entity3 = domainmodels.Entity.create(model);
				dm2.entities[0] = entity3; // TODO: breaks reference

				assert.equal(crossAssoc1.child, null);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");

				// and swap it out again..
				dm2.entities[0] = entity2; // TODO: should not be allowed, was already deleted!
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");
				assert.equal(crossAssoc1.child, null);

				// replace in list with other entity with same name
				const entity4 = domainmodels.Entity.create(model);
				entity4.name = "Entity2";
				dm2.entities[0] = entity4;

				assert.equal(crossAssoc1.child, entity4);
				assert.equal(crossAssoc1.childQualifiedName, "Module2.Entity2");

				// TODO  check if the correct deltas have been sent
				*/
				model.closeConnection(done);
			});
		}, done);
	});

});
