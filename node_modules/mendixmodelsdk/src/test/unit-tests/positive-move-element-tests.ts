

import {assert} from "chai";
import {observable} from "mobx";

import {pages_simple} from "../gen/pages_simple";
import {StubClient, withPage0} from "../helpers/stub-model-client";


describe("when moving elements around in a drag-and-drop fashion, it", () => {

	it("should be possible to move from a non-listy property to a listy one (case 1)", done => {
		withPage0(page => {
			const srcContainer = page.widgets[0] as pages_simple.SingleContainer;
			assert.ok(srcContainer);
			const dstContainer = page.widgets[2] as pages_simple.MultiContainer;
			assert.equal(dstContainer.widgets.length, 3);

			const widgetToMove = srcContainer.widget;
			dstContainer.widgets.push(widgetToMove);

			assert.notOk(srcContainer.widget);
			assert.equal(dstContainer.widgets.length, 4);
			assert.equal(dstContainer.widgets[3], widgetToMove);

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, [
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newIndex": 3,
						"newParentId": dstContainer.id,
						"newParentPropertyName": "widgets",
						"unitId": page.id
					}
				]);
				done();
			}, done);
		}, done);
	});

	it("should be possible to move from a listy property to a non-listy one (case 2)", done => {
		withPage0(page => {
			const srcContainer = page.widgets[2] as pages_simple.MultiContainer;
			assert.equal(srcContainer.widgets.length, 3);
			const dstContainer = page.widgets[1] as pages_simple.SingleContainer;
			assert.ok(dstContainer);

			const widgetToMove = srcContainer.widgets[0];
			dstContainer.widget = widgetToMove;	// <-- action!

			assert.equal(dstContainer.widget, widgetToMove);
			assert.equal(srcContainer.widgets.length, 2);

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, [
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newParentId": dstContainer.id,
						"newParentPropertyName": "widget",
						"unitId": page.id
					}
				]);
				done();
			}, done);
		}, done);
	});

	it("should be possible to move from a non-listy property to a non-listy one in another container (case 3(a))", done => {
		withPage0(page => {
			const srcContainer = page.widgets[0] as pages_simple.SingleContainer;
			assert.ok(srcContainer);
			assert.ok(srcContainer.widget);
			const dstContainer = page.widgets[1] as pages_simple.SingleContainer;
			assert.ok(dstContainer);

			const widgetToMove = srcContainer.widget;
			dstContainer.anotherWidget = widgetToMove;	// <-- action!

			assert.equal(dstContainer.anotherWidget, widgetToMove);
			assert.notOk(srcContainer.widget);

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, [
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newParentId": dstContainer.id,
						"newParentPropertyName": "anotherWidget",
						"unitId": page.id
					}
				]);
				done();
			}, done);
		}, done);
	});

	it("should be possible to move from a non-listy property to a non-listy one in the same container (case 3(b))", done => {
		withPage0(page => {
			const container = page.widgets[0] as pages_simple.SingleContainer;
			assert.ok(container);
			assert.ok(container.widget);

			const widgetToMove = container.widget;
			container.anotherWidget = container.widget;	// <-- action!

			assert.equal(container.anotherWidget, widgetToMove);
			assert.equal(container.widget, null);

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, [
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newParentId": container.id,
						"newParentPropertyName": "anotherWidget",
						"unitId": page.id
					}
				]);
				done();
			}, done);
		}, done);
	});

	it("should be possible to move from a non-listy property to a non-listy one in the same container, and back again (case 3(b)++)",
		done => {
		withPage0(page => {
			const container = page.widgets[0] as pages_simple.SingleContainer;
			assert.ok(container);
			assert.ok(container.widget);

			const widgetToMove = container.widget;
			container.anotherWidget = widgetToMove;	// <-- action!

			assert.equal(container.anotherWidget, widgetToMove);
			assert.equal(container.widget, null);

			container.widget = container.anotherWidget;	// <-- action!

			assert.equal(container.widget, widgetToMove, "container.widget == widgetToMove");
			assert.equal(container.anotherWidget, null, "container.anotherWidget == null");

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, [
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newParentId": container.id,
						"newParentPropertyName": "anotherWidget",
						"unitId": page.id
					},
					{
						"deltaType": "MOVE_ELEMENT",
						"elementId": widgetToMove.id,
						"newParentId": container.id,
						"newParentPropertyName": "widget",
						"unitId": page.id
					}
				]);
				done();
			}, done);
		}, done);
	});

	function testMove(fromIndex: number, toIndex: number) {
		it(`should be possible to move within a listy property (${fromIndex} -> ${toIndex})`, done => {
			withPage0(page => {
				const container = page.widgets[2] as pages_simple.MultiContainer;
				assert.equal(container.widgets.length, 3);
				const idsWidgets = () => container.widgets.map(widget => widget.id);
				const idsBefore = idsWidgets();

				container.widgets.move(fromIndex, toIndex);	// <-- action!

				const idsForMoving = observable(idsBefore.slice());
				idsForMoving.move(fromIndex, toIndex);
				assert.deepEqual(idsWidgets(), idsForMoving.slice());

				page.model.closeConnection(() => {
					// verify the deltas created during the process:
					const deltas = (page.model["_client"] as StubClient).deltas.slice();
					assert.deepEqual(deltas, [
						{
							"deltaType": "MOVE_ELEMENT",
							"elementId": idsBefore[fromIndex],
							"newParentId": container.id,
							"newParentPropertyName": "widgets",
							"newIndex": toIndex,
							"unitId": page.id
						}
					]);
					done();
				}, done);
			}, done);
		});
	}

	testMove(0, 1);
	testMove(0, 2);
	testMove(1, 2);
	testMove(2, 0);


	it("should be possible to self-/re-assign to a non-listy property",
		done => {
		withPage0(page => {
			const container = page.widgets[0] as pages_simple.SingleContainer;
			assert.ok(container);
			assert.ok(container.widget);

			const widgetToMove = container.widget;
			container.widget = widgetToMove;	// <-- action (self-assign)!

			assert.equal(container.widget, widgetToMove);

			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, []);
				done();
			}, done);
		}, done);
	});

	it("should be possible to idempotently splice a listy property",
		done => {
		withPage0(page => {
			assert.isTrue(page.widgets.length >= 2);
			// actions:
			page.widgets.splice(1, 1, page.widgets[1]);
			page.widgets.splice(0, 2, page.widgets[0], page.widgets[1]);
			page.model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (page.model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas, []);
				done();
			}, done);
		}, done);
	});

});
