

import {assert} from "chai";
import {promise} from "when";

import {pages, customwidgets, domainmodels, projects, IModel} from "../../index";

import {StubClient} from "../helpers/stub-model-client";
import {createSdkClient} from "../helpers/sdk-client-helper";
import {createSmallDomainModel} from "../helpers/small-domain-model-helper";
import {writeJson} from "../helpers/file-helper";


describe("update property values", () => {

	const client = createSdkClient();

	function createSmallPage(module: projects.IModule) {
		const page = pages.Page.createIn(module);
		const model = module.model;
		const widget = customwidgets.CustomWidget.create(model);
		const widgetType = widget.type = customwidgets.CustomWidgetType.create(model);
		const widgetObjectType = widgetType.objectType = customwidgets.WidgetObjectType.create(model);
		const widgetPropertyType = customwidgets.WidgetPropertyType.create(model);
		widgetObjectType.propertyTypes.push(widgetPropertyType);
		const valueType = widgetPropertyType.valueType = customwidgets.WidgetValueType.create(model);
		const argument = pages.LayoutCallArgument.create(model);
		argument.widget = widget;
		page.layoutCall.arguments.push(argument);
		return {
			page: page,
			valueType: valueType
		};
	}

	it("should create a custom widget property with enum properties", done => {
		client.openWorkingCopy("1", model => {
			const { page, valueType } = createSmallPage(model.allModules()[0]);

			valueType.attributeTypes.push(
				customwidgets.CustomWidgetAttributeType.Boolean,
				customwidgets.CustomWidgetAttributeType.String
			);

			model.closeConnection(() => {
				// verify the deltas created during the process:
				const deltas = (model["_client"] as StubClient).deltas.slice();
				assert.deepEqual(deltas.slice(20), [	// look only at last two ∂s
					{
						"unitId": page.id,
						"elementId": valueType.id,
						"deltaType": "UPDATE_PROPERTY_VALUE",
						"propertyName": "attributeTypes",
						"mutator": {
							"insertionIndex": 0,
							"value": "Boolean",
							"mutatorType": "ADD"
						}
					},
					{
						"unitId": page.id,
						"elementId": valueType.id,
						"deltaType": "UPDATE_PROPERTY_VALUE",
						"propertyName": "attributeTypes",
						"mutator": {
							"insertionIndex": 1,
							"value": "String",
							"mutatorType": "ADD"
						}
					}
				]);
				done();
			});
		}, done);
	});

	it("should not be possible to add a null value to a partlist", done => {
		client.openWorkingCopy("1", model => {
			const module = projects.Module.createIn(model.root);
			const domainModel = domainmodels.DomainModel.createIn(module);

			assert.throw(() => { domainModel.entities.push(null); }, "Null values cannot be added to property");
			done();
		}, done);
	});

	it("should not be possible to add the same object to a partlist twice", done => {
		client.openWorkingCopy("1", model => {
			const module = projects.Module.createIn(model.root);
			const domainModel = domainmodels.DomainModel.createIn(module);
			const entities = domainmodels.Entity.createIn(domainModel);

			assert.throw(
				() => {
					domainModel.entities.push(entities);
				},
				"was added more than once"
			);
			done();
		}, done);
	});

	it("should not allow unsetting non-nillable properties", done => {
		client.openWorkingCopy("1", model => {
			const domainModel = createSmallDomainModel(model.root);

			assert.throw(
				() => {
					const attribute = domainModel.entities[0].attributes[0];
					attribute.type = null;
				},
				"Cannot unset required part property"
			);
			assert.throw(
				() => {
					const association = domainModel.associations[0];
					association.parent = null;
				},
				"Cannot unset property"
			);
			assert.throw(
				() => {
					const crossAssociation = domainModel.crossAssociations[0];
					crossAssociation.child = null;
				},
				"Cannot unset required property"
			);
			assert.throw(
				() => {
					const association = domainModel.associations[0];
					association.deleteBehavior.parentDeleteBehavior = null;
				},
				"Cannot set parentDeleteBehavior to null"
			);
			assert.throw(
				() => {
					const association = domainModel.associations[0];
					association.name = null;
				},
				"Cannot set name to null"
			);

			model.closeConnection(done, done);

		}, done);
	});

	it("should not allow pushing null to a listy by-name reference", done => {
		client.openWorkingCopy("1", model => {
			const domainModel = createSmallDomainModel(model.root);

			const accessRule = domainmodels.AccessRule.create(model);
			domainModel.entities[0].accessRules.push(accessRule);

			assert.throw(
				() => {
					accessRule.moduleRoles.push(null);
				},
				"Cannot push null to moduleRoles"
			);

			model.closeConnection(done, done);

		}, done);
	});

	it("should not allow pushing null to a listy enumeration property", done => {
		client.openWorkingCopy("1", model => {
			const {valueType} = createSmallPage(model.allModules()[0]);

			assert.throw(
				() => {
					valueType.attributeTypes.push(null);
				},
				"Cannot push null to attributeTypes"
			);

			model.closeConnection(done, done);
		}, done);
	});

	it("should be possible to move elements to not existing element", done => {
		client.openWorkingCopy("1", model => {
			model.allDomainModels()[1].load(dm => {
				(model["_client"] as StubClient).deltas.splice(0);	// clear deltas

				const entOld = dm.entities[0];
				assert.isObject(entOld, "entity not found");
				const attr =  entOld.attributes[0];
				assert.isObject(attr, "attr not found");
				const attrCountPre = entOld.attributes.length;

				const entNew = domainmodels.Entity.create(dm.model);
				entNew.attributes.push(attr); // move attr, ent1 is still detached
				assert.equal(entOld.attributes.length, attrCountPre - 1);
				assert.equal(entNew.attributes.length, 1);
				assert.equal(attr.container, entNew);

				dm.entities.push(entNew); // notify server

				model.closeConnection(() => {
					const deltas = (model["_client"] as StubClient).deltas.slice();
					assert.deepEqual(deltas, [
						{
							"deltaType": "CREATE_ELEMENT",
							"elementId": entNew.id,
							"elementType": "DomainModels$Entity",
							"parentId": dm.id,
							"parentPropertyName": "entities",
							"unitId": dm.id
						},
						{
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"elementId": entNew.id,
							"mutator": {
							"mutatorType": "CHANGE",
							"value": entNew.dataStorageGuid
							},
							"propertyName": "dataStorageGuid",
							"unitId": dm.id
						},
						{
							"deltaType": "CREATE_ELEMENT",
							"elementId": entNew.generalization.id,
							"elementType": "DomainModels$NoGeneralization",
							"parentId": entNew.id,
							"parentPropertyName": "generalization",
							"unitId": dm.id
						},
						{
							"deltaType": "UPDATE_PROPERTY_VALUE",
							"elementId": entNew.generalization.id,
							"mutator": {
							"mutatorType": "CHANGE",
							"value": true
							},
							"propertyName": "persistable",
							"unitId": dm.id
						},
						{
							"deltaType": "MOVE_ELEMENT",
							"elementId": attr.id,
							"newIndex": 0,
							"newParentId": entNew.id,
							"newParentPropertyName": "attributes",
							"unitId": dm.id
						}
					]);
					done();
				}, done);
			});
		}, done);
	});
	/*
	 * This tests non-nillability of PrimitiveListProperty implicitly as EnumListProperty extends that.
	 */

	const openWorkingCopyAsPromise = (done): When.Promise<IModel> =>
		promise<IModel>((resolve, reject) => {
			client.openWorkingCopy("1", model => resolve(model), reject);
		});

	const closeConnectionAsPromise = (model: IModel): When.Promise<IModel> =>
		promise<IModel>((resolve, reject) => {
			model.closeConnection(() => resolve(model), reject);	// return 'model' for chaining
		});

	it("creation of Page should send the correct deltas for .title", done => {
		const title = "Page Title";
		openWorkingCopyAsPromise(done)
			.then(model => {
				const page = pages.Page.createIn(model.allModules()[0]);
				const text = page.title;
				assert.equal(text.translations.length, 1);
				assert.equal(text.translations[0].text, title);
				text.translations.clear();
				assert.equal(text.translations.length, 0);
				return closeConnectionAsPromise(model);
			})
			.then(model => {
				const deltas = (model["_client"] as StubClient).deltas;
				writeJson("Page-title-creation.json", deltas);

				const createTranslationsDeltas = deltas.filter(delta =>
					delta["deltaType"] === "CREATE_ELEMENT" && delta["elementType"] === "Texts$Translation"
				);
				assert.equal(createTranslationsDeltas.length, 2);
				const deleteDeltas = deltas.filter(delta => delta["deltaType"] === "DELETE_ELEMENT");
				assert.equal(deleteDeltas.length, 2, "replace should trigger delete ∂s");
					/*
					 *   1 for replacement of default value [Translation(text="", languageCode="en_US")] of Text
					 * + 1 for clearing the remaining 1 (new) translation.
					 */

				// TODO  check whether non-deleted Translation has a subsequent UPDATE_PROPERTY_VALUE delta with text="Page Title"
			})
			.then(done, done);
	});

});
