

import {assert} from "chai";

import {common} from "../test-index";
import {Version} from "../../sdk/internal/version-checks";
import {domainmodels_simple} from "../gen/domainmodels_simple";
import {withWarnFunc} from "../helpers/detection-helper";
import {utils} from "../../sdk/utils";
import {withEntity, withEntityLoaded, createSdkClient} from "../helpers/test-model-helper";

const toV = Version.parse;


describe("Versioning in test meta model", () => {

	it("should work for availability of structures", () => {
		const attributeAvailability = domainmodels_simple.OldAttribute.versionInfo.availability;

		assert.equal(attributeAvailability.isAvailableIn(toV("5.4.0")), false);
		assert.equal(attributeAvailability.isAvailableIn(toV("6.0.0")), false);
		assert.equal(attributeAvailability.isAvailableIn(toV("6.0.1")), true);
		assert.equal(attributeAvailability.isAvailableIn(toV("6.0.3")), true);
		assert.equal(attributeAvailability.isAvailableIn(toV("6.0.4")), true);
		assert.equal(attributeAvailability.isAvailableIn(toV("6.2.0")), false);
		assert.equal(attributeAvailability.isAvailableIn(toV("13.5.5")), false);

		assert.equal(attributeAvailability.isDeprecatedIn(toV("5.4.0")), false);
		assert.equal(attributeAvailability.isDeprecatedIn(toV("6.0.3")), false);
		assert.equal(attributeAvailability.isDeprecatedIn(toV("6.0.4")), true);
		assert.equal(attributeAvailability.isDeprecatedIn(toV("6.2.0")), false);
		assert.equal(attributeAvailability.isDeprecatedIn(toV("13.1.2")), false);

		assert.equal(attributeAvailability.isRemovedIn(toV("5.4.0")), false);
		assert.equal(attributeAvailability.isRemovedIn(toV("6.0.3")), false);
		assert.equal(attributeAvailability.isRemovedIn(toV("6.0.4")), false);
		assert.equal(attributeAvailability.isRemovedIn(toV("6.2.0")), true);
		assert.equal(attributeAvailability.isRemovedIn(toV("13.0.6")), true);
	});

	it("should work for availability of properties", () => {
		const attributesPropAvailability = domainmodels_simple.Entity.versionInfo.properties["oldAttributes"].availability;

		assert.equal(attributesPropAvailability.isAvailableIn(toV("5.4.0")), false);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("6.0.0")), false);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("6.0.1")), true);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("6.0.3")), true);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("6.0.4")), true);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("6.2.0")), false);
		assert.equal(attributesPropAvailability.isAvailableIn(toV("13.5.5")), false);

		assert.equal(attributesPropAvailability.isDeprecatedIn(toV("5.4.0")), false);
		assert.equal(attributesPropAvailability.isDeprecatedIn(toV("6.0.3")), false);
		assert.equal(attributesPropAvailability.isDeprecatedIn(toV("6.0.4")), true);
		assert.equal(attributesPropAvailability.isDeprecatedIn(toV("6.2.0")), false);
		assert.equal(attributesPropAvailability.isDeprecatedIn(toV("13.1.2")), false);

		assert.equal(attributesPropAvailability.isRemovedIn(toV("5.4.0")), false);
		assert.equal(attributesPropAvailability.isRemovedIn(toV("6.0.3")), false);
		assert.equal(attributesPropAvailability.isRemovedIn(toV("6.0.4")), false);
		assert.equal(attributesPropAvailability.isRemovedIn(toV("6.2.0")), true);
		assert.equal(attributesPropAvailability.isRemovedIn(toV("13.0.6")), true);
	});

	it("should work for modifiers of structures", () => {
		const superCoolElemVersionInfo = domainmodels_simple.SuperCoolElement.versionInfo;

		assert.equal(superCoolElemVersionInfo.isPublic.latestValue, false);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("0.0.0")), false);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("6.0.0")), false);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("6.0.1")), true);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("6.0.2")), true);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("6.0.4")), false);
		assert.equal(superCoolElemVersionInfo.isPublic.isEnabledIn(toV("13.4.4")), false);

		assert.equal(superCoolElemVersionInfo.isExperimental.latestValue, false);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("0.0.0")), false);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("6.0.0")), false);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("6.0.1")), true);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("6.0.2")), true);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("6.0.4")), false);
		assert.equal(superCoolElemVersionInfo.isExperimental.isEnabledIn(toV("13.4.4")), false);
	});

	it("should work for modifiers of properties", () => {
		const namePropertyVersionInfo = domainmodels_simple.Entity.versionInfo.properties["name"];

		assert.equal(namePropertyVersionInfo.isPublic.latestValue, true);
		assert.equal(namePropertyVersionInfo.isPublic.isEnabledIn(toV("1.0.0")), false);
		assert.equal(namePropertyVersionInfo.isPublic.isEnabledIn(toV("6.0.0")), false);
		assert.equal(namePropertyVersionInfo.isPublic.isEnabledIn(toV("6.0.1")), true);
		assert.equal(namePropertyVersionInfo.isPublic.isEnabledIn(toV("6.0.5")), true);
		assert.equal(namePropertyVersionInfo.isPublic.isEnabledIn(toV("13.0.5")), true);

		const typePropertyVersionInfo = domainmodels_simple.OldAttribute.versionInfo.properties["type"];

		assert.equal(typePropertyVersionInfo.isRequired.latestValue, true);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("1.0.0")), false);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("6.0.0")), false);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("6.0.1")), true);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("6.0.2")), false);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("6.0.3")), false);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("6.0.5")), true);
		assert.equal(typePropertyVersionInfo.isRequired.isEnabledIn(toV("13.0.5")), true);
	});

	function checkPublicProperty(done: common.IErrorCallback, forMxVersion: string, shouldThrow: boolean) {
		withEntity(forMxVersion, done, (entity, domainModel, model) => {
			function accessPublicProperty() {
				const justForAssignment = entity.newThing.myNewProp;
			}

			if (shouldThrow) {
				assert.throws(accessPublicProperty, "not fully loaded");
			} else {
				assert.doesNotThrow(accessPublicProperty);
			}
		});
	}

	it("should detect publicness of properties and structures", done => {
		checkPublicProperty(done, "6.0.5", true);
		checkPublicProperty(done, "6.0.6", false);
		done();
	});

	function checkRequiredProperty(done: common.IErrorCallback, forMxVersion: string, shouldThrow: boolean) {
		withEntityLoaded(forMxVersion, done, (entity, domainModel, model) => {
			function setPropToNull() {
				entity.newThing.myProp = null;
			}

			if (shouldThrow) {
				assert.throws(setPropToNull, "Cannot unset required part property");
			} else {
				assert.doesNotThrow(setPropToNull);
			}
		});
	}

	it("should detect requiredness of properties", done => {
		checkRequiredProperty(done, "6.0.5", false);
		checkRequiredProperty(done, "6.0.6", true);
		checkRequiredProperty(done, "6.0.7", false);
		checkRequiredProperty(done, "6.0.8", false);
		checkRequiredProperty(done, "6.0.9", true);
		done();
	});

	function checkExperimentalProperty(done: common.IErrorCallback, forMxVersion: string) {
		withEntityLoaded(forMxVersion, done, (entity) => {
			function accessExperimentalProperty() {
				const justForAssignment = entity.experimentalElemInModel;
			}

			withWarnFunc((warning: string) => {
				done(new Error("Logged warning, but shouldn't have: " + warning));
			}, accessExperimentalProperty);
		});
	}

	// experimentalness is in MxCore only available for Elements at the moment, not for properties
	it("should detect experimentalness on get", done => {
		checkExperimentalProperty(done, "6.0.5");
		checkExperimentalProperty(done, "6.0.6");
		checkExperimentalProperty(done, "6.0.7");
		checkExperimentalProperty(done, "6.0.8");
		checkExperimentalProperty(done, "6.0.9");
		done();
	});

	function checkExperimentalCreate(done: common.IErrorCallback, forMxVersion: string, shouldWarn: boolean) {
		withEntityLoaded(forMxVersion, done, (entity, domainModel, model) => {
			function createExperimenalElement() {
				const expElem = domainmodels_simple.ExperimentalElement.create(model);
				entity.experimentalElemNotInModel = expElem;
			}

			if (shouldWarn) {
				withWarnFunc((warning: string) => {
					assert.equal(
						warning,
						`Type 'DomainModels_simple$ExperimentalElement' is experimental in Mendix meta model version `
						+ `${forMxVersion} and should be used with care.`
					);
				}, createExperimenalElement);
			} else {
				withWarnFunc((warning: string) => {
					done(new Error("Logged warning, but shouldn't have: " + warning));
				}, createExperimenalElement);
			}
		});
	}

	it("should detect experimentalness on creation", done => {
		checkExperimentalCreate(done, "6.0.5", false);
		checkExperimentalCreate(done, "6.0.6", true);
		checkExperimentalCreate(done, "6.0.7", false);
		checkExperimentalCreate(done, "6.0.8", false);
		checkExperimentalCreate(done, "6.0.9", true);
		checkExperimentalCreate(done, "6.1.0", true);
		done();
	});

	it("should detect non-introducedness on open of wc", done => {
		assert.throws(() => {
			withEntity("5.0.0", done, () => {
				throw new Error("Should not be able to read a model with a property that does not exist yet in that Mendix version");
			});
		}, "Type 'DomainModels_simple$OldAttribute' is not yet available in Mendix version 5.0.0. It was introduced in Mendix version 6.0.1");
		done();
	});

	it("should detect introducedness on open of wc", done => {
		assert.doesNotThrow(() => {
			withEntity("6.0.4", done, () => { /* nop */ });
		});
		done();
	});

	it("should detect non-introducedness on open of wc", done => {
		assert.throws(() => {
			withEntity("6.0.0", done, () => { /* nop */ });
		}); // don't specify error-message, since the first missing item will throw an error, which can change over time
		done();
	});

	it("should detect introducedness on creation", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {
			assert.doesNotThrow(() => {
				domainmodels_simple.Attribute.createIn(entity);
			});
			done();
		});
	});

	it("should detect non-introducedness on creation", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {
			assert.throws(
				() => {
					entity.nonUsedElement = domainmodels_simple.VeryNewElement.create(model);
				},
				"Property 'nonUsedElement' of type 'DomainModels_simple$Entity' is not yet available in Mendix version 6.0.4. " +
				"It was introduced in Mendix version 6.0.5"
			);
			done();
		});
	});

	it("should detect temporary containment ambiguity on creation", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {
			assert.throws(
				() => {
					domainmodels_simple.VeryNewElement.createIn(entity);
				},
				`In Mendix version 6.0.4 it is illegal on instances of DomainModels_simple$VeryNewElement to call the "createIn" method, ` +
				`either because it's ambiguously contained or derived.`
			);
			done();
		});
	});

	it("should detect deprecation on get", done => {
		withEntity("6.0.4", done, (entity, domainModel, model) => {
			utils.resetAlreadyPrintedWarningsState();
			withWarnFunc(warning => {
				assert.equal(
					warning,
					"Property 'oldAttributes' of type 'DomainModels_simple$Entity' is deprecated in Mendix version 6.0.4 " +
					"(deprecated since Mendix version 6.0.4) and should no longer be instantiated: Use attributes instead"
				);
				done();
			}, () => {
				const justForAssignment = entity.attributes; // should trigger console.warn
				done();
			});
		});
	});

	it("should detect deprecation on creation", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {
			let isDone = false;
			utils.resetAlreadyPrintedWarningsState();
			withWarnFunc((warning) => {
				if (!isDone) {
					// should check isDone, because we get 2 warnings which are different. We only want to assert the first type at this moment
					assert.equal(
						warning,
						"Type 'DomainModels_simple$OldAttribute' is deprecated in Mendix version 6.0.4 " +
						"(deprecated since Mendix version 6.0.4) and should no longer be instantiated: Use Attribute instead"
					);
					isDone = true;
					done();
				}
			}, () => {
				domainmodels_simple.OldAttribute.createIn(entity); // should trigger console.warn
			});
		});
	});

	it("should not print same deprecation warning twice", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {
			const warnings = [];
			utils.resetAlreadyPrintedWarningsState();
			withWarnFunc((warning) => {
				warnings.push(warning);
			}, () => {
				for (let i = 0; i < 10; i++) {
					domainmodels_simple.OldAttribute.createIn(entity); // should trigger console.warn
				}
				assert.equal(warnings.length, 2); // got warning on both type and attributes?
				assert.deepEqual(warnings, [
					`Type 'DomainModels_simple$OldAttribute' is deprecated in Mendix version 6.0.4 ` +
					`(deprecated since Mendix version 6.0.4) and should no longer be instantiated: Use Attribute instead`,
					`Property 'oldAttributes' of type 'DomainModels_simple$Entity' is deprecated in Mendix version 6.0.4 ` +
					`(deprecated since Mendix version 6.0.4) and should no longer be instantiated: Use attributes instead`
				]);
				done();
			});
		});
	});

	it("should detect deletion", done => {
		assert.throws(() => {
			withEntity("6.2.0", done, () => {
				throw new Error("Should not be able to read a model with a property that no longer exists in that Mendix version");
			});
		}, "Type 'DomainModels_simple$OldAttribute' can no longer be instantiated in Mendix version 6.2.0 " +
		"(removed since Mendix version 6.2.0): Attribute is superior.");
		assert.throws(() => {
			withEntity("16.0.5", done, () => {
				throw new Error("Should not be able to read a model with a property that no longer exists in that Mendix version");
			});
		}, "Type 'DomainModels_simple$OldAttribute' can no longer be instantiated in Mendix version 16.0.5 "
		+ "(removed since Mendix version 6.2.0): Attribute is superior.");
		done();
	});

	it("should detect property availability 1", done => {
		createSdkClient("6.0.4").openWorkingCopy("1", (model) => {
			model.metaModelVersion = new Version(6, 2, 0); // MWE: Bwegh!
			const entity = domainmodels_simple.Entity.create(model);
			assert.equal((entity as any).__attributes.isAvailable, true);
			assert.equal((entity as any).__oldAttributes.isAvailable, false);
			assert.equal(entity.allProperties().filter(prop => prop.name === "attributes").length, 1);
			assert.equal(entity.allProperties().filter(prop => prop.name === "oldAttributes").length, 0);
			done();
		}, done);
	});

});
