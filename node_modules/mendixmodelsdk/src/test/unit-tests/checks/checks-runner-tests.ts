import {assert} from "chai";

import {runChecksOn} from "../../../sdk/checks/checks-runner";

import {testQueryResolver, testChecksResolver} from "./test-metadata-loaders";
import {createSdkClient, withEntityLoaded} from "../../helpers/test-model-helper";


describe("checks runner", () => {

	it("should be able to run all test checks and respect check levels (without interference across groups)", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {	// (ignore warnings issued)

			const issues = runChecksOn(domainModel, testChecksResolver, testQueryResolver);
			assert.isTrue(issues.length >= 5, "number of issues");	// (also effectively asserted by rest of test)

			const issuesByCheckName = (checkName: string) => issues.filter(issue => issue.checkName === checkName);

			const listyNameIssue = issuesByCheckName("NonTrivialListyCheckWithLetAndMessageArgument")[0];
			assert.ok(listyNameIssue);
			assert.equal(listyNameIssue.severity, "ERROR");
			assert.equal(listyNameIssue.structure, entity.oldAttributes[0]);
			assert.equal(
				listyNameIssue.message,
				`attribute '${entity.oldAttributes[0].name}' should be named 'foo' within domain model 'MyAwesomeSimplifiedDomainModel'`
			);

			const issueWithLetParametrizedMessage = issuesByCheckName("CheckUsingMessageArgument")[0];
			assert.ok(issueWithLetParametrizedMessage);
			assert.equal(issueWithLetParametrizedMessage.message, "CheckUsingMessageArgument: foo=bar");

			assert.isTrue(issuesByCheckName("SimpleCheck").length === 1);

			assert.isTrue(issuesByCheckName("AlwaysFiresLevel0").length > 0, "AlwaysFiresLevel0");

			function assertHasIssuesNamed(checkName: string, expectedToHaveIssues = true) {
				const nIssues = issuesByCheckName(checkName).length;
				assert.isTrue(expectedToHaveIssues ? nIssues > 0 : nIssues === 0, checkName);
			}

			// asserts on "standard" check levels:
			assertHasIssuesNamed("NeverFiresLevel1Standard", false);
				// no issues of level 1...
			assertHasIssuesNamed("AlwaysFiresLevel2Standard");
				// ...so level 2 can run (despite level 0 also having produced issues), but produces issues...
			assertHasIssuesNamed("AlwaysFiresButShouldNeverBeRunLevel3Standard", false);
				// ...so level 3 doesn't run and produce issues
			assertHasIssuesNamed("AlwaysFiresButShouldNeverBeRunLevel4Standard", false);
				// ...and likewise for level 4

			// asserts on "secret" check levels:
			assertHasIssuesNamed("AlwaysFiresLevel1Secret");
				// runs and produces issues despite level 0 having issues

			// asserts on "special"" check levels:
			assertHasIssuesNamed("AlwaysFiresLevel3Special");
				// runs and produces issues despite level 2 of "standard" group producing issues

			done();
		});
	});

	it("should report unresolved by-name references", done => {
		createSdkClient("6.0.4").openWorkingCopy("1", model => {
			(model.allNavigations()[0]).load(navigation => {
				const issues = runChecksOn(navigation, testChecksResolver, testQueryResolver);
				assert.deepEqual(issues, [
					{
						"structure": navigation,
						"message": "Failed to resolve reference. There is no [Page] with this [UnresolvableByNameReference]. "
							+ "Please select an existing [Page]",
						"severity": "error",
						"incorrectProperty": "homePage",
						"checkName": "UnresolvedByNameReference (generic)"
					}
				]);	// Note: this also checks that resolvable references (like `awayPage`) are not reported.
				done();
			}, false);
		}, done);
	});

});

