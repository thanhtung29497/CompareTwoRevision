

import {standardLibraryMethods, StructureTypeLiteral} from "../../../sdk/checks/standard-library-methods";

import {assert} from "chai";
import {range} from "lodash";
import {readJson} from "../../helpers/file-helper";
import {assertValidateName} from "./name-validation-checks";

import {withEntityLoaded} from "../../helpers/test-model-helper";
import {domainmodels_simple} from "../../gen/domainmodels_simple";
import {testmodel} from "../../gen/testmodel";


describe("methods in the standard library", () => {

	const stl = (clazz: any) => new StructureTypeLiteral(clazz);

	const entityType = stl(domainmodels_simple.Entity);
	const domainModelType = stl(domainmodels_simple.DomainModel);
	const oldAttributeType = stl(domainmodels_simple.OldAttribute);
	const attributeType = stl(domainmodels_simple.Attribute);

	it("asType", done => {
		const asType = standardLibraryMethods["asType"];
		assert.equal(asType(undefined, []), undefined);
		assert.equal(asType(undefined, [undefined]), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(asType(entity, ["bar"]), undefined);
			assert.equal(asType(entity, [entityType]), entity);
			assert.equal(asType(entity, [attributeType]), undefined);
			done();
		});
	});

	it("concat", () => {
		const concat = standardLibraryMethods["concat"];
		assert.equal(concat(undefined, []), undefined);
		assert.equal(concat("foo", [[]]), undefined);
		assert.deepEqual(concat(range(3), [[3, 4]]), range(5));
		assert.deepEqual(concat(range(10), [[]]), range(10));
		assert.equal(concat(range(4), [undefined]), undefined);
		assert.equal(concat(range(4), ["foo"]), undefined);
	});

	it("container", done => {
		const container = standardLibraryMethods["container"];
		assert.equal(container(undefined, []), undefined);
		assert.equal(container("foo", []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(container(entity, []), domainModel);
			const project = container(domainModel, []);
			assert.isTrue(project instanceof testmodel.Project);
			assert.isNull(container(project, []));	// no infinite loop
			done();
		});
	});

	it("containerAs", done => {
		const containerAs = standardLibraryMethods["containerAs"];
		assert.equal(containerAs(undefined, []), undefined);
		assert.equal(containerAs("foo", [entityType]), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(containerAs(entity, ["foo"]), undefined);
			assert.equal(containerAs(entity, [domainModelType]), domainModel);
			assert.equal(containerAs(entity, [oldAttributeType]), undefined);
			done();
		});
	});

	it("contains", () => {
		const contains = standardLibraryMethods["contains"];
		assert.equal(contains(undefined, undefined), undefined);
		assert.equal(contains("foo", undefined), undefined);
		assert.equal(contains(["foo"], []), undefined);
		assert.equal(contains(["foo"], ["bar"]), false);
		assert.equal(contains(["foo", "bar"], ["bar"]), true);
	});

	it("isDefined", () => {
		const isDefined = standardLibraryMethods["isDefined"];
		assert.equal(isDefined(undefined, []), false);
		assert.equal(isDefined(null, []), false);
		assert.equal(isDefined("", []), true);
		assert.equal(isDefined("foo", []), true);
		assert.equal(isDefined([], []), true);
		assert.equal(isDefined([1, 2, 3], []), true);
	});

	it("isEmpty", () => {
		const isEmpty = standardLibraryMethods["isEmpty"];
		assert.equal(isEmpty(undefined, []), undefined);
		assert.equal(isEmpty(null, []), undefined);
		assert.equal(isEmpty("foo", []), undefined);
		assert.equal(isEmpty([], []), true);
		assert.equal(isEmpty([1, 2, 3], []), false);
	});

	it("isEmptyOrUndefined", () => {
		const isEmptyOrUndefined = standardLibraryMethods["isEmptyOrUndefined"];
		assert.equal(isEmptyOrUndefined(undefined, []), true);
		assert.equal(isEmptyOrUndefined(null, []), true);
		assert.equal(isEmptyOrUndefined("foo", []), undefined);
		assert.equal(isEmptyOrUndefined([], []), true);
		assert.equal(isEmptyOrUndefined([1, 2, 3], []), false);
	});

	it("isOfType", done => {
		const isOfType = standardLibraryMethods["isOfType"];
		assert.equal(isOfType(undefined, []), undefined);
		assert.equal(isOfType(undefined, [undefined]), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(isOfType(entity, ["bar"]), undefined);
			assert.equal(isOfType(entity, [entityType]), true);
			assert.equal(isOfType(entity.oldAttributes[0], [oldAttributeType]), true);
			assert.equal(isOfType(entity, [domainModelType]), false);
			done();
		});
	});

	it("isUndefined", () => {
		const isUndefined = standardLibraryMethods["isUndefined"];
		assert.equal(isUndefined(undefined, []), true);
		assert.equal(isUndefined(null, []), true);
		assert.equal(isUndefined("foo", []), false);
	});

	it("firstContainerOfType", done => {
		const firstContainerOfType = standardLibraryMethods["firstContainerOfType"];
		assert.equal(firstContainerOfType(undefined, []), undefined);
		assert.equal(firstContainerOfType("foo", []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(firstContainerOfType(entity, [entityType]), undefined);	// (do not find yourself)
			assert.equal(firstContainerOfType(entity, [domainModelType]), domainModel);
			assert.equal(firstContainerOfType(entity, [oldAttributeType]), undefined);
			assert.equal(firstContainerOfType(entity.oldAttributes[0], [domainModelType]), domainModel);
			done();
		});
	});

	it("firstContainerOfTypes", done => {
		const firstContainerOfTypes = standardLibraryMethods["firstContainerOfTypes"];
		assert.equal(firstContainerOfTypes(undefined, []), undefined);
		assert.equal(firstContainerOfTypes("foo", []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(firstContainerOfTypes(entity, []), undefined);
			assert.equal(firstContainerOfTypes(entity, [undefined, undefined]), undefined);
			assert.equal(firstContainerOfTypes(entity, [domainModelType]), domainModel);
			assert.equal(firstContainerOfTypes(entity, [undefined, domainModelType]), domainModel);
			assert.equal(firstContainerOfTypes(entity, [oldAttributeType]), undefined);
			done();
		});
	});

	it("flatten", () => {
		const flatten = standardLibraryMethods["flatten"];
		assert.equal(flatten(undefined, []), undefined);
		assert.deepEqual(flatten([[[]]], []), [[]]);
		assert.deepEqual(flatten([[1, 2, 3], [3, 4]], []), [1, 2, 3, 3, 4]);
	});

	it("get", () => {
		const get = standardLibraryMethods["get"];
		const n = 4;
		const list = range(n).map(i => i + 1);
		assert.equal(get(undefined, [1]), undefined);
		assert.equal(get(list, []), undefined);
		assert.equal(get(list, [0]), undefined);
		assert.equal(get(list, [-42]), undefined);
		assert.equal(get(list, [n + 1]), undefined);
		assert.deepEqual(list.map(i => get(list, [i])), list);
		assert.equal(get(list, [Math.PI]), undefined);
	});

	it("hasDuplicates", () => {
		const hasDuplicates = standardLibraryMethods["hasDuplicates"];
		assert.equal(hasDuplicates(undefined, []), undefined);
		assert.equal(hasDuplicates("foo", []), undefined);
		assert.equal(hasDuplicates([], []), false);
		assert.equal(hasDuplicates([1, 2], []), false);
		assert.equal(hasDuplicates([1, 2, 1], []), true);
	});

	it("last", () => {
		const last = standardLibraryMethods["last"];
		assert.equal(last(undefined, []), undefined);
		assert.equal(last([], []), undefined);
		const n = 4;
		assert.equal(last(range(n), []), n - 1);
	});

	it("length", () => {
		const length = standardLibraryMethods["length"];
		assert.equal(length(undefined, []), undefined);
		assert.equal(length([], []), 0);
		const n = 4;
		assert.equal(length(range(n), []), n);
	});

	it("modelUnit", done => {
		const modelUnit = standardLibraryMethods["modelUnit"];
		assert.equal(modelUnit(undefined, []), undefined);
		assert.equal(modelUnit(["foo"], []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.deepEqual(modelUnit(entity, []), domainModel);
			assert.deepEqual(modelUnit(domainModel, []), domainModel);
			done();
		});
	});

	it("notEmpty", () => {
		const notEmpty = standardLibraryMethods["notEmpty"];
		assert.equal(notEmpty(undefined, []), undefined);
		assert.equal(notEmpty(null, []), undefined);
		assert.equal(notEmpty("foo", []), undefined);
		assert.equal(notEmpty([], []), false);
		assert.equal(notEmpty([1, 2, 3], []), true);
	});

	it("parts", done => {
		const parts = standardLibraryMethods["parts"];
		assert.deepEqual(parts(undefined, []), []);
		assert.deepEqual(parts(null, []), []);
		assert.equal(parts("foo", []), undefined);
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const idParts = parts(domainModel, []).map(part => part.id);
			assert.sameMembers(
				idParts,
				[
					"48345255-c0be-4304-803b-1e53c658eb93",		// entity "ExpenseType"
					"b636b8b7-76c9-4aa3-9ff0-253380501cc9",		// oldAttribute "Name"
					"1ca633fd-1562-5914-8deb-74c9698f33ab",		// oldAttribute type string(200)
					"acfe6c11-5a78-498f-b9ee-cbc996c7d9ca",		// attribute "Name2"
					"82d1a8f8-6952-48bf-9d2e-75d38bdd53b8",		// super cool element
					"d6b63541-ddd1-441e-be1b-a71d68136470",		// new thing/element
					"6cf5c693-03a7-44bc-a025-3b99e704a704",		// new prop/element
					"fd3af4bb-726b-4848-a0b7-08bae2545c2c"		// experimental element
				]
			);
			done();
		});
	});

	it("partsOfType", done => {
		const partsOfType = standardLibraryMethods["partsOfType"];
		assert.deepEqual(partsOfType(undefined, []), []);
		assert.deepEqual(partsOfType(null, []), []);
		assert.equal(partsOfType("foo", []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)

			assert.equal(partsOfType(domainModel, []), undefined);
			assert.equal(partsOfType(domainModel, [undefined]), undefined);
			assert.equal(partsOfType(domainModel, [null]), undefined);
			assert.equal(partsOfType(domainModel, ["bar"]), undefined);

			const idParts = partsOfType(domainModel, [oldAttributeType]).map(part => part.id);
			assert.sameMembers(idParts, [ "b636b8b7-76c9-4aa3-9ff0-253380501cc9" ]);

			assert.deepEqual(partsOfType(domainModel, [stl(domainmodels_simple.IntegerAttributeType)]), []);

			done();
		});
	});

	it("qualifiedName", done => {
		const qualifiedName = standardLibraryMethods["qualifiedName"];
		assert.equal(qualifiedName(undefined, []), undefined);
		assert.equal(qualifiedName("foo", []), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(qualifiedName(domainModel, []), "MyAwesomeSimplifiedDomainModel");
			assert.equal(qualifiedName(entity, []), "MyAwesomeSimplifiedDomainModel.ExpenseType");
			done();
		});
	});

	it("toLowerCase", () => {
		const toLowerCase = standardLibraryMethods["toLowerCase"];
		assert.equal(toLowerCase(undefined, []), undefined);
		assert.equal(toLowerCase("foo", []), "foo");
		assert.equal(toLowerCase("BAR123?", []), "bar123?");
	});

	it("typeFilter", done => {
		const typeFilter = standardLibraryMethods["typeFilter"];
		assert.equal(typeFilter(undefined, []), undefined);
		assert.equal(typeFilter(undefined, [undefined]), undefined);
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.deepEqual(typeFilter([entity], [entityType]), [entity]);
			assert.deepEqual(typeFilter([entity], [attributeType]), []);
			assert.equal(typeFilter([entity], ["bar"]), undefined);
			done();
		});
	});

	it("startsWith", () => {
		const startsWith = standardLibraryMethods["startsWith"];
		assert.equal(startsWith(undefined, []), undefined);
		assert.equal(startsWith("foo", []), undefined);
		assert.equal(startsWith("abcda", ["a"]), true);
		assert.equal(startsWith("abcda", ["bcd"]), false);
		assert.equal(startsWith("abcda", ["e"]), false);
		assert.equal(startsWith("abcda", ["abcde"]), false);
	});

	it("validateName (no-args)", () => {
		assertValidateName(standardLibraryMethods["validateName"]);
	});


	it("should match with the declarations in MxCore", () => {
		const declaredStandardLibraryMethods = readJson<string[]>("src/gen/declared-standard-library-methods.json");

		let match = true;
		for (let methodName of declaredStandardLibraryMethods) {
			if (!standardLibraryMethods[methodName]) {
				match = false;
				console.error(`standard library method '${methodName}' is declared in MxCore but not defined in the Model SDK`);
			}
		}
		for (let methodName in standardLibraryMethods) {
			if (declaredStandardLibraryMethods.indexOf(methodName) < 0) {
				match = false;
				console.error(`standard library method '${methodName}' is defined in the Model SDK but not declared in MxCore`);
			}
		}

		assert.isTrue(match, "MxCore declarations of standard library methods do not match with definitions in MxCore (purely name-wise)");
	});

});
