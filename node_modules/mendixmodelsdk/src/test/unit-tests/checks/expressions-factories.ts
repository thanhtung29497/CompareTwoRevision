import {expressionsTypes as expressions} from "../../../gen/expressions-types";


export function mkBinaryExpr(left: expressions.MxExpression, operator: expressions.MxOperator, right: expressions.MxExpression)
: expressions.MxBinaryExpression {
	return {
		$type: "MxBinaryExpression",
		left: left,
		operator: operator,
		right: right,
		appliedFeature: null
	};
};

function mkBooleanLiteral(value: boolean): expressions.MxBooleanLiteralExpression {
	return { $type: "MxBooleanLiteralExpression", value: value, appliedFeature: null };
};
export const trueExpr = mkBooleanLiteral(true);
export const falseExpr = mkBooleanLiteral(false);

export function mkFeatureCallWrapper(featureCall: expressions.MxFeatureCall, appliedFeature: expressions.MxFeatureCallWrapper = null)
: expressions.MxFeatureCallWrapper {
	return {
		$type: "MxFeatureCallWrapper",
		featureCall: featureCall,
		appliedFeature: appliedFeature
	};
}
/** Alias for mkFeatureCallWrapper. */
export const wrap = mkFeatureCallWrapper;

export function mkFollow(variableName: string, path: expressions.MxExpression, including: boolean): expressions.MxAbstractFollow {
	return {
		$type: `MxFollow${including ? "In" : "Ex"}cluding`,
		variable: {
			$type: "MxBuiltInVariableDeclaration",
			name: variableName
		} as expressions.MxBuiltInVariableDeclaration,
		path: path
	};
}

export function mkIteratorCall(type: expressions.MxIteratorType, iteratorVariableName: string, body: expressions.MxExpression)
: expressions.MxIteratorCall {
	return {
		$type: "MxIteratorCall",
		type: type,
		variable: mkIteratorVariable(iteratorVariableName),
		body: body
	};
}

function mkIteratorVariable(variableName: string): expressions.MxIteratorVariableDeclaration {
	return {
		$type: "MxIteratorVariableDeclaration",
		name: variableName
	};
}

export function mkMethodCall(referredMethod: string): expressions.MxMethodCall {
	return {
		$type: "MxMethodCall",
		referredMethod: referredMethod,
		arguments: []
	};
}

export function mkPrefixExpression(expr: expressions.MxExpression): expressions.MxPrefixExpression {
	return { $type: "MxPrefixExpression", expression: expr, appliedFeature: null };
}

export function mkPreviousExpr(
	variable: expressions.MxVariableRefExpression, appliedFeature: expressions.MxFeatureCallWrapper = null
): expressions.MxPreviousExpression {
	return apply<expressions.MxPreviousExpression>(
		{
			$type: "MxPreviousExpression",
			variable: variable
		},
		appliedFeature
	);
}

export function mkPropertyCall(referredProperty: string): expressions.MxPropertyCall {
	return {
		$type: "MxPropertyCall",
		referredProperty: referredProperty
	};
}

export function mkStringLiteral(str: string): expressions.MxStringLiteralExpression {
	return { $type: "MxStringLiteralExpression", value: str, appliedFeature: null };
};

export function thisExpr(appliedFeature: expressions.MxFeatureCallWrapper = null): expressions.MxThisExpression {
	return apply<expressions.MxThisExpression>({ $type: "MxThisExpression" }, appliedFeature);
}

export const undefinedExpr: expressions.MxUndefinedExpression = { $type: "MxUndefinedExpression", appliedFeature: null };

export function mkVariableRef(
	referredVariable: string, appliedFeature: expressions.MxFeatureCallWrapper = null
): expressions.MxVariableRefExpression {
	return apply<expressions.MxVariableRefExpression>(
		{ $type: "MxVariableRefExpression", referredVariable: referredVariable },
		appliedFeature
	);
}


/**
 * Wraps a chain of MxFeatureCall-s in the required way in MxFeatureCallWrapper-s.
 * (Essentially: foldRight(featureCalls)(wrap(_, _)) :))
 */
export function chain(...featureCalls: expressions.MxFeatureCall[]): expressions.MxFeatureCallWrapper {
	return featureCalls.length <= 1
		? wrap(featureCalls[0])
		: wrap(featureCalls[0], chain(...featureCalls.slice(1)));
}


function apply<T extends expressions.MxExpression>(expr: Object, appliedFeature: expressions.MxFeatureCallWrapper): T {
	expr["appliedFeature"] = appliedFeature;
	return expr as T;
}

