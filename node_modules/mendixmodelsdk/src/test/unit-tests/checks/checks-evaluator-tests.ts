import {assert} from "chai";

import {evaluateCheck, calculateMessage} from "../../../sdk/checks/checks-evaluator";
import {expressionsTypes as expressions} from "../../../gen/expressions-types";
import {domainmodels_simple} from "../../gen/domainmodels_simple";
import {lookupByVersion} from "../../../sdk/checks/versioning";

import {testQueryResolver, testChecks} from "./test-metadata-loaders";
import {withEntityLoaded} from "../../helpers/test-model-helper";


describe("checks evaluator", () => {

	const nameListyCheck = "NonTrivialListyCheckWithLetAndMessageArgument";

	it("should be able to evaluate all test checks", done => {
		withEntityLoaded("6.0.4", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const checkConditionTypes = testChecks
				.map(check => lookupByVersion(check.versionCheckBodies, model.metaModelVersion))
				.map(body => body.checkCondition.$type);
			assert.isTrue(checkConditionTypes.indexOf("MxCheckConditionForBoolean") > -1);
			assert.isTrue(checkConditionTypes.indexOf("MxCheckConditionForList") > -1);
			let seenListyCheck = false;
			for (let check of testChecks) {
				// just check whether it doesn't crash at first:
				const issues = (check => {	// using this construct to avoid fall-through issues
					switch (check.structure) {
						case "DomainModels_simple$Entity": return evaluateCheck(check, entity, testQueryResolver);
						case "DomainModels_simple$DomainModel": return evaluateCheck(check, domainModel, testQueryResolver);
						case "DomainModels_simple$OldAttribute": return evaluateCheck(check, entity.oldAttributes[0], testQueryResolver);
						default:
							throw new Error(`don't know what instance to evaluate check on - expected type: ${check.structure}`);
					}
				})(check);
				if (check.name === nameListyCheck) {
					seenListyCheck = true;
					assert.isTrue(issues.every(issue => issue.structure instanceof domainmodels_simple.OldAttribute));
				}
				if (check.name === "NoCycles") {
					assert.isTrue(issues.length === 1);
				}
			}
			assert.isTrue(seenListyCheck, `haven't seen issues stemming from '${nameListyCheck}'`);
			done();
		});
	});

});


describe("checks message calculator", () => {

	it("should replace placeholders with evaluated arguments", () => {
		const message = calculateMessage(
			null,
			{
				text: "1st argument: {0},\n2nd argument: {1}.",
				arguments: [
					{ $type: "MxStringLiteralExpression", value: "first" } as expressions.MxStringLiteralExpression,
					{ $type: "MxStringLiteralExpression", value: "second" } as expressions.MxStringLiteralExpression
				]
			},
			(queryName: string, qualifiedStructureName: string) => undefined
		);
		assert.equal(message, "1st argument: first,\n2nd argument: second.");
	});

});

