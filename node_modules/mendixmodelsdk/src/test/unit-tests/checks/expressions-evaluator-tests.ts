

import {expressionsTypes as expressions} from "../../../gen/expressions-types";
import {evaluateExpression} from "../../../sdk/checks/expressions-evaluator";
import {StructureTypeLiteral} from "../../../sdk/checks/standard-library-methods";

import {assert} from "chai";
import {range} from "lodash";

import {withEntityLoaded} from "../../helpers/test-model-helper";
import {domainmodels_simple} from "../../gen/domainmodels_simple";
import {mkBinaryExpr, trueExpr, falseExpr,
		wrap, mkFollow, mkIteratorCall, mkMethodCall, mkPrefixExpression, mkPreviousExpr, mkPropertyCall,
		mkStringLiteral, thisExpr,  undefinedExpr, mkVariableRef,
		chain} from "./expressions-factories";
import {augmentWithSimpleEntities} from "./simple-entities-helper";
import {Structure} from "../../../sdk/internal/structures";
import {testQueryResolver, testQueries} from "./test-metadata-loaders";


describe("expressions evaluator should be able to evaluate", () => {

	const evaluateWithTestQueries = (expr: expressions.MxExpression, structure: Structure) =>
		evaluateExpression(expr, structure, testQueryResolver);

	const evaluateWithNullThis = (expr: expressions.MxExpression) => evaluateWithTestQueries(expr, null);

	function assertEvalWithNullThis(expr: expressions.MxExpression, expected: any) {
		assert.deepEqual(evaluateWithNullThis(expr), expected);
	}


	it("a binary expression with faulty data", () => {
		assert.throws(
			() => {
				evaluateWithNullThis(mkBinaryExpr(null, "NONE", null));
			},
			"sentinel value of MxOperator not allowed in runtime"
		);
	});

	it("a binary expression with undefined data", () => {
		function testBinaryExprWithUndefineds(operator: expressions.MxOperator, expected: boolean | void) {
			assertEvalWithNullThis(mkBinaryExpr(undefinedExpr, operator, trueExpr), expected);
			assertEvalWithNullThis(mkBinaryExpr(trueExpr, operator, undefinedExpr), expected);
			assertEvalWithNullThis(mkBinaryExpr(undefinedExpr, operator, undefinedExpr), expected);
		}

		testBinaryExprWithUndefineds("EQUALS", false);
		testBinaryExprWithUndefineds("LESS", false);
		testBinaryExprWithUndefineds("LESS_OR_EQUALS", false);
		testBinaryExprWithUndefineds("GREATER", false);
		testBinaryExprWithUndefineds("GREATER_OR_EQUALS", false);
		testBinaryExprWithUndefineds("UNEQUALS", true);
		testBinaryExprWithUndefineds("AND", undefined);

		assertEvalWithNullThis(mkBinaryExpr(undefinedExpr, "OR", trueExpr), true);
		assertEvalWithNullThis(mkBinaryExpr(trueExpr, "OR", undefinedExpr), true);
		assertEvalWithNullThis(mkBinaryExpr(undefinedExpr, "OR", falseExpr), false);
		assertEvalWithNullThis(mkBinaryExpr(falseExpr, "OR", undefinedExpr), false);
		assertEvalWithNullThis(mkBinaryExpr(undefinedExpr, "OR", undefinedExpr), false);
	});

	it("a binary expression with valid data", () => {
		const foo = mkStringLiteral("foo");
		const bar = mkStringLiteral("bar");
		const theAnswer: expressions.MxIntegerLiteralExpression = { $type: "MxIntegerLiteralExpression", value: 42, appliedFeature: null };

		assertEvalWithNullThis(mkBinaryExpr(foo, "EQUALS", foo), true);
		assertEvalWithNullThis(mkBinaryExpr(foo, "EQUALS", bar), false);
		assertEvalWithNullThis(mkBinaryExpr(theAnswer, "EQUALS", bar), false);

		assertEvalWithNullThis(mkBinaryExpr(foo, "LESS", bar), false);
		assertEvalWithNullThis(mkBinaryExpr(foo, "LESS", foo), false);
		assertEvalWithNullThis(mkBinaryExpr(bar, "LESS", foo), true);

		assertEvalWithNullThis(mkBinaryExpr(foo, "LESS_OR_EQUALS", bar), false);
		assertEvalWithNullThis(mkBinaryExpr(foo, "LESS_OR_EQUALS", foo), true);
		assertEvalWithNullThis(mkBinaryExpr(bar, "LESS_OR_EQUALS", foo), true);

		assertEvalWithNullThis(mkBinaryExpr(foo, "GREATER", bar), true);
		assertEvalWithNullThis(mkBinaryExpr(foo, "GREATER", foo), false);
		assertEvalWithNullThis(mkBinaryExpr(bar, "GREATER", foo), false);

		assertEvalWithNullThis(mkBinaryExpr(foo, "GREATER_OR_EQUALS", bar), true);
		assertEvalWithNullThis(mkBinaryExpr(foo, "GREATER_OR_EQUALS", foo), true);
		assertEvalWithNullThis(mkBinaryExpr(bar, "GREATER_OR_EQUALS", foo), false);

		assertEvalWithNullThis(mkBinaryExpr(foo, "UNEQUALS", foo), false);
		assertEvalWithNullThis(mkBinaryExpr(foo, "UNEQUALS", bar), true);
		assertEvalWithNullThis(mkBinaryExpr(theAnswer, "UNEQUALS", bar), true);

		assertEvalWithNullThis(mkBinaryExpr(trueExpr, "AND", falseExpr), false);
		assertEvalWithNullThis(mkBinaryExpr(trueExpr, "AND", trueExpr), true);

		assertEvalWithNullThis(mkBinaryExpr(falseExpr, "OR", trueExpr), true);
		assertEvalWithNullThis(mkBinaryExpr(falseExpr, "OR", falseExpr), false);
	});

	it("a boolean literal expression", () => {
		assertEvalWithNullThis(trueExpr, true);
		assertEvalWithNullThis(falseExpr, false);
	});

	it("a color literal expression", () => {
		assertEvalWithNullThis(
			{ $type: "MxColorLiteralExpression", red: 100, green: 150, blue: 200 } as expressions.MxColorLiteralExpression,
			{ red: 100, green: 150, blue: 200 }
		);
	});

	it("a double literal expression", () => {
		assertEvalWithNullThis(
			{ $type: "MxDoubleLiteralExpression", value: Math.PI } as expressions.MxDoubleLiteralExpression,
			Math.PI
		);
	});

	// MxFeatureCallWrapper is already implicitly tested in all feature call expressions unit tests

	function makeTester(expr: expressions.MxExpression, domainModel: domainmodels_simple.DomainModel) {
		const simpleEntities = augmentWithSimpleEntities(domainModel);
		return (sourceEntityName: string, expectedResultEntityNames: string[], optionalMessage?: string) => {
			assert.deepEqual(
				evaluateWithTestQueries(expr, simpleEntities[sourceEntityName]).map(entity => entity.name),
				expectedResultEntityNames,
				optionalMessage
			);
		};
	}

	it("a followExcl expression", done => {
		const expr = thisExpr(wrap(	// "this."...
			mkFollow("e", wrap(mkVariableRef("e", wrap(mkPropertyCall("generalization")))), false)	// ...".followExcl[ e | e.generalization ]"
		));

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(evaluateWithTestQueries(expr, undefined), undefined);
			assert.equal(evaluateWithTestQueries(expr, null), undefined);

			const testWith = makeTester(expr, domainModel);
			testWith("NonInheriting", []);
			testWith("ANotInCycle", ["BNotInCycle", "CNotInCycle", "DNotInCycle"]);
			testWith("AInCycle", ["BInCycle", "CInCycle", "AInCycle"], "cycle detection");
			testWith("AlphaBeforeCycle", ["OmegaBeforeCycle", "AInCycle", "BInCycle", "CInCycle", "AInCycle"], "do not loop on \rho's");

			done();
		});
	});

	it("a followIncl expression", done => {
		const expr = thisExpr(wrap(	// "this."...
			mkFollow("e", wrap(mkVariableRef("e", wrap(mkPropertyCall("generalization")))), true)	// ...".followIncl[ e | e.generalization ]"
		));

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			assert.equal(evaluateWithTestQueries(expr, undefined), undefined);
			assert.equal(evaluateWithTestQueries(expr, null), undefined);

			const testWith = makeTester(expr, domainModel);
			testWith("NonInheriting", ["NonInheriting"]);
			testWith("ANotInCycle", ["ANotInCycle", "BNotInCycle", "CNotInCycle", "DNotInCycle"]);
			testWith("AInCycle", ["AInCycle", "BInCycle", "CInCycle", "AInCycle"], "cycle detection");
			testWith(
				"AlphaBeforeCycle",
				["AlphaBeforeCycle", "OmegaBeforeCycle", "AInCycle", "BInCycle", "CInCycle", "AInCycle"],
				"do not loop on \rho's"
			);

			done();
		});
	});

	it("a integer literal expression", () => {
		assertEvalWithNullThis({ $type: "MxIntegerLiteralExpression", value: 42 } as expressions.MxIntegerLiteralExpression, 42);
	});

	it("a [map] iterator call expression (and implicitly a variable reference expression)", done => {
		const iteratorBody = mkVariableRef("ent", wrap(mkPropertyCall("name")));	// "ent.name"
		const iteratorCall = mkIteratorCall("MAP", "ent", iteratorBody);			// *".map[ ent | ent.name ]"
		const expr = thisExpr(chain(mkPropertyCall("entities"), iteratorCall));		// "this.entities.map[ ent | ent.name ]""

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const entity2 = domainmodels_simple.Entity.createIn(domainModel);
			entity2.name = "bla";

			const value = evaluateWithTestQueries(expr, domainModel);
			assert.deepEqual(domainModel.entities.map(e => e.name), ["ExpenseType", "bla"]);
			assert.deepEqual(value, ["ExpenseType", "bla"]);
			done();
		});
	});

	it("[map and flatten] iterator and method call expressions (and implicitly a variable reference expression)", done => {
		// "this.entities.map[ ent | ent.oldAttributes.map[ attr | attr.name ]].flatten()"
		const innerMapBody = mkVariableRef("attr", wrap(mkPropertyCall("name")));							// "attr.name"
		const innerMapCall = mkIteratorCall("MAP", "attr", wrap(innerMapBody));								// *".map[ attr | ++<innerMapBody>++ ]"
		const outerMapBody = mkVariableRef("ent", chain(mkPropertyCall("oldAttributes"), innerMapCall));	// "ent.oldAttributes++<innerMapCall>++"
		const outerMapCall = mkIteratorCall("MAP", "ent", outerMapBody);									// *".map[ ent | ++<outerMapBody>++]"
		const flattenCall = mkMethodCall("flatten");														// *".flatten()"
		const expr = thisExpr(chain(mkPropertyCall("entities"), outerMapCall, flattenCall));				// "this.entities++<outerMapCall>++.flatten()"

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const attribute2 = domainmodels_simple.OldAttribute.createIn(entity);
			attribute2.name = "TestAttribute2";

			const entity2 = domainmodels_simple.Entity.createIn(domainModel);
			const attribute3 = domainmodels_simple.OldAttribute.createIn(entity2);
			attribute3.name = "TestAttribute3";

			const value = evaluateWithTestQueries(expr, domainModel);
			assert.deepEqual(value, ["Name", "TestAttribute2", "TestAttribute3"]);
			done();
		});
	});

	it("a list literal expression", () => {
		assertEvalWithNullThis(
			{
				$type: "MxListLiteralExpression",
				items: [
					trueExpr,
					falseExpr,
					{ $type: "MxColorLiteralExpression", red: 100, green: 150, blue: 200 } as expressions.MxColorLiteralExpression
				],
				appliedFeature: null
			} as expressions.MxListLiteralExpression,
			[
				true, false, { red: 100, green: 150, blue: 200 }
			]
		);
	});

	it("a method call that operates on undefined", () => {
		assertEvalWithNullThis(wrap(mkMethodCall("isUndefined")), true);
		assertEvalWithNullThis(wrap(mkMethodCall("someQuery")), undefined);
	});

	it("a prefix (==boolean negation) expression", () => {
		assertEvalWithNullThis(mkPrefixExpression(trueExpr), false);
		assertEvalWithNullThis(mkPrefixExpression(falseExpr), true);
		assertEvalWithNullThis(mkPrefixExpression(undefinedExpr), undefined);
	});

	it("a previous expression", done => {
		// "this.intsList.map[ i | previous(i) ]"
		const iteratorBody = mkPreviousExpr(mkVariableRef("i"));
		const expr = thisExpr(
			chain(mkPropertyCall("intsList"), mkIteratorCall("MAP", "i", iteratorBody))		// *".intsList.map[ i | ++<iteratorBody>++ ]"
		);

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const n = 4;
			entity.intsList.replace(range(n));	// [ 0, 1, 2, 3 ] --[previous]--> [ undefined, 0, 1, 2 ] --[flatMap]--> [0, 1, 2]
			const value = evaluateWithTestQueries(expr, entity);
			assert.deepEqual(value, range(n - 1));	// map is flatMappy, so undefined @ position 0 is skipped
			done();
		});
	});

	it("a property call expression", done => {
		const expr = thisExpr(wrap(mkPropertyCall("name")));	// "this.name"

		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const entityName = "fooBar!";
			entity.name = entityName;
			assert.equal(evaluateWithTestQueries(expr, entity), entityName);
			assert.equal(evaluateWithTestQueries(expr, undefined), undefined);
			done();
		});
	});

	it("a qualified enum literal expression", done => {
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const value = evaluateWithTestQueries(
				{
					$type: "MxQualifiedEnumLiteralExpression",
					enumeration: "DomainModels_simple$FooableType",
					literal: "WhenOnly"
				} as expressions.MxQualifiedEnumLiteralExpression,
				domainModel
			);
			assert.equal(domainmodels_simple.FooableType.WhenOnly, value);
			done();
		});
	});

	it("a size literal expression", () => {
		assertEvalWithNullThis(
			{
				$type: "MxSizeLiteralExpression",
				height: 1000,
				width: 800
			} as expressions.MxSizeLiteralExpression,
			{ height: 1000, width: 800 }
		);
	});

	it("a string literal expression", () => {
		assertEvalWithNullThis(mkStringLiteral("foo"), "foo");
	});

	it("a structure literal expression", done => {
		function mkPropertyAssignment(propertyName: string, valueExpr: expressions.MxLiteralExpression): expressions.MxPropertyAssignment {
			return {
				$type: "MxPropertyAssignment",
				property: propertyName,
				value: valueExpr
			};
		}
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const entityName = "fooBar!";
			const structure = evaluateWithTestQueries(
				{
					$type: "MxStructureLiteralExpression",
					structure: "domainmodels_simple$Entity",
					assignments: [
						mkPropertyAssignment("name", mkStringLiteral(entityName))
					]
				} as expressions.MxStructureLiteralExpression,
				domainModel
			);
			assert.ok(structure);
			assert.isTrue(structure instanceof domainmodels_simple.Entity);
			assert.equal((structure as domainmodels_simple.Entity).name, entityName);
			done();
		});
	});

	it("a switch expression", done => {
		const encompassingQuery = testQueries[domainmodels_simple.OldAttribute.typeName]["fooable"].queryVersions[0];
		const encompassingExpr = encompassingQuery.value as expressions.MxThisExpression;
		const switchExpr = encompassingExpr.appliedFeature.appliedFeature.featureCall as expressions.MxSwitch;
		assert.equal(switchExpr.$type, "MxSwitch", "drill-down to MxSwitch not correct");
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const fooableType = domainmodels_simple.FooableType;
			assert.equal(
				evaluateExpression(switchExpr, domainmodels_simple.StringAttributeType.create(model), testQueryResolver),
				fooableType.Both
			);
			assert.equal(
				evaluateExpression(switchExpr, domainmodels_simple.IntegerAttributeType.create(model), testQueryResolver),
				fooableType.TypeOfOnly
			);
			assert.equal(
				evaluateExpression(switchExpr, domainmodels_simple.BinaryAttributeType.create(model), testQueryResolver),
				fooableType.WhenOnly
			);
			done();
		});
	});

	it("a this expression", done => {
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const entityName = "fooBar!";
			entity.name = entityName;
			const value = evaluateWithTestQueries(thisExpr(), entity);
			assert.equal(value, entity);
			done();
		});
	});

	it("a type structure literal expression", done => {
		const structureTypeLiteralExpr = {
			$type: "MxTypeStructureLiteralExpression",
			referredStructure: domainmodels_simple.Entity.typeName
		} as expressions.MxTypeStructureLiteralExpression;
		withEntityLoaded("6.1.0", done, (entity, domainModel, model) => {	// (ignore warnings issued)
			const typeLiteral = evaluateWithTestQueries(structureTypeLiteralExpr, domainModel);
			assert.isTrue(typeLiteral instanceof StructureTypeLiteral);
			const clazz = typeLiteral.clazz;
			assert.isFunction(clazz);
			assert.equal(clazz.name, "Entity");
			assert.isFunction(clazz.create);
			assert.isTrue(clazz.create(model) instanceof domainmodels_simple.Entity);
			done();
		});
	});

	it("an undefined expression", () => {
		assertEvalWithNullThis(undefinedExpr, undefined);
	});

	// MxVariableRefExpression tested implicitly in tests for iterator calls


	// TODO  test all concrete sub types of MxApplicableExpression whether they're actually "applied"


});
