

import {ICheck} from "../../../sdk/checks/checks-types";
import {IQuery, IQueryResolver, makeQueryResolver, IQueryMap, ISuperTypeMap} from "../../../sdk/checks/queries";
import {makeChecksResolver, IChecksResolver} from "../../../sdk/checks/checks-runner";
	// (Note: tslint warns that IQuery is unused but it's implicitly used and required by the compiler.)
import {domainmodels_simple} from "../../gen/domainmodels_simple";

import {readFileSync} from "fs";
import {join} from "path";
import {assert} from "chai";


const pathPrefix = "src/test/metadata/";

function loadMetadataJson<T>(path: string): T {
	return JSON.parse(readFileSync(join(pathPrefix, path), { encoding: "utf8" }));
}

export const testChecks = loadMetadataJson<ICheck[]>("checks.json");
export const testChecksResolver = makeChecksResolver(testChecks);

export const testQueries = loadMetadataJson<IQueryMap>("queries.json");
export const testSuperTypes = loadMetadataJson<ISuperTypeMap>("super-types.json");
export const testQueryResolver = makeQueryResolver(testQueries, testSuperTypes);


// helper contains own unit tests:

describe("loading query resolver", () => {

	it("should understand inheritance", () => {
		assert.ok(testQueryResolver("isBinary", domainmodels_simple.BinaryAttributeType.typeName));
	});

	it("should not fail on unresolvable queries", () => {
		assert.equal(testQueryResolver("fooable", domainmodels_simple.Entity.typeName), undefined);
		assert.equal(testQueryResolver("barable", domainmodels_simple.AttributeType.typeName), undefined);
	});

});


describe("metadata loaders", () => {

	it("should load checks", () => {
		assert.isTrue(testChecks.length > 0);
	});

	it("should load queries", () => {
		assert.isTrue(Object.keys(testQueries).length > 0);
	});

});

