/* tslint:disable */

import * as internal from "../../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;


export namespace pages_simple {


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Pages_simple`.
	 */


	export interface IWidget extends internal.IElement {
		model: IModel;
		containerAsMultiContainer: IMultiContainer;
		containerAsPage: IPage;
		containerAsSingleContainer: ISingleContainer;
		load(): Widget;
		load(callback: (element: Widget) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class Widget extends internal.Element implements IWidget {
		public static typeName: string = "Pages_simple$Widget";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMultiContainer() { return super.getContainerAs<MultiContainer>(MultiContainer); }
		get containerAsPage() { return super.getContainerAs<Page>(Page); }
		get containerAsSingleContainer() { return super.getContainerAs<SingleContainer>(SingleContainer); }

		private __description: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Widget, this, "description", "", internal.PrimitiveTypeEnum.String);
		public get description(): string { return this.__description.get(); }
		public set description(newValue: string) { this.__description.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Widget() cannot be invoked directly, please use 'model.pages_simple.createWidget()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IMultiContainer extends IWidget {
		model: IModel;
		containerAsMultiContainer: IMultiContainer;
		containerAsPage: IPage;
		containerAsSingleContainer: ISingleContainer;
		load(): MultiContainer;
		load(callback: (element: MultiContainer) => void, forceRefresh?: boolean);
	}

	export class MultiContainer extends Widget implements IMultiContainer {
		public static typeName: string = "Pages_simple$MultiContainer";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMultiContainer() { return super.getContainerAs<MultiContainer>(MultiContainer); }
		get containerAsPage() { return super.getContainerAs<Page>(Page); }
		get containerAsSingleContainer() { return super.getContainerAs<SingleContainer>(SingleContainer); }

		private __widgets: internal.PartListProperty<Widget> =
			new internal.PartListProperty<Widget>(MultiContainer, this, "widgets", []);
		public get widgets(): internal.IList<Widget> { return this.__widgets.get(); }
		public set widgets(newValue: internal.IList<Widget>) { this.__widgets.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new MultiContainer() cannot be invoked directly, please use 'model.pages_simple.createMultiContainer()'"
				);
			}
		}


		/**
		 * Creates and returns a new MultiContainer instance in the SDK and on the server.
		 * The new MultiContainer will be automatically stored in the 'widgets' property
		 * of the parent MultiContainer element passed as argument.
		 */
		public static createInMultiContainerUnderWidgets(container: MultiContainer): MultiContainer {
			return internal.instancehelpers.createElement(container, MultiContainer, "widgets", true);
		}

		/**
		 * Creates and returns a new MultiContainer instance in the SDK and on the server.
		 * The new MultiContainer will be automatically stored in the 'widgets' property
		 * of the parent Page element passed as argument.
		 */
		public static createInPageUnderWidgets(container: Page): MultiContainer {
			return internal.instancehelpers.createElement(container, MultiContainer, "widgets", true);
		}

		/**
		 * Creates and returns a new MultiContainer instance in the SDK and on the server.
		 * The new MultiContainer will be automatically stored in the 'anotherWidget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderAnotherWidget(container: SingleContainer): MultiContainer {
			return internal.instancehelpers.createElement(container, MultiContainer, "anotherWidget", false);
		}

		/**
		 * Creates and returns a new MultiContainer instance in the SDK and on the server.
		 * The new MultiContainer will be automatically stored in the 'widget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderWidget(container: SingleContainer): MultiContainer {
			return internal.instancehelpers.createElement(container, MultiContainer, "widget", false);
		}

		/**
		 * Creates and returns a new MultiContainer instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): MultiContainer {
			return internal.instancehelpers.createElement(model, MultiContainer);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IPage extends internal.IModelUnit {
		model: IModel;
		containerAsProject: testmodel.IProject;
		name: string;
		load(): Page;
		load(callback: (element: Page) => void, forceRefresh?: boolean);
	}

	export class Page extends internal.ModelUnit implements IPage {
		public static typeName: string = "Pages_simple$Page";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<testmodel.Project>(testmodel.Project); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Page, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __widgets: internal.PartListProperty<Widget> =
			new internal.PartListProperty<Widget>(Page, this, "widgets", []);
		public get widgets(): internal.IList<Widget> { return this.__widgets.get(); }
		public set widgets(newValue: internal.IList<Widget>) { this.__widgets.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: testmodel.IProject) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "pages";
		}

		/**
		 * Creates a new Page unit in the SDK and on the server.
		 * Expects one argument, the testmodel.IProject in which this unit is contained.
		 */
		public static createIn(container: testmodel.IProject): Page {
			return internal.instancehelpers.createUnit(container, Page);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ISingleContainer extends IWidget {
		model: IModel;
		containerAsMultiContainer: IMultiContainer;
		containerAsPage: IPage;
		containerAsSingleContainer: ISingleContainer;
		load(): SingleContainer;
		load(callback: (element: SingleContainer) => void, forceRefresh?: boolean);
	}

	export class SingleContainer extends Widget implements ISingleContainer {
		public static typeName: string = "Pages_simple$SingleContainer";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMultiContainer() { return super.getContainerAs<MultiContainer>(MultiContainer); }
		get containerAsPage() { return super.getContainerAs<Page>(Page); }
		get containerAsSingleContainer() { return super.getContainerAs<SingleContainer>(SingleContainer); }

		private __widget: internal.PartProperty<Widget> =
			new internal.PartProperty<Widget>(SingleContainer, this, "widget", null, false);
		public get widget(): Widget { return this.__widget.get(); }
		public set widget(newValue: Widget) { this.__widget.set(newValue); }
		private __anotherWidget: internal.PartProperty<Widget> =
			new internal.PartProperty<Widget>(SingleContainer, this, "anotherWidget", null, false);
		public get anotherWidget(): Widget { return this.__anotherWidget.get(); }
		public set anotherWidget(newValue: Widget) { this.__anotherWidget.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SingleContainer() cannot be invoked directly, please use 'model.pages_simple.createSingleContainer()'"
				);
			}
		}


		/**
		 * Creates and returns a new SingleContainer instance in the SDK and on the server.
		 * The new SingleContainer will be automatically stored in the 'widgets' property
		 * of the parent MultiContainer element passed as argument.
		 */
		public static createInMultiContainerUnderWidgets(container: MultiContainer): SingleContainer {
			return internal.instancehelpers.createElement(container, SingleContainer, "widgets", true);
		}

		/**
		 * Creates and returns a new SingleContainer instance in the SDK and on the server.
		 * The new SingleContainer will be automatically stored in the 'widgets' property
		 * of the parent Page element passed as argument.
		 */
		public static createInPageUnderWidgets(container: Page): SingleContainer {
			return internal.instancehelpers.createElement(container, SingleContainer, "widgets", true);
		}

		/**
		 * Creates and returns a new SingleContainer instance in the SDK and on the server.
		 * The new SingleContainer will be automatically stored in the 'anotherWidget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderAnotherWidget(container: SingleContainer): SingleContainer {
			return internal.instancehelpers.createElement(container, SingleContainer, "anotherWidget", false);
		}

		/**
		 * Creates and returns a new SingleContainer instance in the SDK and on the server.
		 * The new SingleContainer will be automatically stored in the 'widget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderWidget(container: SingleContainer): SingleContainer {
			return internal.instancehelpers.createElement(container, SingleContainer, "widget", false);
		}

		/**
		 * Creates and returns a new SingleContainer instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SingleContainer {
			return internal.instancehelpers.createElement(model, SingleContainer);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface ISomeWidget extends IWidget {
		model: IModel;
		containerAsMultiContainer: IMultiContainer;
		containerAsPage: IPage;
		containerAsSingleContainer: ISingleContainer;
		load(): SomeWidget;
		load(callback: (element: SomeWidget) => void, forceRefresh?: boolean);
	}

	export class SomeWidget extends Widget implements ISomeWidget {
		public static typeName: string = "Pages_simple$SomeWidget";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsMultiContainer() { return super.getContainerAs<MultiContainer>(MultiContainer); }
		get containerAsPage() { return super.getContainerAs<Page>(Page); }
		get containerAsSingleContainer() { return super.getContainerAs<SingleContainer>(SingleContainer); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SomeWidget() cannot be invoked directly, please use 'model.pages_simple.createSomeWidget()'"
				);
			}
		}


		/**
		 * Creates and returns a new SomeWidget instance in the SDK and on the server.
		 * The new SomeWidget will be automatically stored in the 'widgets' property
		 * of the parent MultiContainer element passed as argument.
		 */
		public static createInMultiContainerUnderWidgets(container: MultiContainer): SomeWidget {
			return internal.instancehelpers.createElement(container, SomeWidget, "widgets", true);
		}

		/**
		 * Creates and returns a new SomeWidget instance in the SDK and on the server.
		 * The new SomeWidget will be automatically stored in the 'widgets' property
		 * of the parent Page element passed as argument.
		 */
		public static createInPageUnderWidgets(container: Page): SomeWidget {
			return internal.instancehelpers.createElement(container, SomeWidget, "widgets", true);
		}

		/**
		 * Creates and returns a new SomeWidget instance in the SDK and on the server.
		 * The new SomeWidget will be automatically stored in the 'anotherWidget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderAnotherWidget(container: SingleContainer): SomeWidget {
			return internal.instancehelpers.createElement(container, SomeWidget, "anotherWidget", false);
		}

		/**
		 * Creates and returns a new SomeWidget instance in the SDK and on the server.
		 * The new SomeWidget will be automatically stored in the 'widget' property
		 * of the parent SingleContainer element passed as argument.
		 */
		public static createInSingleContainerUnderWidget(container: SingleContainer): SomeWidget {
			return internal.instancehelpers.createElement(container, SomeWidget, "widget", false);
		}

		/**
		 * Creates and returns a new SomeWidget instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SomeWidget {
			return internal.instancehelpers.createElement(model, SomeWidget);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}
}

import {testmodel} from "./testmodel";

import {IModel} from "./base-model";
