/* tslint:disable */

import * as internal from "../../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import {utils} from "../../sdk/utils";
import {common} from "../../common";


export namespace domainmodels_simple {

	export class FooableType extends internal.IEnum {
		public static DeletedLiteral: FooableType = new FooableType("DeletedLiteral", {
			"introduced" : "6.0.1",
			"deprecated" : "6.0.4",
			"deprecationMessage" : null,
			"deleted" : "6.1.0",
			"deletionMessage" : null
		});
		public static Both: FooableType = new FooableType("Both", { });
		public static TypeOfOnly: FooableType = new FooableType("TypeOfOnly", { });
		public static WhenOnly: FooableType = new FooableType("WhenOnly", { });
		protected qualifiedTsTypeName: string = "domainmodels_simple.FooableType";
	}


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `DomainModels_simple`.
	 */


	/**
	 * In version 6.0.4: introduced, added public
	 */
	export interface IAttribute extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		name: string;
		load(): Attribute;
		load(callback: (element: Attribute) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.4: introduced, added public
	 */
	export class Attribute extends internal.Element implements IAttribute {
		public static typeName: string = "DomainModels_simple$Attribute";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.4",
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true,
				"changedIn" : [
					"6.0.4"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Attribute, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Attribute() cannot be invoked directly, please use 'model.domainmodels_simple.createAttribute()'"
				);
			}
		}

		/**
		 * Creates and returns a new Attribute instance in the SDK and on the server.
		 * The new Attribute will be automatically stored in the 'attributes' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: Entity): Attribute {
			internal.createInVersionCheck(container.model, Attribute.typeName,
				["6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, Attribute, "attributes", true);
		}

		/**
		 * Creates and returns a new Attribute instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Attribute {
			return internal.instancehelpers.createElement(model, Attribute);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IAttributeType extends internal.IElement {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): AttributeType;
		load(callback: (element: AttributeType) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class AttributeType extends internal.Element implements IAttributeType {
		public static typeName: string = "DomainModels_simple$AttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new AttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createAttributeType()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IBinaryAttributeType extends IAttributeType {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): BinaryAttributeType;
		load(callback: (element: BinaryAttributeType) => void, forceRefresh?: boolean);
	}

	export class BinaryAttributeType extends AttributeType implements IBinaryAttributeType {
		public static typeName: string = "DomainModels_simple$BinaryAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new BinaryAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createBinaryAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
		 * The new BinaryAttributeType will be automatically stored in the 'type' property
		 * of the parent OldAttribute element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: OldAttribute): BinaryAttributeType {
			internal.createInVersionCheck(container.model, BinaryAttributeType.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, BinaryAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): BinaryAttributeType {
			return internal.instancehelpers.createElement(model, BinaryAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDateTimeAttributeType extends IAttributeType {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): DateTimeAttributeType;
		load(callback: (element: DateTimeAttributeType) => void, forceRefresh?: boolean);
	}

	export class DateTimeAttributeType extends AttributeType implements IDateTimeAttributeType {
		public static typeName: string = "DomainModels_simple$DateTimeAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }

		private __localizeDate: internal.PrimitiveProperty<boolean> =
			new internal.PrimitiveProperty<boolean>(DateTimeAttributeType, this, "localizeDate", false, internal.PrimitiveTypeEnum.Boolean);
		public get localizeDate(): boolean { return this.__localizeDate.get(); }
		public set localizeDate(newValue: boolean) { this.__localizeDate.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DateTimeAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createDateTimeAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
		 * The new DateTimeAttributeType will be automatically stored in the 'type' property
		 * of the parent OldAttribute element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: OldAttribute): DateTimeAttributeType {
			internal.createInVersionCheck(container.model, DateTimeAttributeType.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, DateTimeAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DateTimeAttributeType {
			return internal.instancehelpers.createElement(model, DateTimeAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.localizeDate = true;
		}

	}

	/**
	 * In version 6.0.1: introduced
	 */
	export interface IDomainModel extends internal.IModelUnit {
		model: IModel;
		containerAsProject: testmodel.IProject;
		name: string;
		entities: internal.IList<IEntity>;
		simpleEntities: internal.IList<ISimpleEntity>;
		load(): DomainModel;
		load(callback: (element: DomainModel) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.1: introduced
	 */
	export class DomainModel extends internal.ModelUnit implements IDomainModel {
		public static typeName: string = "DomainModels_simple$DomainModel";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.1",
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"entities" : {
					"public" : {
						"currentValue" : true
					}
				},
				"simpleEntities" : {
					"public" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<testmodel.Project>(testmodel.Project); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DomainModel, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(DomainModel, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __entities: internal.PartListProperty<Entity> =
			new internal.PartListProperty<Entity>(DomainModel, this, "entities", []);
		public get entities(): internal.IList<Entity> { return this.__entities.get(); }
		public set entities(newValue: internal.IList<Entity>) { this.__entities.set(newValue); }
		private __simpleEntities: internal.PartListProperty<SimpleEntity> =
			new internal.PartListProperty<SimpleEntity>(DomainModel, this, "simpleEntities", []);
		public get simpleEntities(): internal.IList<SimpleEntity> { return this.__simpleEntities.get(); }
		public set simpleEntities(newValue: internal.IList<SimpleEntity>) { this.__simpleEntities.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: testmodel.IProject) {
			super(model, typeName, id, isPartial, container);
			this._declaredAsNamespace = true;
			this._containmentName = "domainModel";
		}

		/**
		 * Creates a new DomainModel unit in the SDK and on the server.
		 * Expects one argument, the testmodel.IProject in which this unit is contained.
		 */
		public static createIn(container: testmodel.IProject): DomainModel {
			return internal.instancehelpers.createUnit(container, DomainModel);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IDummyType extends internal.IElement {
		model: IModel;
		containerAsNewElement: INewElement;
		load(): DummyType;
		load(callback: (element: DummyType) => void, forceRefresh?: boolean);
	}

	export class DummyType extends internal.Element implements IDummyType {
		public static typeName: string = "DomainModels_simple$DummyType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsNewElement() { return super.getContainerAs<NewElement>(NewElement); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new DummyType() cannot be invoked directly, please use 'model.domainmodels_simple.createDummyType()'"
				);
			}
		}

		/**
		 * Creates and returns a new DummyType instance in the SDK and on the server.
		 * The new DummyType will be automatically stored in the 'myProp' property
		 * of the parent NewElement element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: NewElement): DummyType {
			internal.createInVersionCheck(container.model, DummyType.typeName,
				["6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, DummyType, "myProp", false);
		}

		/**
		 * Creates and returns a new DummyType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): DummyType {
			return internal.instancehelpers.createElement(model, DummyType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.0.2: introduced, removed experimental
	 * In version 6.0.1: added experimental
	 * In version 6.0.0: 
	 */
	export interface IEntity extends internal.IElement {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		/**
		 * In version 6.0.5: removed optional
		 * In version 6.0.2: added optional
		 * In version 6.0.1: added public, removed optional
		 */
		name: string;
		/**
		 * In version 6.2.0: deleted
		 * In version 6.0.4: deprecated
		 * In version 6.0.1: introduced
		 */
		oldAttributes: internal.IList<IOldAttribute>;
		/**
		 * In version 6.0.4: introduced
		 */
		attributes: internal.IList<IAttribute>;
		/**
		 * In version 6.0.4: introduced
		 */
		newThing: INewElement;
		superEntity: IEntity;
		superEntityQualifiedName: string;
		load(): Entity;
		load(callback: (element: Entity) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.2: introduced, removed experimental
	 * In version 6.0.1: added experimental
	 * In version 6.0.0: 
	 */
	export class Entity extends internal.Element implements IEntity {
		public static typeName: string = "DomainModels_simple$Entity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.2",
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true,
						"changedIn" : [
							"6.0.1"
						]
					}
				},
				"oldAttributes" : {
					"introduced" : "6.0.1",
					"deprecated" : "6.0.4",
					"deprecationMessage" : "Use attributes instead",
					"deleted" : "6.2.0",
					"deletionMessage" : "attributes is superior",
					"public" : {
						"currentValue" : true
					}
				},
				"attributes" : {
					"introduced" : "6.0.4",
					"public" : {
						"currentValue" : true
					}
				},
				"newThing" : {
					"introduced" : "6.0.4",
					"public" : {
						"currentValue" : true
					}
				},
				"nonUsedElement" : {
					"introduced" : "6.0.5"
				},
				"experimentalElemInModel" : {
					"introduced" : "6.0.4"
				},
				"experimentalElemNotInModel" : {
					"introduced" : "6.0.4"
				},
				"superEntity" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			},
			"experimental" : {
				"currentValue" : false,
				"changedIn" : [
					"6.0.2",
					"6.0.1"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Entity, this, "name", "", internal.PrimitiveTypeEnum.String);
		/**
		 * In version 6.0.5: removed optional
		 * In version 6.0.2: added optional
		 * In version 6.0.1: added public, removed optional
		 */
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __location: internal.PrimitiveProperty<common.IPoint> =
			new internal.PrimitiveProperty<common.IPoint>(Entity, this, "location", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
		public get location(): common.IPoint { return this.__location.get(); }
		public set location(newValue: common.IPoint) { this.__location.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(Entity, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }
		private __oldAttributes: internal.PartListProperty<OldAttribute> =
			new internal.PartListProperty<OldAttribute>(Entity, this, "oldAttributes", []);
		/**
		 * In version 6.2.0: deleted
		 * In version 6.0.4: deprecated
		 * In version 6.0.1: introduced
		 */
		public get oldAttributes(): internal.IList<OldAttribute> { return this.__oldAttributes.get(); }
		public set oldAttributes(newValue: internal.IList<OldAttribute>) { this.__oldAttributes.set(newValue); }
		private __attributes: internal.PartListProperty<Attribute> =
			new internal.PartListProperty<Attribute>(Entity, this, "attributes", []);
		/**
		 * In version 6.0.4: introduced
		 */
		public get attributes(): internal.IList<Attribute> { return this.__attributes.get(); }
		public set attributes(newValue: internal.IList<Attribute>) { this.__attributes.set(newValue); }
		private __superCool: internal.PartProperty<SuperCoolElement> =
			new internal.PartProperty<SuperCoolElement>(Entity, this, "superCool", null, false);
		public get superCool(): SuperCoolElement { return this.__superCool.get(); }
		public set superCool(newValue: SuperCoolElement) { this.__superCool.set(newValue); }
		private __newThing: internal.PartProperty<NewElement> =
			new internal.PartProperty<NewElement>(Entity, this, "newThing", null, false);
		/**
		 * In version 6.0.4: introduced
		 */
		public get newThing(): NewElement { return this.__newThing.get(); }
		public set newThing(newValue: NewElement) { this.__newThing.set(newValue); }
		private __nonUsedElement: internal.PartProperty<VeryNewElement> =
			new internal.PartProperty<VeryNewElement>(Entity, this, "nonUsedElement", null, false);
		/**
		 * In version 6.0.5: introduced
		 */
		public get nonUsedElement(): VeryNewElement { return this.__nonUsedElement.get(); }
		public set nonUsedElement(newValue: VeryNewElement) { this.__nonUsedElement.set(newValue); }
		private __experimentalElemInModel: internal.PartProperty<ExperimentalElement> =
			new internal.PartProperty<ExperimentalElement>(Entity, this, "experimentalElemInModel", null, false);
		/**
		 * In version 6.0.4: introduced
		 */
		public get experimentalElemInModel(): ExperimentalElement { return this.__experimentalElemInModel.get(); }
		public set experimentalElemInModel(newValue: ExperimentalElement) { this.__experimentalElemInModel.set(newValue); }
		private __experimentalElemNotInModel: internal.PartProperty<ExperimentalElement> =
			new internal.PartProperty<ExperimentalElement>(Entity, this, "experimentalElemNotInModel", null, false);
		/**
		 * In version 6.0.4: introduced
		 */
		public get experimentalElemNotInModel(): ExperimentalElement { return this.__experimentalElemNotInModel.get(); }
		public set experimentalElemNotInModel(newValue: ExperimentalElement) { this.__experimentalElemNotInModel.set(newValue); }
		private __intsList: internal.PrimitiveListProperty<number> =
			new internal.PrimitiveListProperty<number>(Entity, this, "intsList", [], internal.PrimitiveTypeEnum.Integer);
		public get intsList(): internal.IList<number> { return this.__intsList.get(); }
		public set intsList(newValue: internal.IList<number>) { this.__intsList.set(newValue); }
		private __superEntity: internal.ByNameReferenceProperty<IEntity> =
			new internal.ByNameReferenceProperty<IEntity>(Entity, this, "superEntity", null, "DomainModels_simple$Entity");
		public get superEntity(): IEntity { return this.__superEntity.get(); }
		public set superEntity(newValue: IEntity) { this.__superEntity.set(newValue); }
		get superEntityQualifiedName(): string { return this.__superEntity.qualifiedName(); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new Entity() cannot be invoked directly, please use 'model.domainmodels_simple.createEntity()'"
				);
			}
			this._declaredAsNamespace = true;
		}

		/**
		 * Creates and returns a new Entity instance in the SDK and on the server.
		 * The new Entity will be automatically stored in the 'entities' property
		 * of the parent DomainModel element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: DomainModel): Entity {
			internal.createInVersionCheck(container.model, Entity.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, Entity, "entities", true);
		}

		/**
		 * Creates and returns a new Entity instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): Entity {
			return internal.instancehelpers.createElement(model, Entity);
		}

		_isByNameReferrable() { return true; }

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.name = (() => {
				if (internal.isNotBefore("[6.0.1]", this.model)) {
					return "MyEntity";
				}
				return "12";
			})();
		}

	}

	/**
	 * In version 6.0.9: added experimental
	 * In version 6.0.7: removed experimental
	 * In version 6.0.6: added experimental
	 * In version 6.0.4: introduced
	 */
	export interface IExperimentalElement extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): ExperimentalElement;
		load(callback: (element: ExperimentalElement) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.9: added experimental
	 * In version 6.0.7: removed experimental
	 * In version 6.0.6: added experimental
	 * In version 6.0.4: introduced
	 */
	export class ExperimentalElement extends internal.Element implements IExperimentalElement {
		public static typeName: string = "DomainModels_simple$ExperimentalElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.4",
			"experimental" : {
				"currentValue" : true,
				"changedIn" : [
					"6.0.9",
					"6.0.7",
					"6.0.6"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ExperimentalElement() cannot be invoked directly, please use 'model.domainmodels_simple.createExperimentalElement()'"
				);
			}
		}


		/**
		 * Creates and returns a new ExperimentalElement instance in the SDK and on the server.
		 * The new ExperimentalElement will be automatically stored in the 'experimentalElemInModel' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createInEntityUnderExperimentalElemInModel(container: Entity): ExperimentalElement {
			internal.createInVersionCheck(container.model, ExperimentalElement.typeName,
				["6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, ExperimentalElement, "experimentalElemInModel", false);
		}

		/**
		 * Creates and returns a new ExperimentalElement instance in the SDK and on the server.
		 * The new ExperimentalElement will be automatically stored in the 'experimentalElemNotInModel' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createInEntityUnderExperimentalElemNotInModel(container: Entity): ExperimentalElement {
			internal.createInVersionCheck(container.model, ExperimentalElement.typeName,
				["6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, ExperimentalElement, "experimentalElemNotInModel", false);
		}

		/**
		 * Creates and returns a new ExperimentalElement instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): ExperimentalElement {
			return internal.instancehelpers.createElement(model, ExperimentalElement);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface INumericAttributeTypeBase extends IAttributeType {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): NumericAttributeTypeBase;
		load(callback: (element: NumericAttributeTypeBase) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class NumericAttributeTypeBase extends AttributeType implements INumericAttributeTypeBase {
		public static typeName: string = "DomainModels_simple$NumericAttributeTypeBase";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new NumericAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels_simple.createNumericAttributeTypeBase()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IFloatAttributeType extends INumericAttributeTypeBase {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): FloatAttributeType;
		load(callback: (element: FloatAttributeType) => void, forceRefresh?: boolean);
	}

	export class FloatAttributeType extends NumericAttributeTypeBase implements IFloatAttributeType {
		public static typeName: string = "DomainModels_simple$FloatAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new FloatAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createFloatAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
		 * The new FloatAttributeType will be automatically stored in the 'type' property
		 * of the parent OldAttribute element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: OldAttribute): FloatAttributeType {
			internal.createInVersionCheck(container.model, FloatAttributeType.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, FloatAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): FloatAttributeType {
			return internal.instancehelpers.createElement(model, FloatAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IIntegerAttributeType extends INumericAttributeTypeBase {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): IntegerAttributeType;
		load(callback: (element: IntegerAttributeType) => void, forceRefresh?: boolean);
	}

	export class IntegerAttributeType extends NumericAttributeTypeBase implements IIntegerAttributeType {
		public static typeName: string = "DomainModels_simple$IntegerAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new IntegerAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createIntegerAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
		 * The new IntegerAttributeType will be automatically stored in the 'type' property
		 * of the parent OldAttribute element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: OldAttribute): IntegerAttributeType {
			internal.createInVersionCheck(container.model, IntegerAttributeType.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, IntegerAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): IntegerAttributeType {
			return internal.instancehelpers.createElement(model, IntegerAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	/**
	 * In version 6.0.4: introduced
	 */
	export interface INewElement extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		/**
		 * In version 6.0.6: added public
		 */
		myNewProp: string;
		load(): NewElement;
		load(callback: (element: NewElement) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.4: introduced
	 */
	export class NewElement extends internal.Element implements INewElement {
		public static typeName: string = "DomainModels_simple$NewElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.4",
			"properties" : {
				"myProp" : {
					"required" : {
						"currentValue" : true,
						"changedIn" : [
							"6.0.9",
							"6.0.7",
							"6.0.6"
						]
					}
				},
				"myNewProp" : {
					"public" : {
						"currentValue" : true,
						"changedIn" : [
							"6.0.6"
						]
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __myProp: internal.PartProperty<DummyType> =
			new internal.PartProperty<DummyType>(NewElement, this, "myProp", null, true);
		/**
		 * In version 6.0.9: removed optional
		 * In version 6.0.7: added optional
		 * In version 6.0.6: removed optional
		 */
		public get myProp(): DummyType { return this.__myProp.get(); }
		public set myProp(newValue: DummyType) { this.__myProp.set(newValue); }
		private __myNewProp: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(NewElement, this, "myNewProp", "", internal.PrimitiveTypeEnum.String);
		/**
		 * In version 6.0.6: added public
		 */
		public get myNewProp(): string { return this.__myNewProp.get(); }
		public set myNewProp(newValue: string) { this.__myNewProp.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new NewElement() cannot be invoked directly, please use 'model.domainmodels_simple.createNewElement()'"
				);
			}
		}

		/**
		 * Creates and returns a new NewElement instance in the SDK and on the server.
		 * The new NewElement will be automatically stored in the 'newThing' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: Entity): NewElement {
			internal.createInVersionCheck(container.model, NewElement.typeName,
				["6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, NewElement, "newThing", false);
		}

		/**
		 * Creates and returns a new NewElement instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): NewElement {
			return internal.instancehelpers.createElement(model, NewElement);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.myProp = (() => {
				if (internal.isNotBefore("[6.0.7]", this.model)) {
					return DummyType.create(this.model);
				}
				return undefined;
			})();
		}

	}

	/**
	 * In version 6.2.0: deleted
	 * In version 6.0.4: deprecated
	 * In version 6.0.1: introduced
	 */
	export interface IOldAttribute extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		name: string;
		/**
		 * This property is required and cannot be set to null.
		 *
		 * In version 6.0.4: removed optional
		 * In version 6.0.2: added optional
		 * In version 6.0.1: removed optional
		 */
		type: IAttributeType;
		load(): OldAttribute;
		load(callback: (element: OldAttribute) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.2.0: deleted
	 * In version 6.0.4: deprecated
	 * In version 6.0.1: introduced
	 */
	export class OldAttribute extends internal.Element implements IOldAttribute {
		public static typeName: string = "DomainModels_simple$OldAttribute";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"introduced" : "6.0.1",
			"deprecated" : "6.0.4",
			"deprecationMessage" : "Use Attribute instead",
			"deleted" : "6.2.0",
			"deletionMessage" : "Attribute is superior",
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"type" : {
					"public" : {
						"currentValue" : true
					},
					"required" : {
						"currentValue" : true,
						"changedIn" : [
							"6.0.4",
							"6.0.2",
							"6.0.1"
						]
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(OldAttribute, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __dataStorageGuid: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(OldAttribute, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
		public get dataStorageGuid(): string { return this.__dataStorageGuid.get(); }
		public set dataStorageGuid(newValue: string) { this.__dataStorageGuid.set(newValue); }
		private __type: internal.PartProperty<AttributeType> =
			new internal.PartProperty<AttributeType>(OldAttribute, this, "type", null, true);
		/**
		 * In version 6.0.4: removed optional
		 * In version 6.0.2: added optional
		 * In version 6.0.1: removed optional
		 */
		public get type(): AttributeType { return this.__type.get(); }
		public set type(newValue: AttributeType) { this.__type.set(newValue); }
		private __documentation: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(OldAttribute, this, "documentation", "", internal.PrimitiveTypeEnum.String);
		public get documentation(): string { return this.__documentation.get(); }
		public set documentation(newValue: string) { this.__documentation.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new OldAttribute() cannot be invoked directly, please use 'model.domainmodels_simple.createOldAttribute()'"
				);
			}
		}

		/**
		 * Creates and returns a new OldAttribute instance in the SDK and on the server.
		 * The new OldAttribute will be automatically stored in the 'oldAttributes' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: Entity): OldAttribute {
			internal.createInVersionCheck(container.model, OldAttribute.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, OldAttribute, "oldAttributes", true);
		}

		/**
		 * Creates and returns a new OldAttribute instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): OldAttribute {
			return internal.instancehelpers.createElement(model, OldAttribute);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.dataStorageGuid = utils.randomUuid();
			this.type = StringAttributeType.create(this.model);
		}

	}

	export interface ISimpleEntity extends internal.IElement {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		name: string;
		generalization: ISimpleEntity;
		load(): SimpleEntity;
		load(callback: (element: SimpleEntity) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class SimpleEntity extends internal.Element implements ISimpleEntity {
		public static typeName: string = "DomainModels_simple$SimpleEntity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"name" : {
					"public" : {
						"currentValue" : true
					}
				},
				"generalization" : {
					"public" : {
						"currentValue" : true
					}
				}
			},
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }

		private __name: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(SimpleEntity, this, "name", "", internal.PrimitiveTypeEnum.String);
		public get name(): string { return this.__name.get(); }
		public set name(newValue: string) { this.__name.set(newValue); }
		private __generalization: internal.ByIdReferenceProperty<SimpleEntity> =
			new internal.ByIdReferenceProperty<SimpleEntity>(SimpleEntity, this, "generalization", null);
		public get generalization(): SimpleEntity { return this.__generalization.get(); }
		public set generalization(newValue: SimpleEntity) { this.__generalization.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SimpleEntity() cannot be invoked directly, please use 'model.domainmodels_simple.createSimpleEntity()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.name = "MySimpleEntity";
		}

	}

	export interface ISimpleSubEntity extends ISimpleEntity {
		model: IModel;
		containerAsDomainModel: IDomainModel;
		load(): SimpleSubEntity;
		load(callback: (element: SimpleSubEntity) => void, forceRefresh?: boolean);
	}

	export class SimpleSubEntity extends SimpleEntity implements ISimpleSubEntity {
		public static typeName: string = "DomainModels_simple$SimpleSubEntity";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsDomainModel() { return super.getContainerAs<DomainModel>(DomainModel); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SimpleSubEntity() cannot be invoked directly, please use 'model.domainmodels_simple.createSimpleSubEntity()'"
				);
			}
		}

		/**
		 * Creates and returns a new SimpleSubEntity instance in the SDK and on the server.
		 * The new SimpleSubEntity will be automatically stored in the 'simpleEntities' property
		 * of the parent DomainModel element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: DomainModel): SimpleSubEntity {
			internal.createInVersionCheck(container.model, SimpleSubEntity.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, SimpleSubEntity, "simpleEntities", true);
		}

		/**
		 * Creates and returns a new SimpleSubEntity instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SimpleSubEntity {
			return internal.instancehelpers.createElement(model, SimpleSubEntity);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.name = (() => {
				if (internal.isNotBefore("[6.2.0]", this.model)) {
					return "MySimpleSubEntity";
				}
				return "MyEasySubEntity";
			})();
		}

	}

	export interface IStringAttributeType extends IAttributeType {
		model: IModel;
		containerAsOldAttribute: IOldAttribute;
		load(): StringAttributeType;
		load(callback: (element: StringAttributeType) => void, forceRefresh?: boolean);
	}

	export class StringAttributeType extends AttributeType implements IStringAttributeType {
		public static typeName: string = "DomainModels_simple$StringAttributeType";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : true
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsOldAttribute() { return super.getContainerAs<OldAttribute>(OldAttribute); }

		private __length: internal.PrimitiveProperty<number> =
			new internal.PrimitiveProperty<number>(StringAttributeType, this, "length", 0, internal.PrimitiveTypeEnum.Integer);
		public get length(): number { return this.__length.get(); }
		public set length(newValue: number) { this.__length.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new StringAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createStringAttributeType()'"
				);
			}
		}

		/**
		 * Creates and returns a new StringAttributeType instance in the SDK and on the server.
		 * The new StringAttributeType will be automatically stored in the 'type' property
		 * of the parent OldAttribute element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.1, 6.0.2, 6.0.4, 6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0
		 */
		public static createIn(container: OldAttribute): StringAttributeType {
			internal.createInVersionCheck(container.model, StringAttributeType.typeName,
				["6.0.1", "6.0.2", "6.0.4", "6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0"]
			);
			return internal.instancehelpers.createElement(container, StringAttributeType, "type", false);
		}

		/**
		 * Creates and returns a new StringAttributeType instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): StringAttributeType {
			return internal.instancehelpers.createElement(model, StringAttributeType);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.length = 200;
		}

	}

	/**
	 * In version 6.0.4: removed public, removed experimental
	 * In version 6.0.1: added public, added experimental
	 */
	export interface ISuperCoolElement extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): SuperCoolElement;
		load(callback: (element: SuperCoolElement) => void, forceRefresh?: boolean);
	}

	/**
	 * In version 6.0.4: removed public, removed experimental
	 * In version 6.0.1: added public, added experimental
	 */
	export class SuperCoolElement extends internal.Element implements ISuperCoolElement {
		public static typeName: string = "DomainModels_simple$SuperCoolElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"public" : {
				"currentValue" : false,
				"changedIn" : [
					"6.0.4",
					"6.0.1"
				]
			},
			"experimental" : {
				"currentValue" : false,
				"changedIn" : [
					"6.0.4",
					"6.0.1"
				]
			}
		}, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new SuperCoolElement() cannot be invoked directly, please use 'model.domainmodels_simple.createSuperCoolElement()'"
				);
			}
		}

		/**
		 * Creates and returns a new SuperCoolElement instance in the SDK and on the server.
		 * The new SuperCoolElement will be automatically stored in the 'superCool' property
		 * of the parent Entity element passed as argument.
		 */
		public static createIn(container: Entity): SuperCoolElement {
			return internal.instancehelpers.createElement(container, SuperCoolElement, "superCool", false);
		}

		/**
		 * Creates and returns a new SuperCoolElement instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): SuperCoolElement {
			return internal.instancehelpers.createElement(model, SuperCoolElement);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IVeryNewElement extends internal.IElement {
		model: IModel;
		containerAsEntity: IEntity;
		load(): VeryNewElement;
		load(callback: (element: VeryNewElement) => void, forceRefresh?: boolean);
	}

	export class VeryNewElement extends internal.Element implements IVeryNewElement {
		public static typeName: string = "DomainModels_simple$VeryNewElement";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsEntity() { return super.getContainerAs<Entity>(Entity); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new VeryNewElement() cannot be invoked directly, please use 'model.domainmodels_simple.createVeryNewElement()'"
				);
			}
		}

		/**
		 * Creates and returns a new VeryNewElement instance in the SDK and on the server.
		 * The new VeryNewElement will be automatically stored in the 'nonUsedElement' property
		 * of the parent Entity element passed as argument.
		 *
		 * Warning! Can only be used on models with the following Mendix meta model versions:
		 *  6.0.5, 6.0.6, 6.0.7, 6.0.8, 6.0.9, 6.1.0, 6.2.0, 6.3.0
		 */
		public static createIn(container: Entity): VeryNewElement {
			internal.createInVersionCheck(container.model, VeryNewElement.typeName,
				["6.0.5", "6.0.6", "6.0.7", "6.0.8", "6.0.9", "6.1.0", "6.2.0", "6.3.0"]
			);
			return internal.instancehelpers.createElement(container, VeryNewElement, "nonUsedElement", false);
		}

		/**
		 * Creates and returns a new VeryNewElement instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): VeryNewElement {
			return internal.instancehelpers.createElement(model, VeryNewElement);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}
}

import {testmodel} from "./testmodel";

import {IModel} from "./base-model";
