/* tslint:disable */

import * as internal from "../../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;


export namespace parsing_simple {


	/**
	 * Interfaces and instance classes for types from the Mendix sub meta model `Parsing_simple`.
	 */


	export interface IParseNode extends internal.IElement {
		model: IModel;
		containerAsUnitWithParserProperties: IUnitWithParserProperties;
		load(): ParseNode;
		load(callback: (element: ParseNode) => void, forceRefresh?: boolean);
	}

	/**
	 * Warning: this class represents an abstract and non-instantiable concept in the meta model.
	 * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
	 * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
	 */
	export abstract class ParseNode extends internal.Element implements IParseNode {
		public static typeName: string = "Parsing_simple$ParseNode";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsUnitWithParserProperties() { return super.getContainerAs<UnitWithParserProperties>(UnitWithParserProperties); }


		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new ParseNode() cannot be invoked directly, please use 'model.parsing_simple.createParseNode()'"
				);
			}
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
		}

	}

	export interface IUnitWithParserProperties extends internal.IModelUnit {
		model: IModel;
		containerAsProject: testmodel.IProject;
		load(): UnitWithParserProperties;
		load(callback: (element: UnitWithParserProperties) => void, forceRefresh?: boolean);
	}

	export class UnitWithParserProperties extends internal.ModelUnit implements IUnitWithParserProperties {
		public static typeName: string = "Parsing_simple$UnitWithParserProperties";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({
			"properties" : {
				"asAst" : {
					"required" : {
						"currentValue" : true
					}
				},
				"asText" : {
					"required" : {
						"currentValue" : true
					}
				},
				"storedAsStringInstance" : {
					"required" : {
						"currentValue" : true
					}
				}
			}
		}, internal.StructureType.ModelUnit);
		model: IModel;

		get containerAsProject() { return super.getContainerAs<testmodel.Project>(testmodel.Project); }

		private __asAst: internal.PartProperty<ParseNode> =
			new internal.PartProperty<ParseNode>(UnitWithParserProperties, this, "asAst", null, true);
		public get asAst(): ParseNode { return this.__asAst.get(); }
		public set asAst(newValue: ParseNode) { this.__asAst.set(newValue); }
		private __asText: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UnitWithParserProperties, this, "asText", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type parsing_simple.ParseNode.
		 */
		public get asText(): string { return this.__asText.get(); }
		public set asText(newValue: string) { this.__asText.set(newValue); }
		private __storedAsStringInstance: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UnitWithParserProperties, this, "storedAsStringInstance", "", internal.PrimitiveTypeEnum.String);
		/**
		 * The value of this property is conceptually of type parsing_simple.StoredAsStringType.
		 */
		public get storedAsStringInstance(): string { return this.__storedAsStringInstance.get(); }
		public set storedAsStringInstance(newValue: string) { this.__storedAsStringInstance.set(newValue); }

		constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: testmodel.IProject) {
			super(model, typeName, id, isPartial, container);
			this._containmentName = "unitWithParserProperties";
		}

		/**
		 * Creates a new UnitWithParserProperties unit in the SDK and on the server.
		 * Expects one argument, the testmodel.IProject in which this unit is contained.
		 */
		public static createIn(container: testmodel.IProject): UnitWithParserProperties {
			return internal.instancehelpers.createUnit(container, UnitWithParserProperties);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.asAst = UnparseableTextNode.create(this.model);
			this.asText = "???";
			this.storedAsStringInstance = "";
		}

	}

	export interface IUnparseableTextNode extends IParseNode {
		model: IModel;
		containerAsUnitWithParserProperties: IUnitWithParserProperties;
		load(): UnparseableTextNode;
		load(callback: (element: UnparseableTextNode) => void, forceRefresh?: boolean);
	}

	export class UnparseableTextNode extends ParseNode implements IUnparseableTextNode {
		public static typeName: string = "Parsing_simple$UnparseableTextNode";
		public static versionInfo: StructureVersionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);
		model: IModel;

		get containerAsUnitWithParserProperties() { return super.getContainerAs<UnitWithParserProperties>(UnitWithParserProperties); }

		private __text: internal.PrimitiveProperty<string> =
			new internal.PrimitiveProperty<string>(UnparseableTextNode, this, "text", "", internal.PrimitiveTypeEnum.String);
		public get text(): string { return this.__text.get(); }
		public set text(newValue: string) { this.__text.set(newValue); }

		constructor(
			model: internal.AbstractModel,
			typeName: string,
			id: string,
			isPartial: boolean,
			unit: internal.ModelUnit,
			container: internal.AbstractElement
		) {
			super(model, typeName, id, isPartial, unit, container);
			if (arguments.length < 4) {
				throw new Error(
					"new UnparseableTextNode() cannot be invoked directly, please use 'model.parsing_simple.createUnparseableTextNode()'"
				);
			}
		}


		/**
		 * Creates and returns a new UnparseableTextNode instance in the SDK and on the server.
		 * The new UnparseableTextNode will be automatically stored in the 'asAst' property
		 * of the parent UnitWithParserProperties element passed as argument.
		 */
		public static createInUnitWithParserPropertiesUnderAsAst(container: UnitWithParserProperties): UnparseableTextNode {
			return internal.instancehelpers.createElement(container, UnparseableTextNode, "asAst", false);
		}

		/**
		 * Creates and returns a new UnparseableTextNode instance in the SDK and on the server.
		 * The new UnparseableTextNode will be automatically stored in the 'asText' property
		 * of the parent UnitWithParserProperties element passed as argument.
		 */
		public static createInUnitWithParserPropertiesUnderAsText(container: UnitWithParserProperties): UnparseableTextNode {
			return internal.instancehelpers.createElement(container, UnparseableTextNode, "asText", false);
		}

		/**
		 * Creates and returns a new UnparseableTextNode instance in the SDK and on the server.
		 * Expects one argument: the IModel object the instance will "live on".
		 * After creation, assign or add this instance to a property that accepts this kind of objects.
		 */
		public static create(model: IModel): UnparseableTextNode {
			return internal.instancehelpers.createElement(model, UnparseableTextNode);
		}

		_initializeDefaultProperties() {
			super._initializeDefaultProperties();
			this.text = "???";
		}

	}
}

import {testmodel} from "./testmodel";

import {IModel} from "./base-model";
