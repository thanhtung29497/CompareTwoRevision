import * as properties from "../internal/properties";
import * as units from "../internal/units";
import * as structures from "../internal/structures";
import * as instances from "../internal/instances";

interface IPropertySetting {
	propertyName: string;
	listy?: boolean;				  // default: false
	value: any;
	kind: PropertyKind;
	couldBeDefaultValue?: boolean;   // default: false
	targetType?: string;			 // qualified name of type targetted by by-name reference
}

interface IStructureCreation {
	id: string;
	subMetaModel: string;
	unqualifiedTypeName: string;
	name?: string;				   // optional name of structure
	settings: IPropertySetting[];
	unit: boolean;
}

enum PropertyKind {
	primitive, enumeration, byIdReference, byNameReference, part
}

function toFirstLowerCase(str: string) {
	return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * Class which allows to serialize a given model part as TypeScript code that constructs that model piece.
 * Limitations:
 *  - Can only do elements in one (model) unit.
 */
export class JavaScriptSerializer {

	private _creations: IStructureCreation[] = [];
	private _creationsById: { [id: string]: boolean } = {};
	private _varNamesById: { [id: string]: string } = {};
	private _varNames: { [varName: string]: boolean } = {};

	static serializeToJs(unit: units.IAbstractUnit) {
		if (!unit.isLoaded) {
			throw new Error("serializeToJs can be used on loaded units only!");
		}
		const serializer = new JavaScriptSerializer(unit);
		serializer.schedule(unit);
		return serializer.source();
	}

	public constructor(private _unit: units.IAbstractUnit) { }

	public schedule(structure: structures.IStructure) {
		if (!structure || this._creationsById[structure.id]) {
			return;
		}

		this._creationsById[structure.id] = true;
		this._creations.push(this._asCreation(structure));
	}

	public source() {
		// 1. compute varNames:
		for (let creation of this._creations) {
			this._computeVarName(creation);
		}

		// 2. build source for everything but assignments of by-id references:
		const phase1 = this._creations.map(creation => this._creationAsSource(creation)).join("\n");

		// 3. add source for assignments of by-id references:
		const creationsWithByIdRefencesAssigments = this._creations.filter(
			creation => creation.settings.some(setting => setting.kind === PropertyKind.byIdReference)
		);
		const phase2 = creationsWithByIdRefencesAssigments.map(creation => "\n" +
			creation.settings
				.filter(setting => setting.kind === PropertyKind.byIdReference)
				.map(setting => "\t" + this._settingAsSource(this._varNamesById[creation.id], setting) + "\n")
				.join("")
		).join("");

		const today = new Date();
		const header =
			`(function (unit, model) {

\t/*
\t * JavaScript code generated by mendixmodelsdk.sdk.extras.JavaScriptSerializer
\t * from unit with id "${this._unit.id}" of type ${this._unit.typeName}
\t * in working copy "${this._unit._model.metadata.metaData.name}"
\t * on ${today.getDate()}-${today.getMonth() + 1}-${today.getFullYear()}.
\t */

`;

		return header + phase1 + phase2 + "\n})";
	}

	private _computeVarName(creation: IStructureCreation) {
		let preName, name, uniqueIndex = 0, addUnderscore = false;
		if (creation.name) {
			preName = this._sanitizeName(creation.name);
			name = preName;
			addUnderscore = !!preName.match(/\d$/);
		} else {
			preName = toFirstLowerCase(creation.unqualifiedTypeName);
			name = preName + "1";
			uniqueIndex = 1;
		}
		while (this._varNames[name]) {
			uniqueIndex++;
			name = preName + (addUnderscore ? "_" : "") + uniqueIndex;
		}
		this._varNamesById[creation.id] = name;
		this._varNames[name] = true;
	}

	private _sanitizeName(name: string) {
		name = name.replace(/[!\"#$%&'\(\)\*\+,\.\/:;<=>\?\@\[\\\]\^`\{\|\}~]/g, "");
		name = name.replace(/^\d+/, "");
		name = name.charAt(0).toLowerCase() + name.substring(1);	// == toFirstLowerCase
		return name;
	}

	private _creationAsSource(creation: IStructureCreation) {
		const lines: string[] = [];
		const varName = this._varNamesById[creation.id];
		lines.push(
			`var ${varName} = ${creation.subMetaModel.toLowerCase()}.${creation.unqualifiedTypeName}.create${creation.unit ? "In(unit" : "(model"});`
		);
		creation.settings.filter(
			setting => setting.kind !== PropertyKind.byIdReference).forEach(setting => lines.push(...this._settingAsSource(varName, setting))
		);
		return lines.map(line => "\t" + line + "\n").join("");
	}

	private _settingAsSource(varName: string, setting: IPropertySetting): string[] {
		const commentsPostfix = setting.couldBeDefaultValue ? "   // Note: for this property a default value is defined." : "";
		return setting.listy
			? (setting.value as any[]).map(
				singleValue => `${varName}.${setting.propertyName}.push(${this._singleValueAsTsExpr(varName, setting, singleValue)});${commentsPostfix}`
			)
			: [`${varName}.${setting.propertyName} = ${this._singleValueAsTsExpr(varName, setting, setting.value)};${commentsPostfix}`];
	}

	private _singleValueAsTsExpr(varName: string, setting: IPropertySetting, singleValue: any): string {
		switch (setting.kind) {
			case PropertyKind.primitive: return JSON.stringify(singleValue);
			case PropertyKind.enumeration: return (singleValue as instances.IEnum).qualifiedTsLiteralName();
			case PropertyKind.byIdReference: return this._varNamesById[singleValue];
			case PropertyKind.byNameReference: {
				const $index = setting.targetType.indexOf("$");
				return `model.find${setting.targetType.substring($index + 1)}ByQualifiedName("${singleValue}")`;
			}
			case PropertyKind.part: return !singleValue ? null : (this._varNamesById[singleValue.id]);
			default:
				throw new Error(`unmapped property kind (${setting.kind}) for setting of ${setting.propertyName} in ${varName}`);
		}
	}

	private _asCreation(structure: structures.IStructure): IStructureCreation {
		const typeParts = structure.typeName.split("$");
		const creation = {
			id: structure.id,
			subMetaModel: typeParts[0],
			unqualifiedTypeName: typeParts[1],
			settings: []
		} as IStructureCreation;
		if (structure["name"]) {
			creation.name = structure["name"];
		}
		if (structure instanceof units.ModelUnit || structure instanceof units.StructuralUnit) {
			// i.e. structure instanceof units.AbstractUnit if the TS type hierarchy actually matched the one in MxCore
			creation.unit = true;
		}
		structure.allProperties().forEach(property => {
			if (!property.isAvailable) {
				return;
			}
			if (property instanceof properties.EnumProperty) {
				const value = (property as properties.EnumProperty<any>).get();
				if (value !== property["defaultValue"]) {
					creation.settings.push({ propertyName: property["name"], kind: PropertyKind.enumeration, value: value } as IPropertySetting);
				}
				return;
			}
			if (property instanceof properties.EnumListProperty) {
				const value = (property as properties.EnumListProperty<any>).get();
				if (value.length > 0) {
					creation.settings.push(
						{ propertyName: property["name"], kind: PropertyKind.enumeration, value: value, listy: true } as IPropertySetting)
					;
				}
				return;
			}
			// Primitive(List)Property must be handled _after_ Enum(List)Property since the latter inherit from the first!
			if (property instanceof properties.PrimitiveProperty) {
				if (property["primitiveType"] === properties.PrimitiveTypeEnum.Guid) {
					return;
				}

				const value = (property as properties.PrimitiveProperty<any>).get();
				if (value !== property["defaultValue"]) {
					creation.settings.push({ propertyName: property["name"], kind: PropertyKind.primitive, value: value } as IPropertySetting);
				}
				return;
			}
			if (property instanceof properties.PrimitiveListProperty) {
				const value = (property as properties.PrimitiveListProperty<any>).get();
				if (value.length > 0) {
					creation.settings.push(
						{ propertyName: property["name"], kind: PropertyKind.primitive, value: value, listy: true } as IPropertySetting
					);
				}
				return;
			}
			if (property instanceof properties.PartProperty) {
				const value = (property as properties.PartProperty<any>).get();
				if (value) {
					this.schedule(value);
				}
				if (property["hasDefaultValue"] || value) {
					creation.settings.push(
						{
							propertyName: property["name"],
							kind: PropertyKind.part,
							value: value,
							couldBeDefaultValue: property["hasDefaultValue"]
						} as IPropertySetting
					);
				}
				return;
			}
			if (property instanceof properties.PartListProperty) {
				const value = (property as properties.PartListProperty<any>).get();
				if (value.length > 0) {
					value.forEach(item => this.schedule(item));
					creation.settings.push({ propertyName: property["name"], kind: PropertyKind.part, value: value, listy: true } as IPropertySetting);
				}
				return;
			}
			if (property instanceof properties.ByNameReferenceProperty) {
				const value = (property as properties.ByNameReferenceProperty<any>).get();
				if (value) {
					creation.settings.push(
						{
							propertyName: property["name"],
							kind: PropertyKind.byNameReference,
							value: property.qualifiedName(),
							targetType: property.targetType
						} as IPropertySetting
					);
				}
				return;
			}
			if (property instanceof properties.ByNameReferenceListProperty) {
				const value = (property as properties.ByNameReferenceListProperty<any>).get();
				if (value.length > 0) {
					creation.settings.push(
						{
							propertyName: property["name"],
							kind: PropertyKind.byNameReference,
							value: property.qualifiedNames(),
							targetType: property.targetType,
							listy: true
						} as IPropertySetting
					);
				}
				return;
			}
			if (property instanceof properties.ByIdReferenceProperty) {
				const value = (property as properties.ByIdReferenceProperty<any>).get();
				if (value) {
					this.schedule(value);
					creation.settings.push({ propertyName: property["name"], kind: PropertyKind.byIdReference, value: value.id } as IPropertySetting);
				}
				return;
			}
			throw new Error(`cannot serialize property: ${property}`);
		});
		return creation;
	}

}
