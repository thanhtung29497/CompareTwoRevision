import {configuration} from "../config";
import {common} from "../../common";
import * as transport from "./transport-interfaces";
import * as units from "./units";
import * as transportation from "./transportation";
import * as fs from "fs";
import * as path from "path";
import {clone} from "lodash";

/**
 * The IModelApiClient interface is used for forwarding calls to the underlying Mendix Model API.
 * Implementations of this interface serve as fully-typed clients for the Model API Server.
 * Default implementation: {@link ModelApiClientImpl}.
 * Note that all its methods are asynchronous, with the last two arguments always being a (success) callback and an error callback,
 * and we will only explain the "essential" arguments in their documentation.
 *
 * Note: this interface is part of the internal API of the Model SDK.
 *
 * DISCLAIMER: End-users of the SDK should never rely directly on elements of the internal API,
 * e.g. by implementing interfaces or instantiating classes.
 * Anything in this file can be removed, or change signature, even between patch-level SDK versions.
 */
export interface IModelApiClient {

	createWorkingCopy(
		workingCopyInfo: configuration.ICreateWorkingCopyParameters,
		callback: common.ICallback<transport.IWorkingCopy>,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Loads all unit interfaces of the working copy indicated with `workingCopyId` as an array of normalized model JSON.
	 */
	loadUnitInterfaces(workingCopyId: string, callback: common.ICallback<transport.IAbstractUnitJson[]>, errorCallback: common.IErrorCallback);

	/**
	 * Retrieves the top-level working copy information/meta data for the working copy with given `workingCopyId`.
	 */
	loadWorkingCopyMetaData(workingCopyId: string, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback);

	deleteWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	grantAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	revokeAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	checkAccess(workingCopyId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback);

	revokeAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	grantAccessByProject(projectId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback);

	getAppEnvironmentStatus(workingCopyId: string, callback: common.ICallback<transport.IEnvironmentStatus>, errorCallback: common.IErrorCallback);

	/**
	 * Start async deploy flow, creates new app job and returns it
	 */
	startAppUpdate(
		workingCopyId: string,
		callback: common.ICallback<transport.IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Retrieves App Job by jobId
	 */
	getAppUpdateStatus(
		workingCopyId: string,
		jobId: string,
		callback: common.ICallback<transport.IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	);

	getMyWorkingCopies(callback: common.ICallback<transport.IWorkingCopy[]>, errorCallback: common.IErrorCallback);

	exportMpk(workingCopyId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Retrieves a unit, as normalized model JSON, by working copy and unit ID.
	 */
	loadUnitById<T extends units.AbstractUnit>(
		workingCopyId: string,
		unitId: string,
		callback: common.ICallback<transport.IAbstractUnitJson>,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Sends a sequence of deltas on the working copy with the given `workingCopyId` to the Model API Server;
	 * batched if more than one is passed, as a single delta otherwise.
	 */
	sendDeltas(workingCopyId: string, deltas: transport.IDelta[], callback: common.ICallback<Object>, errorCallback: common.IErrorCallback);

	/**
	 * Returns an array of all filepaths in the working copy.
	 */
	getFiles(
		workingCopyId: string,
		options: transport.IGetFilesOptions,
		callback: common.ICallback<string[]>,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Downloads the file specified by the supplied filepath.
	 */
	getFile(
		workingCopyId: string,
		filePath: string,
		outFilePath: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Uploads the supplied file to the specified filepath.
	 */
	putFile(
		workingCopyId: string,
		inFilePath: string | Blob,
		filePath: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Deletes the file with the specified filepath.
	 */
	deleteFile(workingCopyId: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Returns UUIDs for helper working copies for each supported Mendix version.
	 *
	 * These are pre-defined working copies that are accessible for read operations,
	 * and contain units that might come in handy when creating pages from templates.
	 */
	getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback);

	/**
	 * Retrieves the working copy id that the given project ID maps to.
	 */
	getWorkingCopyByProject(projectId, callback: common.ICallback<string>, errorCallback: common.IErrorCallback);

	/**
	 * Update the project-to-working copy mapping with the given data.
	 */
	updateWorkingCopyByProject(
		projectId: string,
		workingCopyId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	);

	/**
	 * Deletes the project-to-working copy mapping for given project ID.
	 */
	deleteWorkingCopyByProject(projectId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Lock the working copy (will be locked for the currently authenticated openid)
	 */
	lockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Unlock the working copy (will be unlocked for the currently authenticated openid, will fail if it's locked by another openid)
	 */
	unlockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);
}

/**
 * Default implementation of {@link IModelApiClient}.
 */
const apiEndPoint = "/api/v1/";
export class ModelApiClientImpl implements IModelApiClient {

	constructor(private transportation: transportation.ITransportation) { }

	private pendingRequests: ILoadUnitByIdRequest[] = [];
	private MAX_PARALLEL_REQUESTS: number = 100;
	private runningRequests: number = 0;

	createWorkingCopy(
		workingCopyInfo: configuration.ICreateWorkingCopyParameters,
		callback: common.ICallback<transport.IWorkingCopy>,
		errorCallback: common.IErrorCallback
	) {
		const data = {
			name: workingCopyInfo.name,
			description: workingCopyInfo.description || "",
			avatarUrl: workingCopyInfo.avatarUrl || "",
			projectId: workingCopyInfo.projectId || "",
			longLived: workingCopyInfo.longLived === true,
			publicReadOnly: workingCopyInfo.publicReadOnly === true,
			teamServerBaseRevision: workingCopyInfo.teamServerBaseRevision || -1,
			teamServerBaseBranch: workingCopyInfo.teamServerBaseBranch || "",
			setAsDefault: workingCopyInfo.setAsDefault === true
		};
		this.transportation.requestMultipartBinaryFileUpload(
			"post", `${apiEndPoint}wc/`, data, "template", workingCopyInfo.template, callback, errorCallback
		);
	}

	loadWorkingCopyMetaData(workingCopyId: string, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback) {
		this.transportation.request("get", `${apiEndPoint}wc/${workingCopyId}`, null, callback, errorCallback);
	}

	loadUnitInterfaces(
		workingCopyId: string,
		callback: common.ICallback<transport.IAbstractUnitJson[]>,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.request("get", `${apiEndPoint}wc/${workingCopyId}/units/`, null, callback, errorCallback);
	}

	deleteWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request("delete", `${apiEndPoint}wc/${workingCopyId}`, null, callback, errorCallback);
	}

	grantAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"put", `${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}`, null, callback, errorCallback
		);
	}

	revokeAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"delete", `${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}`, null, callback, errorCallback
		);
	}

	checkAccess(workingCopyId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"get",
			`${apiEndPoint}wc/${workingCopyId}/members/${encodeURIComponent(memberOpenId)}`,
			null,
			(response: any) => {
				return void callback(response.hasAccess);
			},
			errorCallback
		);
	}

	grantAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"put", `${apiEndPoint}project/${projectId}/members/${encodeURIComponent(memberOpenId)}`, null, callback, errorCallback
		);
	}

	revokeAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"delete", `${apiEndPoint}project/${projectId}/members/${encodeURIComponent(memberOpenId)}`, null, callback, errorCallback
		);
	}

	exportMpk(workingCopyId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.requestFileDownload(
			"get",
			`${apiEndPoint}wc/${workingCopyId}/mpk`,
			this.createDownloadHandler(outFilePath, callback, errorCallback),
			errorCallback
		);
	}

	startAppUpdate(
		workingCopyId: string,
		callback: common.ICallback<transport.IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.request(
			"post",
			`${apiEndPoint}wc/${workingCopyId}/updateapp`,
			null,
			(status: transport.IDeployJobStatus) => {
				this.parseAppUpdateStatus(status);
				callback(status);
			},
			errorCallback
		);
	}

	getAppUpdateStatus(
		workingCopyId: string,
		jobId: string,
		callback: common.ICallback<transport.IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.request(
			"get",
			`${apiEndPoint}wc/${workingCopyId}/updateapp-status?jobid=${jobId}`,
			null,
			(status: transport.IDeployJobStatus) => {
				this.parseAppUpdateStatus(status);
				callback(status);
			},
			errorCallback
		);
	}

	private parseAppUpdateStatus(status: transport.IDeployJobStatus) {
		status.consistencyErrors = this.parseBuildStatus(status.buildstatus);
	}

	loadUnitById<T extends units.AbstractUnit>(
		workingCopyId: string,
		unitId: string,
		callback: common.ICallback<transport.IAbstractUnitJson>,
		errorCallback: common.IErrorCallback
	) {
		this.loadUnitByIdBatched({ workingCopyId, unitId, callback, errorCallback });
	}

	sendDeltas(workingCopyId: string, deltas: transport.IDelta[], callback: common.ICallback<Object>, errorCallback: common.IErrorCallback) {
		this.transportation.request("post", `${apiEndPoint}wc/${workingCopyId}/deltas`, { deltas: deltas }, callback, errorCallback);
	}

	getFiles(
		workingCopyId: string,
		options: transport.IGetFilesOptions,
		callback: common.ICallback<any>,
		errorCallback: common.IErrorCallback
	) {
		if (!options.format) {
			options.format = "json";
		}
		const filterPostfix = options.filter ? "&filter=" + options.filter : "";
		const downloadUrl = `${apiEndPoint}wc/${workingCopyId}/files/?format=${options.format}${filterPostfix}`;
		if (options.format === "json") {
			this.transportation.request("get", downloadUrl, null, callback, errorCallback);
		} else if (options.format === "zip") {
			this.transportation.requestFileDownload(
				"get",
				downloadUrl,
				this.createDownloadHandler(options.path, callback, errorCallback),
				errorCallback
			);
		} else {
			throw new Error("Unsupported format" + options.format);
		}
	}

	getFile(
		workingCopyId: string,
		filePath: string,
		outFilePath: string,
		callback: common.ICallback<any>,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.requestFileDownload(
			"get",
			`${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`,
			this.createDownloadHandler(outFilePath, callback, errorCallback),
			errorCallback
		);
	}

	putFile(
		workingCopyId: string,
		inFilePath: string | Blob,
		filePath: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.requestMultipartBinaryFileUpload(
			"put", `${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`, {}, "file", inFilePath, callback, errorCallback
		);
	}

	deleteFile(workingCopyId: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"delete", `${apiEndPoint}wc/${workingCopyId}/files/${encodeURIComponent(filePath)}`, null, callback, errorCallback
		);
	}

	getAppEnvironmentStatus(workingCopyId: string, callback: common.ICallback<transport.IEnvironmentStatus>, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"get",
			`${apiEndPoint}wc/${workingCopyId}/app-environment-status`,
			null,
			this.handleRawDeploymentResult.bind(this, callback, errorCallback),
			errorCallback,
			true
		);
	}

	getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback) {
		this.transportation.request("get", `${apiEndPoint}editordata`, null, callback, errorCallback);
	}

	getMyWorkingCopies(callback: common.ICallback<transport.IWorkingCopy[]>, errorCallback: common.IErrorCallback) {
		this.transportation.request("get", `${apiEndPoint}wc/`, null, callback, errorCallback);
	}

	getWorkingCopyByProject(projectId, callback: common.ICallback<string>, errorCallback: common.IErrorCallback) {
		this.transportation.request(
			"get",
			`${apiEndPoint}project/${projectId}`,
			null,
			(response: any) => {
				return void callback(response.workingCopyId);
			},
			errorCallback
		);
	}

	createWorkingCopyByProject(
		projectId: string,
		workingCopyId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.request(
			"post",
			`${apiEndPoint}project/${projectId}`,
			{
				projectId: projectId,
				workingCopyId: workingCopyId
			},
			callback,
			errorCallback
		);
	}

	/**
	 * Update the project-to-working copy mapping with the given data.
	 */
	updateWorkingCopyByProject(
		projectId: string,
		workingCopyId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		this.transportation.request(
			"put",
			`${apiEndPoint}project/${projectId}`,
			{
				projectId: projectId,
				workingCopyId: workingCopyId
			},
			callback,
			errorCallback
		);
	}

	/**
	 * Deletes the project-to-working copy mapping for given project ID.
	 */
	deleteWorkingCopyByProject(projectId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request("delete", `${apiEndPoint}project/${projectId}`, null, callback, errorCallback);
	}

	lockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request("post", `${apiEndPoint}wc/${workingCopyId}/lock`, null, callback, errorCallback);
	}

	unlockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this.transportation.request("post", `${apiEndPoint}wc/${workingCopyId}/unlock`, null, callback, errorCallback);
	}

	private sendGetUnitRequest(info: ILoadUnitByIdRequest) {
		this.runningRequests += 1;
		this.transportation.request(
			"get",
			`${apiEndPoint}wc/${info.workingCopyId}/units/${info.unitId}`,
			null,
			(data: any) => {
				this.completeGetUnitRequest();
				return void info.callback(data);
			},
			error => {
				this.completeGetUnitRequest();
				return void info.errorCallback(error);
			}
		);
	}

	private createDownloadHandler(exportPath: string, callback: common.ICallback<any>, errorCallback: common.IErrorCallback) {
		if (exportPath && !fs) {
			throw new Error("cannot download asset to disk without file system");
		}

		return (response: any) => {
			if (exportPath) {
				this.storeResponseAsFile(response, exportPath, () => void callback(null), errorCallback);
			} else {
				return void callback(response);
			}
		};
	}

	private handleRawDeploymentResult(
		callback: common.ICallback<transport.IEnvironmentStatus>,
		errorCallback: common.IErrorCallback,
		deploymentResult: transport.IEnvironmentStatus
	) {
		deploymentResult.consistencyErrors = this.parseBuildStatus(deploymentResult.buildstatus);
		return void callback(deploymentResult);
	}

	private parseBuildStatus(buildstatus: string): transport.IProblem[] {
		// EPO: JSON to object conversion done here, and not earlier in the chain (like in platform-services or in the model-api)
		// because we will skip platform-services and model-api in a later story.
		try {
			if (!buildstatus) {
				return [];
			}
			return JSON.parse(buildstatus).problems as transport.IProblem[];
		} catch (e) {
			console.error("Failed to parse deployment result: " + buildstatus);
			return[{
				name: "BUILD_FAILED",
				severity: "Error",
				message: "Failed to build: " + buildstatus,
				locations: []
			}];
		}
	}

	private storeResponseAsFile(response: any, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		let dirPath = path.dirname(outFilePath);
		fs.lstat(dirPath, (err, stats) => {
			if (err || !stats.isDirectory()) {
				let cwd = eval("process.cwd()");	// kludge to work around Node.js typings not being available for Model SDK
				return void errorCallback(new Error(`target directory ${dirPath} does not exist relative to ${cwd}`));
			}
			fs.open(outFilePath, "w", (err, fd) => { // open for (over-)writing
				if (err) {
					return void errorCallback(new Error(`Could not create file with path "${outFilePath}"; due to: ${err}`));
				}
				fs.writeFile(outFilePath, response, "binary", err => {
					if (err) {
						return void errorCallback(new Error(`Could not write to file with path "${outFilePath}"; due to: ${err}`));
					}
					return void callback(); // make sure we don't expose any arguments to the end-user
				});
			});
		});
	}

	private loadUnitByIdBatched(info: ILoadUnitByIdRequest) {
		if (this.runningRequests < this.MAX_PARALLEL_REQUESTS) {
			this.sendGetUnitRequest(info);
		} else {
			this.pendingRequests.push(info);
		}
	}

	private completeGetUnitRequest() {
		this.runningRequests -= 1;
		if (this.runningRequests < this.MAX_PARALLEL_REQUESTS && this.pendingRequests.length > 0) {
			this.sendGetUnitRequest(this.pendingRequests.shift());
		}
	}

}

type ILoadUnitByIdRequest = {
	workingCopyId: string;
	unitId: string;
	callback: common.ICallback<transport.IAbstractUnitJson>;
	errorCallback: common.IErrorCallback;
}

export type IEditorData = {
	[mmVersion: string]: { pageTemplates: string }
}

