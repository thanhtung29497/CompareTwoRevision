import {utils} from "../utils";
import {AbstractElement} from "./elements";
import {AbstractModel} from "./abstract-model";
import {instancehelpers} from "./instances";
import {find} from "lodash";
import {IStructure, Structure} from "./structures";


const NEW_ARRAY = () => [];

/**
 * Manages a cached map [qualified name: string] -> list of structures,
 * with the possibility to retrieve (resolve) based on qualified name.
 *
 * Used to speed up resolution of by-(qualified-)name references.
 */
export default class QualifiedNameCache {

	private _cache: utils.IMap<AbstractElement[]> = {};

	constructor(private _model: AbstractModel) {
	}

	resolve(typeName: string, qualifiedName: string) {
		if (!qualifiedName) {
			return null;
		}

		const elements = this._cache[qualifiedName];
		if (!elements) {
			return null;
		}

		if (!typeName) {
			throw new Error("please provide a typename");
		}

		const initializer = instancehelpers.lookupClass(typeName, this._model._allModelClasses());
		return find(elements, elem => elem instanceof initializer);
	}

	/**
	 * Recursively adds this structure and its children to the elements cache.
	 */
	addStructureToCache(structure: IStructure) {
		// If a structure was renamed and it is a namespace, the name change also effects the names of children, hence the traverse.
		structure.traversePublicParts(this.addElementToCache);
	}

	removeStructureFromCache(structure: IStructure) {
		if (structure instanceof AbstractElement && structure._registeredQualifiedName) {
			utils.removeFromArray(this._cache[structure._registeredQualifiedName], structure);
		}
	}

	/**
	 * Updates the cache as far as it is affected by the rename of this element.
	 * Child entries are updated automatically as well.
	 */
	processNameChange(structure: IStructure) {
		// If it is a namespace or the structure is by name referrable the cache should be updated.
		if (instancehelpers.structureAffectsQualifiedNames(structure as Structure)) {
			structure.traversePublicParts(this.addElementToCache);
		}
	}

	private addElementToCache: (structure: IStructure) => void = (structure: IStructure) => {
		if (structure instanceof AbstractElement && structure._isByNameReferrable()) {
			const oldName = structure._registeredQualifiedName;
			const newName = structure._registeredQualifiedName = structure.qualifiedName;
			// Note: qname might be an empty string!
			if (oldName === newName) {
				return;
			}
			if (oldName !== undefined) {
				utils.removeFromArray(this._cache[oldName], structure);
			}
			utils.getOrCreateMapEntry(this._cache, newName, NEW_ARRAY).push(structure);
		}
	};

}
