import {IAbstractModel} from "./abstract-model";
import * as structures from "./structures";
import {AbstractProperty} from "./properties/abstract-property";
import {utils} from "../utils";


export interface ILifeCycle {
	introduced?: string;
	deprecated?: string;
	deleted?: string;
	deprecationMessage?: string;
	deletionMessage?: string;
}


export interface IModifierValueHistory {
	currentValue: boolean;
	/** descending list of change in previous meta model versions */
	changedIn?: string[];
}


export interface IStructureVersionInfo extends ILifeCycle {
	public?: IModifierValueHistory;
	experimental?: IModifierValueHistory;
	properties?: { [name: string]: IPropertyVersionInfo };
}


export interface IPropertyVersionInfo extends ILifeCycle {
	public?: IModifierValueHistory;
	required?: IModifierValueHistory;
}


export class Version {

	constructor(public major: number, public minor: number, public patch: number) {
		// (empty constructor)
	}

	private static memoisMap: { [versionString: string]: Version } = {};

	/**
	 * Parses and @returns the given string as a Version object.
	 *
	 * This function is memoised to keep memory and time consumption low,
	 * given that only a handful of versions exist at any time anyway.
	 */
	static parse(versionString: string) {
		if (!versionString) {
			return null;
		}
		let version: Version = Version.memoisMap[versionString];
		if (!version) {
			const [major, minor, patch] = versionString.split(".").map(x => parseInt(x, 10));
			version = new Version(major, minor, patch);
			Version.memoisMap[versionString] = version;
		}
		return version;
	}

	/**
	 * Returns true if this version is strictly larger than the provided version.
	 */
	public isAfter(other: Version) {
		return this.major > other.major
			|| (this.major === other.major && this.minor > other.minor)
			|| (this.major === other.major && this.minor === other.minor && this.patch > other.patch);
	}

	public isAfterOrEqual(other: Version) {
		return this.isEqualTo(other) || this.isAfter(other);
	}

	/**
	 * Returns true if this version is strictly smaller compared to the provided version.
	 */
	public isBefore(other: Version) {
		return this.major < other.major
			|| (this.major === other.major && this.minor < other.minor)
			|| (this.major === other.major && this.minor === other.minor && this.patch < other.patch);
	}

	public isBeforeOrEqual(other: Version) {
		return this.isEqualTo(other) || this.isBefore(other);
	}

	public isEqualTo(other: Version) {
		return this.major === other.major && this.minor === other.minor && this.patch === other.patch;
	}

	public toString() {
		return `${this.major}.${this.minor}.${this.patch}`;
	}

}


/**
 * Parses the given string as a sem-Version, ignoring non-numeric and "extra" data,
 * and padding with ".0" where necessary.
 */
export function parseAsNormalizedVersion(versionString: string): Version {
	const parts = versionString.split(".", 3).map(p => p.replace(/^(\d*).*$/, (_, nr) => nr || "0"));
	while (parts.length < 3) {
		parts.push("0");
	}
	return Version.parse(parts.join("."));
}


export enum LifeCycleState { UNAVAILABLE, AVAILABLE, DEPRECATED, REMOVED };


export class LifeCycle {

	introduced: Version; // null indicates available in base version
	deprecated: Version; // null indicates not deprecated anywhere
	deleted: Version; // null indicates not removed anywhere
	deprecationMessage: string = "";
	deletionMessage: string = "";

	constructor(info: ILifeCycle) {
		if (info) {
			this.introduced = Version.parse(info.introduced);
			this.deprecated = Version.parse(info.deprecated);
			this.deleted = Version.parse(info.deleted);
			this.deprecationMessage = info.deprecationMessage || "";
			this.deletionMessage = info.deletionMessage || "";
		}
	}


	// TODO  make the following more symmetric

	/**
	 * Yields true if this feature is available in the specified version, that is:
	 * - it was in base, or added before the specified version
	 * - it was not removed yet in the given version
	 * - deprecation statues does not influence it results
	 */
	isAvailableIn(version: Version) {
		if (this.isRemovedIn(version)) {
			return false;
		}
		if (!this.introduced || this.introduced.isBeforeOrEqual(version)) {
			return true;
		}
		return false;
	}

	/**
	 * Yields true only if the feature is available, (added but not yet removed) and deprecated in the specified version.
	 */
	isDeprecatedIn(version: Version) {
		return this.isAvailableIn(version) && this.deprecated != null && this.deprecated.isBeforeOrEqual(version);
			// Note: '!==' causes almost all unit tests to fail...
	}

	/**
	 * Yields true only if this version was actively removed in the given version.
	 * Doesn't yield true if the feature was not yet introduced in the given version (see isAvailableIn for that)
	 */
	isRemovedIn(version: Version) {
		return this.deleted != null && this.deleted.isBeforeOrEqual(version);
			// Note: '!==' causes almost all unit tests to fail...
	}

	getCurrentState(version: Version): LifeCycleState {
		if (this.isRemovedIn(version)) {
			return LifeCycleState.REMOVED;
		}
		if (!this.isAvailableIn(version)) {
			return LifeCycleState.UNAVAILABLE;
		}
		if (this.isDeprecatedIn(version)) {
			return LifeCycleState.DEPRECATED;
		}
		return LifeCycleState.AVAILABLE;
	}


	/**
	 * Checks a version based on this lifecycle.
	 * Returns true if something is thrown or warned, otherwise false
	 */
	reportVersionIssues(version: Version, aboutWhatMessage: string, printWarnings: boolean): boolean {
		switch (this.getCurrentState(version)) {
			case LifeCycleState.UNAVAILABLE:
				throw new Error(
					`${aboutWhatMessage} is not yet available in Mendix version ${version}. It was introduced in Mendix version ${this.introduced}`
				);
			case LifeCycleState.DEPRECATED:
				if (printWarnings) {
					utils.warnOnce(
						`${aboutWhatMessage} is deprecated in Mendix version ${version} (deprecated since Mendix version ${this.deprecated}) `
						+ `and should no longer be instantiated: ${this.deprecationMessage}`
					);
				}
				return true;
			case LifeCycleState.REMOVED:
				throw new Error(
					`${aboutWhatMessage} can no longer be instantiated in Mendix version ${version} `
					+ `(removed since Mendix version ${this.deleted}): ${this.deletionMessage}.`
				);
			case LifeCycleState.AVAILABLE:
				return false;
			default:
				throw new Error("Illegal state");
		}
	}

}


export class ModifierValueHistory {

	latestValue: boolean;

	/**
	 * ordered from low to high
	 */
	changedIn: Version[];

	/**
	 * defaultFallback indiciates whether the absence of a lifecycle yields true or false
	 */
	constructor(lifecycle: IModifierValueHistory, defaultFallback: boolean) {
		if (lifecycle) {
			this.latestValue = lifecycle.currentValue;
			this.changedIn = lifecycle.changedIn ? lifecycle.changedIn.map(Version.parse) : [];
			for (let i = 0; i < this.changedIn.length - 1; i++) {
				if (!this.changedIn[i + 1].isBefore(this.changedIn[i])) {
					throw new Error("The list of version changes is not ordered correctly: " + JSON.stringify(lifecycle));
				}
			}
		} else {
			this.changedIn = [];
			this.latestValue = defaultFallback;
		}
	}

	isEnabledIn(version: Version) {
		if (this.changedIn.length === 0) {
			return this.latestValue;
		}
		const nonRelevant = this.changedIn.filter(changedInVersion => version.isBefore(changedInVersion));
		// odd or even number of toggles from now back to the relevant version ?
		return nonRelevant.length % 2 === 0 ? this.latestValue : !this.latestValue;
	}

}


export enum StructureType { StructuralUnit, ModelUnit, Element };

export abstract class VersionInfo {
	checkSameModelVersion(model: IAbstractModel, otherModel: IAbstractModel) {
		if (model !== otherModel) {
			throw new Error("It is not possible to combine values coming from two different models");
		}
	}
}


export class StructureVersionInfo extends VersionInfo {

	availability: LifeCycle;
	isPublic: ModifierValueHistory;
	isExperimental: ModifierValueHistory;
	properties: { [name: string]: PropertyVersionInfo } = {};
	defaultPropertyInfo: PropertyVersionInfo;

	constructor(info: IStructureVersionInfo, public structureType: StructureType) {
		super();
		this.availability = new LifeCycle(info);
		this.isPublic = structureType === StructureType.Element
			? new ModifierValueHistory(info.public, false)
			: new ModifierValueHistory(null, true);
		this.isExperimental = new ModifierValueHistory(info.experimental, false);

		const propertiesArePublicByDefault = structureType === StructureType.StructuralUnit;
		for (let key in info.properties) {
			this.properties[key] = new PropertyVersionInfo(info.properties[key], propertiesArePublicByDefault);
		}
		this.defaultPropertyInfo = new PropertyVersionInfo(null, propertiesArePublicByDefault);
	}

	checkStructureVersion(instance: structures.IStructure, includeWarnings: boolean) {
		const {availability} = this;
		const {metaModelVersion} = instance.model;
		const {typeName} = instance;
		let hasVersionIssues = availability.reportVersionIssues(metaModelVersion, `Type '${typeName}'`, includeWarnings);
		if (!hasVersionIssues) {
			if (includeWarnings && this.isExperimental && this.isExperimental.isEnabledIn(metaModelVersion)) {
				utils.warnOnce(`Type '${typeName}' is experimental in Mendix meta model version ${metaModelVersion} and should be used with care.`);
			}
		}
		// There is no need to check super structures: each structure has its own complete set of annotations in the meta model.
	}

	getPropertyVersionInfo(name: string): PropertyVersionInfo {
		return this.properties[name] ? this.properties[name] : this.defaultPropertyInfo;
	}

}


export class PropertyVersionInfo extends VersionInfo {

	availability: LifeCycle;
	isPublic: ModifierValueHistory;
	isRequired: ModifierValueHistory;

	constructor(info: IPropertyVersionInfo, publicByDefault: boolean) {
		super();
		this.availability = new LifeCycle(info);
		this.isPublic = new ModifierValueHistory(info ? info.public : null, publicByDefault);
		this.isRequired = new ModifierValueHistory(info ? info.required : null, false);
	}

	checkPropertyVersion(property: AbstractProperty<any, any>, includeWarnings: boolean) {
		const {name} = property;
		const {metaModelVersion} = property.parent.model;
		const {availability} = property.parent.versionInfo.getPropertyVersionInfo(name);
		const {typeName} = property.parent;
		availability.reportVersionIssues(metaModelVersion, `Property '${name}' of type '${typeName}'`, includeWarnings);
	}

}


export function createInVersionCheck(model: IAbstractModel, typeName: string, allowedVersions: string[]) {
	const version = model.metaModelVersion.toString();
	if (allowedVersions.indexOf(version) === -1) {
		throw new Error(
			`In Mendix version ${version} it is illegal on instances of ${typeName} to call the "createIn" method, `
			+ `either because it's ambiguously contained or derived.`
		);
	}
}


export function isNotBefore(versionString: string, model: IAbstractModel) {
	return model.metaModelVersion.isAfterOrEqual(Version.parse(versionString));
}

