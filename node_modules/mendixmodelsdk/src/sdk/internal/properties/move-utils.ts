

/**
 * @returns whether indices.asSet equals [0, 1, ..., (indices.length - 1)].
 */
export function isPermutation(indices: number[]): boolean {
	const sorted = indices.slice().sort((x, y) => x - y - 0);	// defensive copy + defeat broken JS sorting...
	for (let i = 0; i < sorted.length; i++) {
		if (i !== sorted[i]) {
			return false;
		}
	}
	return true;
}


export interface IRun {
	count: number;
	value: number;
}

export function runLenghtEncode(values: number[], max: number = 4): IRun[] | void {
	const runs: IRun[] = [];
	let lastValue = NaN;
	let currentRun: IRun;
	for (let i = 0; i < values.length; i++) {
		if (values[i] === lastValue) {
			currentRun.count++;
		} else {
			lastValue = values[i];
			currentRun = { count: 1, value: lastValue };
			runs.push(currentRun);
			if (runs.length > max) {
				return null;
			}
		}
	}
	return runs;
}


/**
 * @returns the move action expressed by the given indices, expressed as an array `[fromIndex, toIndex]`,
 * 	or `null` if it's not a move.
 */
export function detectMove(indices: number[]): number[] | void {
	if (!isPermutation(indices)) {
		return null;
	}

	const runsOrNull = runLenghtEncode(indices.map((num, i) => num - i), 4);
	if (!runsOrNull) {
		return null;
	}

	const runs = runsOrNull as IRun[];
	if (runs.length < 2) {
		return null;
	}

	// "un-degenerate":
	if (runs[0].value !== 0) {
		runs.unshift({ count: 0, value: 0 });
	}
	if (runs[runs.length - 1].value !== 0) {
		runs.push({ count: 0, value: 0 });
	}

	if (runs.length !== 4) {
		return null;
	}

	const n = indices.length;
	if (runs[1].value === 1) {	// f < t
		const f = runs[0].count;
		const t = runs[1].count + f;
		if (runs[2].count === 1 && runs[2].value === (f - t) && runs[3].count === (n - t - 1) && runs[3].value === 0) {
			return [ f, t ];
		}
	} else if (runs[1].count === 1) {	// f > t
		const t = runs[0].count;
		const f = runs[1].value + t;
		if (runs[2].count === (f - t) && runs[2].value === -1 && runs[3].count === (n - f - 1) && runs[3].value === 0) {
			return [ f, t ];
		}
	}

	return null;
}


/**
 * @returns whether the members of the two given arrays are identical (using object comparison),
 * and occur in the same order.
 */
export function areIdentical<T>(left: T[], right: T[]): boolean {
	if (left.length !== right.length) {
		return false;
	}
	for (let i = 0; i < left.length; i++) {
		if (left[i] !== right[i]) {	// (should be object comparison)
			return false;
		}
	}
	return true;
}

