import {observe} from "mobx";

import * as references from "../references";
import * as structures from "../structures";
import * as versions from "../version-checks";
import {utils} from "../../utils";


/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
export abstract class AbstractProperty<T, P> {

	handle: () => void;
	observableValue: P;

	/**
	 * parent is the structure that the value of this property attaches to,
	 * so e.g. for all values `item` of Part(List)Property we (should) have the invariant:
	 * 	item.container === this.parent.
	 *
	 * initialValue is default value except parts and GUID-typed primitives.
	 * (by-id/name references do not have default values.)
	 */
	constructor(declaredOn, parent: structures.Structure, name: string, initialValue: T, ...moreArgs: any[])
	constructor(public declaredOn, public parent: structures.Structure, public name: string, ...initializeArgs: any[]) {
		parent._registerProperty(this);
		this.observableValue = this.initialize.apply(this, initializeArgs);
		if (this.observableValue instanceof references.AbstractReference) {
			this.handle = (this.observableValue as any as references.AbstractReference<any>).observe(this.fireOnChange.bind(this), false);
		} else {
			this.handle = observe(this.observableValue, this.fireOnChange.bind(this), false);
		}
	}

	public get versionInfo(): versions.PropertyVersionInfo {
		return ((this.declaredOn["versionInfo"]) as versions.StructureVersionInfo).getPropertyVersionInfo(this.name);
	}

	public get isPublic(): boolean {
		return this.versionInfo.isPublic.isEnabledIn(this.parent.model.metaModelVersion);
	}

	public get isRequired(): boolean {
		return this.versionInfo.isRequired.isEnabledIn(this.parent.model.metaModelVersion);
	}

	/**
	 * Returns true if this property is not deleted, and already availabe in the current model version.
	 */
	public get isAvailable(): boolean {
		return this.versionInfo.availability.isAvailableIn(this.parent.model.metaModelVersion);
	}

	/**
	 * Initialize should return something that is observable.
	 * The property will observe this internal structure
	 * and make sure changes are pushed to the server whenever needed, in its onChange event.
	 */
	initialize(value: T, ...moreConstructorArgs: any[]): P {
		throw new Error("This function should be overriden in subclass");
	}

	fireOnChange() {
		if (!this.parent._isUpdating) {
			this.assertWritable();
			this.onChange.apply(this, arguments);
		}
	}

	onChange(...args: any[]) {
		throw new Error("This function should be overridden in subclass");
	}

	get(): T {
		throw new Error("This function should be overridden in subclass");
	}

	set(newValue: T) {
		throw new Error("This function should be overridden in subclass");
	}

	updateWithRawValue(value: any) {
		throw new Error("This function should be overridden in subclass");
	}

	assertWritable() {
		this.parent._assertLoaded(this);
		this.assertPropertyAvailableInCurrentVersion();
	}

	assertReadable() {
		if (!this.isPublic) {
			this.parent._assertLoaded(this);
		}
		this.assertPropertyAvailableInCurrentVersion();
	}

	assertPropertyAvailableInCurrentVersion() {
		// parent check is done here and not in property info, because the actual type of the structure
		// might have different version annations as the type that declared the property
		this.parent.versionInfo.checkStructureVersion(this.parent, true);
		this.versionInfo.checkPropertyVersion(this, true);
	}

	resolveReferences() {
		// empty stub
	}

	dispose() {
		this.handle();
	}

	abstract deepCopyInto(
		clone: structures.Structure,
		idMap?: utils.IMap<structures.Structure>,
		unresolvedIdentifierFixers?: ((idMap: utils.IMap<structures.Structure>) => void)[]
	);

	_toJSON(): any {
		throw new Error(`Cannot JSON-serialize property: ${this} (this function should be overridden in sub class)`);
	}

}
