import {AbstractProperty} from "./abstract-property";
import {AbstractElement} from "../elements";
import {ByIdReference} from "../references";


/**
 * Property value that references a (model) element by id.
 */
export class ByIdReferenceProperty<T extends AbstractElement> extends AbstractProperty<T, ByIdReference<T>> {

	parent: AbstractElement;

	initialize(value: T) {
		return new ByIdReference<T>(this.parent);
	}

	get(): T {
		this.assertReadable();
		return this.observableValue.get();
	}

	set(value: T) {
		this.assertWritable();
		if (!value && this.isRequired) {
			throw new Error(`Cannot unset property that is a required by-id reference`);
		}
		this.observableValue.set(value);
	}

	updateWithRawValue(value: string) {
		this.observableValue.updateWithRawValue(value);
	}

	resolveReferences() {
		this.observableValue.resolve();
	}

	onChange(newValue: T, oldValue: T) {
		this.assertWritable();
		this.observableValue.assertValueHasSameUnit();
		this.parent._sendChangeDelta(this.name, newValue ? newValue.id : null);
	}

	updateElementContainer() {
		// We didn't know our container before, now we know it, let's check the referred value:
		this.observableValue.assertValueHasSameUnit();
	}

	dispose() {
		this.observableValue.dispose();
		super.dispose();
	}

	_toJSON() {
		const value = this.get();
		return value ? value.id : null;
	}

	deepCopyInto(clone, idMap, unresolvedIdentifierFixers) {
		unresolvedIdentifierFixers.push(idMap => {
			const val = this.get();
			if (!val) {
				// no target
				clone[this.name] = val;
			} else {
				if (idMap.hasOwnProperty(val.id)) {
					// The target was cloned
					clone[this.name] = idMap[val.id];
				} else {
					// The target was outside the cloned range, restore ref if still in same unit.
					if (clone.unit === val.unit) {
						clone[this.name] = val;
					}
				}
			}
		});
	}

}

// TODO  ByIdReferenceListProperty

