import {IArrayChange, IArraySplice, IObservableArray, IObservableValue, asFlat, asReference, observable} from "mobx";

import {AbstractProperty} from "./abstract-property";
import {IList} from "../instances";
import {IModelUnit, IStructuralUnit, ModelUnit, StructuralUnit} from "../units";


/**
 * Note: structural child values are updated through AbstractModel._addUnitToStructuralParent.
 */

/**
 * Value of a property owned by a structural unit.
 */
export class StructuralChildProperty<T extends IStructuralUnit | IModelUnit> extends AbstractProperty<T, IObservableValue<T>> {

	constructor(declaredOn, parent: StructuralUnit, name: string, value: T, targetRefType?: string) {
		super(declaredOn, parent, name, value);
	}

	initialize(value: T) {
		return observable(asReference(value)) as any as IObservableValue<T>;
	}

	get(): T {
		this.assertReadable();
		return this.observableValue.get();
	}

	set(value: T) {
		if (value) {
			console.warn("Cannot directly set a structural child property");
		// TODO  make unit test for this and comment-in
		// } else if (this.isRequired) {
		// 	console.warn("Cannot delete a unit through a required property");
		} else {
			const unit = this.observableValue.get();
			if (unit instanceof ModelUnit) {
				(unit as any as ModelUnit).delete();
				this.observableValue.set(null);
			} else {
				console.warn("Cannot delete a structural unit");
			}
		}
	}

	updateWithRawValue(value) {
		throw new Error("Illegal state: cannot update a structural child property");
	}

	onChange(changeData: any) {
		// do nothing
		// TODO  changeData seems to be always null: is that correct and expected?
	}

	dispose() {
		// do nothing
	}

	deepCopyInto() {
		/*
		Structural children are not copied by default, that would require
		loading and cloning all children, which is probably not desirable.

		const child =  this.get();
		if (child) {
			child.deepCopyInto(clone);
		}*/
	}

}


/**
 * Property instance that wraps a list of structural units.
 * Structural child values are updated through AbstractModel._addUnitToStructuralParent.
 */
export class StructuralChildListProperty<T extends IStructuralUnit | IModelUnit>
	extends AbstractProperty<T[], IObservableArray<T>> {

	constructor(declaredOn, parent: StructuralUnit, name: string, value: T[], targetRefType?: string) {
		super(declaredOn, parent, name, value);
	}

	initialize(values) {
		return observable(asFlat(values || [])) as any;
	}

	get(): IList<T> {
		this.assertReadable();
		return this.observableValue;
	}

	set(value: T[]) {
		console.warn("Cannot set a structural child property");
	}

	updateWithRawValue(value) {
		throw new Error("Illegal state: cannot update a structural child property");
	}

	onChange(changeData: IArrayChange<T> | IArraySplice<T>) {
		this.assertWritable();
		// For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
		switch (changeData.type) {
			case "splice": {
				const splice = changeData as IArraySplice<T>;
				splice.removed.forEach(unit => this.processChildRemoval(unit));
				for (let i = splice.index; i < splice.index + splice.addedCount; i++) {
					this.processChildAddition(i);
				}
				return;
			}
			case "update": {
				const update = changeData as IArrayChange<T>;
				this.processChildRemoval(update.oldValue);
				this.processChildAddition(update.index);
				return;
			}
		}
	}

	processChildRemoval(unit: T) {
		/* If the unit was removed and not inserted at another place
		* (either on another parent or in the same parent on another index),
		* remove it:
		*/
		if (unit instanceof StructuralUnit) {
			throw new Error("Deletion of structural child units is not yet implemented");
		}
		if (this.observableValue.indexOf(unit) === -1) {
			unit.container = null;

			((unit as any as IModelUnit) as any).clearBackReferences();
			(unit as any as IModelUnit).delete();
				// Note: have to use 'as any' to get around lack of control flow analysis in TS 1.8.10 compiler.
		}
	}

	processChildAddition(index: number) {
		console.warn("Adding a unit to a (property of a) structural unit is part of creating that unit");
	}

	dispose() {
		// do nothing
	}

	deepCopyInto(clone) {
		/*
		Structural children are not copied by default, that would require
		loading and cloning all children, which is probably not desirable.

		this.get().forEach(child => child.deepCopyInto(clone));
		*/
	}

}
