\documentclass[12pt]{amsart}

\usepackage[a4paper,margin=1.5cm,footskip=1.0cm]{geometry}

%\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\move}[2]{\ensuremath{#1 \rightarrow #2}}
\newcommand{\range}[2]{\ensuremath{[#1, #2)}}
\newcommand{\s}[1]{\ensuremath{\{ #1 \}}}	% singleton
\newcommand{\concat}[0]{\ensuremath{, \;}}
\newcommand{\rep}[2]{\ensuremath{\left<#1 \times \, #2^{\ast}\right>}}	% repetition

\title{Recognizing simple list moves}
\author{Meinte Boersma - Mendix}

\begin{document}

\begin{abstract}
In this internal "article", I'll derive an algorithm to recognize a simple move within a list.
This helps with implementing reactive list moves in the Model SDK.
\end{abstract}

\maketitle

\section{Simple moves}

Consider a list of length $n$ (being a positive integer) of elements (in some domain, which is effectively irrelevant) $l_0, \ldots, l_{n-1}$.
(I'll index lists from 0 to ensure compatibility with e.g. JavaScript.)
By identifying elements with their indices, we can restrict our reasoning to lists and sub ranges of integers $0, \ldots, n-1$.

To further ease up on notation, I'll use the notation for half-open intervals $\range{i}{j}$ to denote the list of integers $i, \ldots, j-1$.
Note that this matches well with JavaScript's \texttt{Array.slice} function: $\range{0}{n}$\texttt{.slice($i$, $j$) == }$\range{i}{j}$.

Consider a simple move $\move{f}{t}$ (where $0 \leq f, t < n$) which moves the element at index $f$ (for "from") to index $t$ (for "to"), leaving the other elements as much as possible on the same index.
Apart from the trivial situation where $f = t$, we can distinguish two situations:

\begin{equation} \label{simpleMove}
\move{f}{t} \equiv
	\begin{cases}
		\range{0}{f} \concat \range{(f+1)}{(t+1)} \concat \s{f} \concat \range{(t+1)}{n},	& f < t \\
		\range{0}{t} \concat \s{f} \concat \range{t}{f} \concat \range{(f+1)}{n},			& f > t
	\end{cases}
\end{equation}
('$\concat$' translates to \texttt{Array.concat} or variations thereof.)


\section{Recognizing simple moves}

How can we recognize whether a list of indices $i_0, \ldots, i_{n-1}$ represents a move like in \eqref{simpleMove}?

Note that $\move{m}{m + 1} \equiv \move{m + 1}{m}$.
Let's disambiguate this by always favouring the variant with $f < t$.

Consider the list of integers $i_0 - 0, i_1 - 1, \ldots, i_j - j, \ldots, i_{n-1} - (n-1)$ and denote it as $L(i_0, \ldots, i_{n-1})$.

Let $\rep{n}{c}$ means "$n$ times the integer $c$".
Applying the process of subtracting the index from each list element to \eqref{simpleMove} gives us:
$$
L(\move{f}{t}) \equiv
\begin{cases}
	\rep{f}{0} \concat \rep{(t-f)}{1} \concat \rep{1}{(f-t)} \concat \rep{(n-t-1)}{0},		& f < t \\
	\rep{t}{0} \concat \rep{1}{(f-t)} \concat \rep{(f-t)}{-1} \concat \rep{(n-f-1)}{0},		& f > t
\end{cases}
$$
(A quick check asserts that these lists are of the correct length.)

Note the following:
\begin{itemize}
	\item Neither case can degenerate into $\rep{x}{0} \concat \rep{y}{\pm 1} \concat \rep{z}{0}$.
	\item Since we favour $\move{f}{f+1}$ over $\move{f+1}{f}$, we don't have to consider a single $1$ appearing in the second case.
		(Instead, we'd have a single $1$ appearing in the first case.)
	\item If the list doesn't appear to start or end with 0's, we can "un-degenerate" the situation by adding $\rep{0}{0}$ to the applicable side(s).
	\item After un-degeneration, the list should have precisely four repetitions, and $f$ and $t$ can be derived from the first two of these.
		(Note that we still have to check the other two repetitions for correctness.)
\end{itemize}

\end{document}
