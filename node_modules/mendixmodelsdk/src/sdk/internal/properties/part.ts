import {IArrayChange, IArraySplice, IObservableArray, IObservableValue, asFlat, asReference, observable} from "mobx";

import {AbstractProperty} from "./abstract-property";
import {AbstractElement, Element} from "../elements";
import {instancehelpers} from "../instances";
import {ModelUnit, IModelUnit} from "../units";
import {areIdentical, detectMove} from "./move-utils";

/* for debugging:
function describe(element: Element) {
	if (!element) {
		return "null";
	}
	let description = `${element.typeName}(id=${element.id}`;
	description += `, container: `;
	if (element.container) {
		const childHandle = element.container._childHandle(element);
		description += `{id=${element.container.id}, property=${childHandle ? childHandle.containingProperty.name : "ill-defined!"}}`;
	} else {
		description += "null";
	}
	description += ")";
	return description;
}
 */


/**
 * A property value that is a (model) element.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
export class PartProperty<T extends Element> extends AbstractProperty<T, IObservableValue<T>> {

	public parent: AbstractElement;

	private hasDefaultValue: boolean;

	initialize(value: T, hasDefaultValue: boolean) {
		this.hasDefaultValue = hasDefaultValue;
		return observable(asReference(value)) as any as IObservableValue<T>;
	}

	get() {
		this.assertReadable();
		return this.observableValue.get();
	}

	set(newValue: T) {
		if (this.isRequired && !newValue) {
			throw new Error(`Cannot unset required part property`);
		}
		this.assertWritable();
		const oldValue = this.observableValue.get();
		if (newValue === oldValue) {
			return;		// (nothing to do)
		}
		if (newValue) {
			newValue.versionInfo.checkSameModelVersion(newValue.model, this.parent.model);
			newValue.versionInfo.checkStructureVersion(newValue, true);
			if (newValue._isNew) { // just created
				newValue.container = this.parent;
				if (!this.parent._isNew) {
					newValue._updateElementsContainer(this.parent.unit as ModelUnit);
					this.parent._model._qualifiedNameCache.addStructureToCache(newValue);
				}
				newValue._sendCreateDelta(this.parent, this.name);
			} else { // moved TO here
				newValue._sendMoveDelta(this.parent, this.name);
				const oldParent = newValue.container;
				const childHandle = oldParent._childHandle(newValue);	// !== undefined
				if (oldParent) {
					if (oldParent === this.parent) {	// move within containing structure
						if (this !== childHandle.containingProperty) {	// ...from other property
							childHandle.detach();
						}
					} else {
						newValue.container = this.parent;
						childHandle.detach();
					}
				}
				if (oldValue) {	// old value is replaced: detach it from parent and delete it
					oldValue.container = null;
					oldValue.delete();
				}
			}
		}

		this.observableValue.set(newValue);
	}

	updateWithRawValue(value) {
		const newChild = instancehelpers.modelElementJsonToInstance(
				this.parent._model, this.parent.unit as ModelUnit, this.parent, value, this.parent._isPartial
			) as T;

		// cleanup old value, we got a server side change that this child is no longer ours:
		const currentChild = this.observableValue.get();
		if (currentChild !== null && currentChild !== newChild) {
			currentChild._dispose();
		}

		this.observableValue.set(newChild);
	}

	onChange(newValue: T, oldValue: T) {
		// (do nothing)
	}

	resolveReferences() {
		if (this.observableValue.get()) {
			this.observableValue.get()._resolveReferences();
		}
	}

	updateElementContainer(unit: ModelUnit) {
		if (this.observableValue.get()) {
			this.observableValue.get()._updateElementsContainer(unit);
		}
	}

	dispose() {
		if (this.observableValue.get()) {
			this.observableValue.get()._dispose();
		}
	}

	_toJSON() {
		const value = this.get();
		return value ? value.toJSON() : null;
	}

	deepCopyInto(clone, idMap, unresolvedIdentifierFixers) {
		const val = this.get();
		if (val === null) {
			clone[this.name] = val;
		} else {
			val._deepCopyStructureInto(clone, this.name, idMap, unresolvedIdentifierFixers);
		}
	}

}


/**
 * A property value that is a list of (model) elements.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
export class PartListProperty<T extends Element> extends AbstractProperty<T[], IObservableArray<T>> {

	parent: AbstractElement;

	/*
	* Currently, only possible default value for listy properties is [],
	* so we don't have to store initialItems to be able to distinguish from default value.
	*/

	initialize(initialItems: T[]) {
		return observable(asFlat(initialItems || []));
	}

	get() {
		this.assertReadable();
		return this.observableValue;
	}

	set(newValue: T[]) {
		this.assertWritable();
		this.observableValue.replace(newValue);
	}

	updateWithRawValue(value) {
		const newChildren = value.map(e =>
			instancehelpers.modelElementJsonToInstance(
				this.parent._model, this.parent.unit as ModelUnit, this.parent, e, this.parent._isPartial
			) as T
		);
		const oldChildren = this.observableValue;

		// dispose old children:
		for (let i = 0; i < oldChildren.length; i++) {
			if (newChildren.indexOf(oldChildren[i]) === -1) {
				oldChildren[i]._dispose();
			}
		}

		this.observableValue.replace(newChildren);
	}

	onChange(changeData: IArrayChange<T> | IArraySplice<T>) {
		this.assertWritable();
		// For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
		switch (changeData.type) {
			case "splice": {
				const splice = changeData as IArraySplice<T>;
				// idempotent?:
				if (areIdentical(splice.added, splice.removed)) {
					return;
				}
				if (this.observableValue.length === splice.addedCount && splice.addedCount === splice.removedCount) {
					const indices = splice.removed.map(item => this.observableValue.indexOf(item));
						// Note: for some reason we need to inspect splice.removed and then reverse indices?!
					let moveData = detectMove(indices);
					if (moveData) {
						if (moveData[1] === moveData[0] + 1) {	// but pre-reverse for the i -> i+1 case
							moveData = (moveData as number[]).reverse();
						}
						this.observableValue[moveData[0]]._sendMoveDelta(this.parent, this.name, moveData[0]);
						return;
					}
				}
				splice.removed.forEach(element => this.processChildRemoval(element));
				for (let i = splice.index; i < splice.index + splice.addedCount; i++) {
					this.processChildAddition(i);
				}
				return;
			}
			case "update": {
				const update = changeData as IArrayChange<T>;
				this.processChildRemoval(update.oldValue);
				this.processChildAddition(update.index);
				return;
			}
		}
	}

	processChildRemoval(element: T) {
		/* If the element was removed and not inserted at another place
		* (either on another parent or in the same parent on another index),
		* remove it:
		*/
		if (element.container === this.parent && this.observableValue.indexOf(element) === -1) {
			element.container = null;
			((element as any as IModelUnit) as any).clearBackReferences();
			element.delete();
		}
	}

	processChildAddition(index: number) {
		const item = this.observableValue[index];
		if (!item) {
			throw new Error(`Null values cannot be added to property '${this.name}' of '${this.parent.typeName}#${this.parent.id}'`);
		}
		item.versionInfo.checkSameModelVersion(item.model, this.parent.model);
		item.versionInfo.checkStructureVersion(item, true);
		if (this.observableValue.filter(other => other === item).length > 1) {
			throw new Error(
				`Object '${item.typeName}#${item.id}' was added more than once `
				+ `to property '${this.name}' of '${this.parent.typeName}#${this.parent.id}'`
			);
		}
		if (item._isNew) {
			item.container = this.parent;
			if (!this.parent._isNew) {
				item._updateElementsContainer(this.parent.unit as ModelUnit);
				this.parent._model._qualifiedNameCache.addStructureToCache(item);
			}
			item._unit = this.parent.unit as ModelUnit;
			item._sendCreateDelta(this.parent, this.name);
			if (index < this.observableValue.length - 1) {
				// only send delta if not added at the end
				item._sendMoveDelta(this.parent, this.name, index);
			}
		} else {
			item._sendMoveDelta(this.parent, this.name, index);
			const oldParent = item.container;
			item.container = this.parent;
			if (oldParent) {
				oldParent._detachChild(item);
			}
		}

		// This could be a by-name-referrable element that was previously removed. We need to update the references to it then.
		if (item && item._isByNameReferrable()) {
			item._processNameChange();
		}
	}

	resolveReferences() {
		this.observableValue.forEach(item => item._resolveReferences());
	}

	updateElementContainer(unit: ModelUnit) {
		this.observableValue.forEach((item: Element) => item._updateElementsContainer(unit));
	}

	removeChild(child: T): boolean {
		const idx = this.observableValue.indexOf(child);
		if (idx >= 0) {
			this.observableValue.splice(idx, 1);
			return true;
		}
		return false;
	}

	dispose() {
		this.observableValue.forEach(elem => elem._dispose());
	}

	_toJSON() {
		return this.get().map(item => item.toJSON());
	}

	deepCopyInto(clone, idMap, unresolvedIdentifierFixers) {
		// throw away default / existing values in the list
		(clone["__" + this.name] as PartListProperty<T>).get().clear();
		this.get()
			.filter(child => !!child)
			.forEach(child => child._deepCopyStructureInto(clone, this.name, idMap, unresolvedIdentifierFixers));
	}

}

