import {IArrayChange, IArraySplice, IObservableArray, IObservableValue, asFlat, asReference, observable} from "mobx";

import {AbstractProperty} from "./abstract-property";
import {IEnum} from "../instances";
import {Structure} from "../structures";
import {ILifeCycle} from "../version-checks";
import {MutatorTypes} from "../deltas";
import {utils} from "../../utils";

/**
 * All primitive types.
 * Note: must match exactly with MxPrimitiveTypeEnum!
 */
export enum PrimitiveTypeEnum {
	Integer,
	String,
	Boolean,
	Double,
	DateTime,
	Guid,
	Point,
	Size,	// as in: Dimension
	Color,
	Blob
}

/*
 * Primitive-typed property value
 */
export class PrimitiveProperty<T> extends AbstractProperty<T, IObservableValue<T>> {

	private defaultValue: T;
	private primitiveType: PrimitiveTypeEnum;

	initialize(defaultValue: T, primitiveType: PrimitiveTypeEnum) {
		this.defaultValue = defaultValue;
		this.primitiveType = primitiveType;
		return observable(asReference(defaultValue)) as any as IObservableValue<T>;
	}

	get() {
		this.assertReadable();
		return this.observableValue.get();
	}

	set(newValue: T) {
		utils.assertNotNull(newValue, this.name);
		this.assertWritable();
		this.observableValue.set(newValue);
	}

	updateWithRawValue(value: T) {
		utils.assertNotNull(value, this.name);
		this.observableValue.set(value);
	}

	onChange(newValue: T, oldValue: T) {
		if (this.name === "name") {	// This element, namespace, etc. is changed, reprocess all unresolved references..
			this.parent._processNameChange();
		}
		this.parent._sendChangeDelta(this.name, newValue);
	}

	markCurrentValueAsDefault() {
		this.defaultValue = this.get();
	}

	_toJSON(): any {
		// skip values which are unlikely to have any human-readable meaning:
		if (this.primitiveType === PrimitiveTypeEnum.Guid || this.primitiveType === PrimitiveTypeEnum.Blob) {
			return void 0;
		} else {
			return this.get();
		}
	}

	deepCopyInto(clone) {
		if (this.primitiveType !== PrimitiveTypeEnum.Guid) {
			// Guids should never be cloned
			clone[this.name] = this.get();
		}
	}

}


/**
 * Primitive-typed property values list.
 */
export class PrimitiveListProperty<T> extends AbstractProperty<T[], IObservableArray<T>> {

	private primitiveType: PrimitiveTypeEnum;

	/*
	* Currently, only possible default value for listy properties is [],
	* so we don't have to store initialItems to be able to distinguish from default value.
	*/
	initialize(initialItems: T[], primitiveType: PrimitiveTypeEnum) {
		this.primitiveType = primitiveType;
		return observable(asFlat(initialItems || []));
	}

	get() {
		this.assertReadable();
		return this.observableValue;
	}

	set(newValue: T[]) {
		this.assertWritable();
		this.observableValue.replace(newValue);
	}

	updateWithRawValue(value: T[]) {
		this.observableValue.replace(value);
	}

	onChange(change: IArraySplice<T> | IArrayChange<T>) {
		this.assertWritable();
		switch (change.type) {
			case "update": {
				const c = change as IArrayChange<T>;
				utils.assertNotNull(c.object[c.index], this.name, true);
				this.parent._sendChangeDelta(this.name, this.toRawChangeValue(c.object[c.index]), MutatorTypes.CHANGE, c.index);
				return;
			}
			case "splice": {
				const c = change as IArraySplice<T>;
				for (let i = c.removed.length; i > 0; i--) {
					this.parent._sendChangeDelta(this.name, null, MutatorTypes.REMOVE, c.index + i);
				}
				for (let i = 0; i < c.addedCount; i++) {
					utils.assertNotNull(c.object[c.index + i], this.name, true);
					this.parent._sendChangeDelta(this.name, this.toRawChangeValue(c.object[c.index + i]), MutatorTypes.ADD, c.index + i);
				}
				return;
			}
		}
	}

	toRawChangeValue(value: T): any {
		return value;   // primitives can be sent verbatim to the server
	}

	_toJSON(): any[] {
		return this.get();
	}

	deepCopyInto(clone) {
		if (this.primitiveType !== PrimitiveTypeEnum.Guid) {
			// Guids should never be cloned
			clone[this.name] = this.get().slice();
		}
	}

}


/**
 * A property value that is an enum literal.
 */
export class EnumProperty<T extends IEnum> extends PrimitiveProperty<T> {

	constructor(
		declaredOn, parent: Structure, name: string, private initialValue: T,
		protected enumType: new (key: string, lifeCycle: ILifeCycle) => IEnum
	) {
		super(declaredOn, parent, name, initialValue);
	}

	updateWithRawValue(value) {
		this.observableValue.set(this.enumType[value] || this.initialValue);
	}

	set(value: T) {
		if (value) {
			value.checkEnumVersion(this.parent.model.metaModelVersion, true);
		}
		super.set(value);
	}

	onChange(newValue, oldValue) {
		super.onChange(newValue.toString(), oldValue.toString());
	}

	_toJSON(): string {
		return this.get().name;
	}

}


/**
 * A property value that is a list of enum literals.
 */
export class EnumListProperty<T extends IEnum> extends PrimitiveListProperty<T> {

	constructor(
		declaredOn, parent: Structure, name: string, private initialValue: T[],
		protected enumType: new (key: string, lifeCycle: ILifeCycle) => IEnum
	) {
		super(declaredOn, parent, name, initialValue);
	}

	updateWithRawValue(value) {
		this.observableValue.replace(value
			? value.map(e => this.enumType[e] || this.initialValue)
			: []
		);
	}

	toRawChangeValue(value: T): any {
		if (value) {
			value.checkEnumVersion(this.parent.model.metaModelVersion, true);
			return value.toString(); // send enum string representation to the server
		}
		return null;
	}

	_toJSON(): string[] {
		return this.get().map(item => item.name);
	}

}
