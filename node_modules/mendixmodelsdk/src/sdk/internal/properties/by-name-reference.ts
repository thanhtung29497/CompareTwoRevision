import {IArrayChange, IArraySplice, IObservableArray, Lambda, asFlat, observable} from "mobx";

import {AbstractProperty} from "./abstract-property";
import {AbstractElement, IAbstractElement} from "../elements";
import {PrimitiveListProperty} from "./primitives";
import {ByNameReference} from "../references";
import {utils} from "../../utils";


/**
 * Property value that references a (model) element by name.
 */
export class ByNameReferenceProperty<T extends IAbstractElement> extends AbstractProperty<T, ByNameReference<T>> {

	parent: AbstractElement;

	constructor(declaredOn, parent: AbstractElement, name: string, initialValue: T, private _targetType: string) {
		super(declaredOn, parent, name, initialValue, _targetType);
	}

	initialize(value: T, _targetType: string) {
		return new ByNameReference<T>(this.parent, _targetType, this.name);
	}

	get(): T {
		this.assertReadable();
		return this.observableValue.get();
	}

	set(newValue: T) {
		if (this.isRequired && !newValue) {
			throw new Error(`Cannot unset required property '${this.name}' on '${this.parent.qualifiedName}' of type '${this.parent.typeName}'`);
		}
		this.assertWritable();
		this.observableValue.set(newValue);
	}

	updateWithRawValue(value: string) {
		this.observableValue.updateWithRawValue(value);
	}

	resolveReferences() {
		this.observableValue.resolve();
	}

	onChange(newValue: T, oldValue: T) {
		this.parent._sendChangeDelta(this.name, newValue ? newValue.qualifiedName : null);
	}

	qualifiedName() {
		return this.observableValue.qualifiedName();
	}

	get targetType(): string {
		return this._targetType;
	}

	dispose() {
		this.observableValue.dispose();
		super.dispose();
	}

	_toJSON() {
		return (this.isRequired || this.get()) ? this.qualifiedName() : null;
	}

	deepCopyInto(clone, _, unresolvedIdentifierFixers) {
		// make sure we copy the refs, not the values, refs might be broken.
		const qn = this.qualifiedName();
		unresolvedIdentifierFixers.push(() => {
			const elem = qn ? clone._model._resolveName(this.targetType, qn) : null;
			// This works around #875733 and doesn't seem to impact anything else (negatively) so far...
			if (elem !== null) {
				clone[this.name] = elem;
			}
			/*
			 * FIXME  This doesn't seem to be semantically correct,
			 * since deep copying inconsistent model content would cause default values to "spring back".
			 * We have to think whether we should throw on setting this to null.
			 */
		});
	}

}


/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
export class ByNameReferenceListProperty<T extends IAbstractElement>
	extends AbstractProperty<T[], IObservableArray<ByNameReference<T>>> {

	parent: AbstractElement;
	supressViewEvents: boolean = false;

	private viewList: IObservableArray<T> = observable(asFlat([])) as any;
	private viewListDisposer: Lambda;

	constructor(declaredOn, parent: AbstractElement, name: string, value: T[], private _targetType: string) {
		super(declaredOn, parent, name, value);
		this.viewListDisposer = this.viewList.observe((changeData: IArrayChange<T> | IArraySplice<T>) => {
			if (this.supressViewEvents) {
				return;
			}

			// For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
			switch (changeData.type) {
				case "splice": {
					const splice = changeData as IArraySplice<T>;
					const newValues = splice.object.slice(splice.index, splice.index + splice.addedCount);
					newValues.forEach(newValue => utils.assertNotNull(newValue, this.name, true));
					const newReferences = newValues.map(newValue => {
						const ref = new ByNameReference<T>(this.parent, this._targetType, this.name);
						ref.set(newValue);
						return ref;
					});
					this.observableValue.splice(splice.index, splice.removed.length, ...newReferences).forEach(ref => ref.dispose());
					return;
				}
				case "update": {
					const update = changeData as IArrayChange<T>;

					if (update.index < 0 || update.index >= this.observableValue.length) {
						throw new Error("Update index out of bounds " + update.index);
					}

					const newValue = update.object[update.index];
					utils.assertNotNull(newValue, this.name, true);
					const newRef = new ByNameReference<T>(this.parent, this._targetType, this.name);
					newRef.set(newValue);
					this.observableValue[update.index].dispose();
					this.observableValue[update.index] = newRef;
					return;
				}
			}
		});
	}

	initialize(value: T[]): IObservableArray<ByNameReference<T>> {
		if (value && value.length > 0) {
			throw new Error("Illegal state: can only initialize with []");
		}
		return observable(asFlat([]));
	}

	get() {
		this.assertReadable();
		return this.viewList;
	}

	set(newElements: T[]) {
		throw new Error("Illegal state: cannot re-assign list property - use push or splice instead");
	}

	updateWithRawValue(qualifiedNames: string[]) {
		this.replaceViewItems([]);
		this.observableValue.replace((qualifiedNames || []).map(qualifiedName => {
			const ref = new ByNameReference<T>(this.parent, this._targetType, this.name);
			ref.updateWithRawValue(qualifiedName);
			return ref;
		}));
	}

	resolveReferences() {
		this.observableValue.map(ref => ref.resolve());
		this.replaceViewItems(this.observableValue.map(ref => ref.get()));
	}

	qualifiedNames(): string[] {
		return this.observableValue.map(ref => ref.qualifiedName());
	}

	dispose() {
		this.viewListDisposer();	// prevent further events
		this.observableValue.forEach(ref => ref.dispose());
		super.dispose();
	}

	replaceViewItems(newItems: T[]) {
		this.supressViewEvents = true;
		this.viewList.replace(newItems);
		this.supressViewEvents = false;
	}

	onChange(changeData: IArrayChange<ByNameReference<T>> | IArraySplice<ByNameReference<T>>) {
		this.assertWritable();
		// Reuse listeness behavior from primitiveList
		// Uses toRawChangeValue to get the raw data
		PrimitiveListProperty.prototype.onChange.apply(this, arguments);
	}

	toRawChangeValue(reference: ByNameReference<T>): any {
		return reference.qualifiedName();
	}

	get targetType(): string {
		return this._targetType;
	}

	_toJSON() {
		return this.qualifiedNames();
	}

	deepCopyInto(clone, _, unresolvedIdentifierFixers) {
		// make sure we copy the refs, not the values, refs might be broken.
		const qns = this.qualifiedNames();
		unresolvedIdentifierFixers.push(() => {
			clone[this.name].replace(qns
				.map(qn => qn ? clone._model._resolveName(this.targetType, qn) : null)
				.filter(elem => !!elem)
			);
		});
	}

}
