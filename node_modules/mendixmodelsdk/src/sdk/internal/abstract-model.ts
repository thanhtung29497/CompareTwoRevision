import {transaction, extendObservable, asFlat} from "mobx";
import {common} from "../../common";
import {configuration} from "../config";
import {IAbstractUnit, StructuralUnit} from "./units";
import {IWorkingCopy, IDelta, IAbstractUnitJson, IGetFilesOptions, IEnvironmentStatus, IDeployJobStatus} from "./transport-interfaces";
import {ByNameReference} from "./references";
import {DeltaQueue, DeltaRequest} from "./deltas";
import {IModelApiClient, IEditorData} from "./model-api-client";
import {Structure, IStructure} from "./structures";
import {IAbstractElement} from "./elements";
import {instancehelpers} from "./instances";
import {Version, parseAsNormalizedVersion} from "./version-checks";
import {utils} from "../utils";
import {StructuralChildProperty, StructuralChildListProperty} from "./properties";
import QualifiedNameCache from "./qualified-name-cache";


/**
 * This interface exposes a single Mendix Model.
 * This interface contains the parts of the {@link Model} that are exposed through the SDK.
 */
export interface IAbstractModel {

	/**
	 * Working copy id of the current opened model (read only)
	 */
	id: string;

	/**
	 * The meta data of the model.
	 */
	metadata: IWorkingCopy;

	/**
	 * The Mendix meta model version related to the project.
	 */
	metaModelVersion: Version;

	/**
	 * The Mendix product version the model was created with/in.
	 * Note: this does not have to equal the meta model version.
	 */
	mxVersionForModel: Version;

	/**
	 * Ends the connection with the Model API client.
	 * Flushes any pending deltas and invokes the callback once complete.
	 * (Errors will be handled through the default modelstore error handler.)
	 */
	closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback);

	/**
	 * Deletes this model from the server, and the (SDK) client.
	 * If you are altering the model before deleting it, make sure to call this method in the callback of {@link closeConnection}.
	 *
	 */
	deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback);

	/**
	 * Exports this model as MPK.
	 * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
	 * If outFilePath is empty, the raw request response will be provided in the callback
	 */
	exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback);

	/**
	 * Get the deployment status of the working copy. Can be STARTED, STARTING, UPDATING, STOPPED and APP_NOT_FOUND.
	 * Contains other deployment info as well.
	 */
	getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback?: common.IErrorCallback);

	/**
	 * Start async deploy flow, creates new app job and returns it.
	 * This call immediately returns after successfully initiating the deployment job, and it's progress
	 * can be tracked using `getAppUpdateStates.
	 *
	 * A start update packs the mpk and sends it to the the cloud environment to update the application,
	 * a new application will be provisioned if needed.
	 *
	 * The update job will always converge to a stable state (one of "started" | "failed" | "consistencyerrors").
	 * Use the returned job id to poll for this.
	 */
	startAppUpdate(
		callback: common.ICallback<IDeployJobStatus>,
		errorCallback?: common.IErrorCallback
	);

	/**
	 * Retrieves App Job by jobId. See also `startAppUpdate`.
	 * In the response the most important field is status.
	 *
	 * Polling for job status should stop once it has reeached "started" | "failed" | "consistencyerrors".
	 * Jobs will be cleaned up 10 minutes after the have reached one of this states.
	 */
	getAppUpdateStatus(
		jobId: string,
		callback: common.ICallback<IDeployJobStatus>,
		errorCallback?: common.IErrorCallback
	);

	/**
	 * Given an id, fetches a complete unit. The result might be returned from the cache.
	 * Use this method if you have just a unit Id, otherwise, unit.fetch() is a simpler alternative.
	 */
	loadUnitById<T extends IAbstractUnit>(
		id: string,
		forceRefresh: boolean,
		callback: common.ICallback<T>,
		errorCallback?: common.IErrorCallback
	);

	/**
	 * Returns all units in the project, including modules, folders etc.
	 * To retrieve all "real" documents (pages, microflows etc.), use allDocuments().
	 */
	allUnits(): IAbstractUnit[];

	/**
	 * Given a qualified name, returns a module.
	 * (For modules, their qualified name equals their name)
	 */
	findModuleByQualifiedName(qname: string);

	/**
	 * Returns an array of all filepaths in the working copy.
	 */
	getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback);

	/**
	 * Returns all files or a subset of files
	 * options.filter: glob pattern to limit the set of files
	 * options.format: "json" or "zip"
	 * options.path: useful if format is "zip". If provided the zip will be stored on disk
	 */
	getFiles(callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback);
	getFiles(options: IGetFilesOptions, callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback);

	/**
	 * Downloads the file specified by the supplied filepath.
	 * If filePath is empty, the raw request response will be provided in the callback
	 */
	getFile(filePath: string, outFilePath: string, callback: (response?: any) => void, errorCallback: common.IErrorCallback);

	/**
	 * Uploads the supplied file to the specified filepath.
	 */
	putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Deletes the file with the specified filepath.
	 */
	deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback);

	/**
	 * Returns UUIDs for helper working copies for each supported Mendix version.
	 *
	 * These are pre-defined working copies that are accessible for read operations,
	 * and contain units that might come in handy when creating pages from templates.
	 */
	getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback);

}

export interface IUnitsCache {
	[id: string]: IAbstractUnit;
}

export interface IUnitsByTypeCache {
	[type: string]: IAbstractUnit[];
}

/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
export abstract class AbstractModel implements IAbstractModel {

	public metadata: IWorkingCopy = null;
	metaModelVersion: Version;
	mxVersionForModel: Version;

	/**
	 * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
	 */
	_unitsCache: IUnitsCache = {};

	/**
	 * Map qualifiedName -> AbstractElement[]; the same qualified name could potentially refer to different kind of objects;
	 * e.g. MyFirstModule.SecondThing could both be an entity or a microflow.
	 *
	 * A structure has a qualified name precisely if it's public, publicly contained through namespaces and
	 * has a public, 1-string-typed `name` property.
	 * In other words: every structure having a qualified name is already present in the interface of the containing unit.
	 * So, as soon as the `_processLoadedUnitInterfaces` has been called the cache is complete (no lazy loading).
	 * (It still needs to be continuously updated obviously.)
	 */
	_qualifiedNameCache: QualifiedNameCache = new QualifiedNameCache(this);

	/**
	 * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
	 * Please extend the type whenever applicable, for convenience of the programmer.
	 */
	protected _unitsByType: IUnitsByTypeCache = {};

	protected _unresolvedReferences: ByNameReference<any>[] = [];

	protected _areUnitInterfacesLoaded: boolean = false;

	protected _deltaQueue: DeltaQueue = null;

	constructor(
		public _client: IModelApiClient,
		public _errorHandler: common.IErrorCallback,
		protected _connectionConfig: configuration.ISdkConfig
	) { }

	public closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback) {
		setTimeout(
			() => {
				this._deltaQueue.closeConnection(callback, errorCallback || this._errorHandler);
			},
			1
		);
	}

	/**
	 * Instantiates a new Model that can communicate with the server for sending and receiving documents.
	 * Loading a Model will automatically fetches all unit interfaces for this working copy and invokes the (success) callback,
	 * or calls the errorHandler if this fails.
	 */
	public static create(
		client: IModelApiClient,
		workingCopyInfo: configuration.ICreateWorkingCopyParameters,
		callback: common.ICallback<IWorkingCopy>,
		errorCallback: common.IErrorCallback
	) {
		client.createWorkingCopy(workingCopyInfo, callback, errorCallback);
	}

	/**
	 * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
	 * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
	 * or call the errorHandler if this fails.
	 */
	public static read<IT extends IAbstractModel, CT extends AbstractModel>(
		client: IModelApiClient,
		workingCopyId: string,
		connectionConfig: configuration.ISdkConfig,
		instance: CT,
		callback: (model: IT) => void,
		errorCallback: common.IErrorCallback
	) {
		AbstractModel.readImpl(instance, workingCopyId, callback);
	}

	private static readImpl(instance: AbstractModel, workingCopyId: string, callback: (model: IAbstractModel) => void) {
		// TODO  use promises to avoid callback admin mess
		let hasError = false;
		let processMetaDataCallback = null;
		let processUnitInterfacesCallback = null;
		const guardedCallback = function() {
			if (!hasError && processMetaDataCallback && processUnitInterfacesCallback) {
				/*
				 * order is important: metadata (e.g. version) must be set first,
				 * then unit-interfaces (which uses version), then the user can do his/her thing.
				 */
				processMetaDataCallback();
				processUnitInterfacesCallback();
				callback(instance);
			}
		};
		const guardedErrorCallback = function(err) {
			if (!hasError) {
				hasError = true;
				instance._errorHandler(err);
			}
			// Loading is parallel, if multiple errors occur, we are only interested in the first one..
		};

		instance._loadMetaData(
			workingCopyId,
			(callback: common.IVoidCallback) => {
				processMetaDataCallback = callback;
				return void guardedCallback();
			},
			guardedErrorCallback
		);
		instance._loadUnitInterfaces(
			workingCopyId,
			(callback: common.IVoidCallback) => {
				processUnitInterfacesCallback = callback;
				return void guardedCallback();
			},
			guardedErrorCallback
		);
	}

	public get id(): string {
		return this.metadata.id;
	}

	protected get _unitTypes(): string[] {
		return Object.keys(this._unitsByType);
	}

	/**
	 * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
	 */
	protected _unitInterfacesByType<T extends IAbstractUnit>(typeName: string): T[] {
		if (!(typeName in this._unitsByType)) {
			extendObservable(this._unitsByType, { [typeName]: asFlat([]) });
		}
		return this._unitsByType[typeName] as T[];
	}

	/**
	 * Returns a defensive collection of all units in this model.
	 */
	public allUnits(): IAbstractUnit[] {
		const result = [];
		for (let key in this._unitsByType) {
			const objects = this._unitsByType[key];
			result.push(...objects.slice());
		}
		return result;
	}

	_sendDelta(delta: IDelta) {
		this._deltaQueue.push(new DeltaRequest(delta));
	}

	/**
	 * Registers the given `unit` in the cache(s).
	 */
	_cache(unit: IAbstractUnit) {
		if (!unit.typeName) {
			throw new Error("Illegal state: unit has no type name specified");
		}
		if (!this._unitsCache[unit.id]) {
			this._unitsCache[unit.id] = unit;
			this._unitInterfacesByType(unit.typeName).push(unit);
		}
	}

	/**
	 * Unregisters the given `unit` from the cache(s).
	 */
	_uncache(unit: IAbstractUnit) {
		delete this._unitsCache[unit.id];
		let idx = this._unitsByType[unit.typeName].indexOf(unit); // yay for pointer equality
		if (idx > -1) {
			this._unitsByType[unit.typeName].splice(idx, 1);
		}
	}

	/**
	 * Fetches a complete unit. The result might be returned from the cache.
	 */
	public loadUnitById<T extends IAbstractUnit>(
		id: string,
		forceRefresh: boolean,
		callback: common.ICallback<T>,
		errorCallback?: common.IErrorCallback
	) {
		if (id === null) {
			return void callback(null);
		}
		let unit = this._unitsCache[id];
		if (!unit) {
			if (typeof errorCallback === "function") {
				errorCallback(new Error("Unknown unit ID: " + id));
			} else {
				this._errorHandler(new Error("Unknown unit ID: " + id));
			}
		} else if (forceRefresh) {
			// make sure we can load the unit again:
			unit._markNotLoaded();
			this._loadUnit(unit, callback, errorCallback);
		} else if (unit._isLoading) {
			unit._registerAfterLoadCallback(callback);
		} else if (unit.isLoaded) {
			setTimeout(
				() => { // mimic async behavior -> no difference now in working whether gotten from cache or not.
					callback(unit as T);
				},
				1
			);
		} else {
			this._loadUnit(unit, callback, errorCallback);
		}
	}

	protected _loadUnit<T extends IAbstractUnit>(unit: IAbstractUnit, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback) {
		unit._registerAfterLoadCallback(callback);
		unit._markLoading();
		this._client.loadUnitById(
			this.metadata.id,
			unit.id,
			(data: IAbstractUnitJson) => {
				transaction(() => {
					unit._updateWithJson(data);
					this._resolveContainer(unit, data.containerId);
					unit._resolveReferences();
				});
				unit._markLoaded();
			},
			errorCallback || this._errorHandler
		);
	}

	protected _loadMetaData(
		workingCopyId: string,
		callback: (processCallback: common.IVoidCallback) => void,
		errorCallback: common.IErrorCallback
	) {
		this._client.loadWorkingCopyMetaData(
			workingCopyId,
			(data: IWorkingCopy) => {
				callback(this._processLoadedMetaData.bind(this, data));
			},
			errorCallback
		);
	}

	protected _processLoadedMetaData(data: IWorkingCopy) {
		this.metadata = data;
		this.metaModelVersion = parseAsNormalizedVersion(data.metaData.metaModelVersion);
		this.mxVersionForModel = parseAsNormalizedVersion(data.mprMetaData._ProductVersion);
		this._deltaQueue = new DeltaQueue(this);
	}

	/**
	 * Loads all unit interfaces and caches them.
	 * This function cannot be called twice.
	 */
	protected _loadUnitInterfaces(
		workingCopyId: string,
		callback: (processCallback: common.IVoidCallback) => void,
		errorCallback: common.IErrorCallback
	) {
		if (this._areUnitInterfacesLoaded) {
			throw new Error("Illegal state: unit interfaces already loaded");
		}

		this._client.loadUnitInterfaces(
			workingCopyId,
			(data: IAbstractUnitJson[]) => {
				return void callback(this._processLoadedUnitInterfaces.bind(this, data));
			},
			errorCallback
		);
	}

	protected _processLoadedUnitInterfaces(data: IAbstractUnitJson[]) {
		transaction(() => {
			data.forEach(unitJson => {
				instancehelpers.abstractUnitJsonToInstance(this, unitJson, true);
			});

			// resolve all parents:
			data.filter(unitJson => !!unitJson.containerId).forEach(unitJson => {
				let unit = this._unitsCache[unitJson.$ID];
				this._resolveContainer(unit, unitJson.containerId);
			});

			// resolve all qualified names:
			Object.keys(this._unitsCache).forEach(key => this._qualifiedNameCache.addStructureToCache(this._unitsCache[key]));

			// resolve all references:
			Object.keys(this._unitsCache).forEach(key => this._unitsCache[key]._resolveReferences());
		});
		this._areUnitInterfacesLoaded = true;
	}

	protected _resolveContainer(unit: IAbstractUnit, containerId: string) {
		if (!unit) {
			return; // can happen as long as the meta model isn't complete.
		}
		const container = this._unitsCache[containerId];
		if (!container) {
			throw new Error("Invalid container ID: " + containerId);
		}
		if (container !== unit) {
			// Project has a self reference container, which is of course very annoying for recursion..
			// add unit to the structural parent in the project tree
			this._addUnitToStructuralParent(unit, container as StructuralUnit);
		}
	}

	/**
	 * Structural units have children (e.g., folders have documents), but in storage the inverse is stored:
	 * documents specify in which parent they reside.
	 * However, in the SDK we want to be able to read the children of a folder, so these kind of properties are expressed
	 * using StructuralChild(List)Property objects, see `properties/structural.ts`.
	 * We notify structural parents that a child was added upon loading a child structure,
	 * so that parent can do the appropriate bookkeeping at that time (and only once).
	 * This way we avoid having to visit all unit interfaces to gather all childrenof a specific structural child (list) property.
	 */
	_addUnitToStructuralParent(unit: IAbstractUnit, parent: StructuralUnit) {
		if (unit.container !== parent) {
			// old container needs to be unset first
			this._removeUnitFromStructuralParent(unit);
		}

		// set the new parent
		unit.container = parent;
		const prop = parent["__" + unit._containmentName];
		parent._isUpdating = true;
		if (prop instanceof StructuralChildProperty) {
			prop.observableValue.set(unit);
		} else if (prop instanceof StructuralChildListProperty) {
			if (prop.observableValue.indexOf(unit) === -1) {
				prop.observableValue.push(unit);
			}
		} else {
			throw new Error("Illegal state");
		}
		parent._isUpdating = false;
	}

	_removeUnitFromStructuralParent(unit: IAbstractUnit) {
		if (!unit.container) {
			return;
		}

		const oldParent = unit.container as StructuralUnit;
		const oldProp = oldParent["__" + unit._containmentName];
		oldParent._isUpdating = true;
		if (oldProp instanceof StructuralChildProperty) {
			oldProp.observableValue.set(null);
		} else if (oldProp instanceof StructuralChildListProperty) {
			oldProp.observableValue.remove(unit);
		} else {
			throw new Error("Illegal state");
		}
		oldParent._isUpdating = false;
		unit.container = null;
	}

	/**
	 * If a reference is broken, it should be registered here, so that it can be restored once model elements are renamed.
	 */
	public _registerUnresolvedReference(ref: ByNameReference<any>) {
		if (this._unresolvedReferences.indexOf(ref) === -1) {
			this._unresolvedReferences.push(ref);
		}
	}

	/**
	 * If a reference is no longer broken, it should be unregistered here.
	 */
	public _unregisterUnresolvedReference(ref: ByNameReference<any>) {
		let idx = this._unresolvedReferences.indexOf(ref);
		if (idx >= 0) {
			this._unresolvedReferences.splice(idx, 1);
		}
	}

	public _unresolvedReferencesFor(unit: IAbstractUnit) {
		return this._unresolvedReferences.filter(ref => ref.owner.unit === unit);
	}

	/**
	 * If a model element changes its name, broken by-name references should be attempted to resolve.
	 *
	 * In the future this might be made smarter and less expensive, once that becomes an issue.
	 */
	public _processNameChange(element: Structure) {
		if (instancehelpers.structureAffectsQualifiedNames(element)) {
			this._qualifiedNameCache.processNameChange(element);
			for (let i = this._unresolvedReferences.length - 1; i >= 0; i--) {
				if (this._unresolvedReferences[i].resolve()) {
					this._unresolvedReferences.splice(i, 1);
				}
			}
		}
	}

	protected _assertConnectionClosed() {
		if (!this._deltaQueue.isClosing) {
			throw new Error("Connection should be closed first");
		}
	}

	/**
	 * Deletes this working copy from the server, and the (SDK) client.
	 */
	public deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback) {
		this._assertConnectionClosed();
		this._client.deleteWorkingCopy(this.id, callback, errorCallback || this._errorHandler);
	}

	public exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback) {
		this._assertConnectionClosed();
		this._client.exportMpk(this.id, outFilePath, callback, errorCallback || this._errorHandler);
	}

	public getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback) {
		this.getFiles(callback, errorCallback);
	}

	getFiles(callback: common.ICallback<string[] | void>, errorCallback: common.IErrorCallback);
	getFiles(options: IGetFilesOptions, callback: common.ICallback<string[] | void>, errorCallback: common.IErrorCallback);
	getFiles(arg1, arg2?, arg3?) {
		let cb, errorCb, options;
		if (typeof arg1 === "function") {
			cb = arg1;
			errorCb = arg2;
			options = {
				format: "json"
			};
		} else {
			options = arg1;
			cb = arg2;
			errorCb = arg3;
		}
		this._client.getFiles(this.id, options, cb, errorCb);
	}

	public getFile(filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this._client.getFile(this.id, filePath, outFilePath, callback, errorCallback);
	}

	public putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this._client.putFile(this.id, inFilePath, filePath, callback, errorCallback);
	}

	public deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		this._client.deleteFile(this.id, filePath, callback, errorCallback);
	}

	public getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback?: common.IErrorCallback) {
		this._client.getAppEnvironmentStatus(this.id, callback, errorCallback || this._errorHandler);
	}

	public getAppUpdateStatus(jobId: string, callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback) {
		this._client.getAppUpdateStatus(this.id, jobId, callback, errorCallback);
	}

	public startAppUpdate(callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback) {
		this._client.startAppUpdate(this.id, callback, errorCallback);
	}

	public getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback) {
		this._client.getEditorData(callback, errorCallback || this._errorHandler);
	}

	/**
	 * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
	 * Will always succeed for unbroken references,
	 * since all objects that are referred by name should be part of the public interface of the model.
	 *
	 * Example usage:
	 * 	`modelStore.resolveName(domainmodels.Attribute.typeName, "Expenses.Expense.Price");`
	 */
	_resolveName(typeName: string, qualifiedName: string): IAbstractElement {
		return this._qualifiedNameCache.resolve(typeName, qualifiedName);
	}

	protected _warnAboutUnsupportedType(propertyName: string, qname: string) {
		utils.warnOnce(
			`Cannot resolve identifier; the type of the identifiers used by property '${propertyName}' is currently not supported. `
			+ `Please use the property '.${propertyName}QualifiedName' instead to read or update this reference.`);
	}


	findModuleByQualifiedName(qname: string) {
		throw new Error("Abstract! Should be overriden");
	}

	_allModelClasses() {
		throw new Error("Abstract! Should be overriden");
	}

	protected _allOfTypes<T extends IAbstractUnit>(typeNames: string[]): T[] {
		return utils.flatten(typeNames.map(typeName => this._unitInterfacesByType(typeName))) as T[];
	}

}

export interface ISubResolver {
	(parent: IStructure, partName: string): IStructure;
}

