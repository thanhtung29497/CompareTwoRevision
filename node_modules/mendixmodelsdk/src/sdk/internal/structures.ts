import {utils} from "../utils";


/**
 * "Something" that contains properties.
 * Concrete sub types: MxElement, MxStructuralUnit, MxModelUnit.
 * Abstract sub types: MxAbstractElement, MxAbstractUnit.
 *
 * Each unit in the model is guaranteed to exist only once in memory.
 */
export interface IStructure {

	id: string;
	typeName: string;
	_declaredAsNamespace: boolean;
	container: aliases.IContainer;
	isLoaded: boolean;
	versionInfo: StructureVersionInfo;

	/**
	 * Unit that owns/contains this thing.
	 */
	unit: units.IAbstractUnit;
	model: IAbstractModel;
	_resolveReferences();
	_updateWithJson(json: transport.IStructureJson);

	/**
	 * Renders the structure as plain JSON (without observables magic).
	 * This is intended for debugging and development convenience.
	 * Note that the resulting object is not of the interface type corresponding to this structure.
	 */
	toJSON(): Object;

	allProperties(): AbstractProperty<any, any>[];

	/**
	 * Traverses this structure by calling the provided visitor function
	 * on itself and all the structures contained (as part) by it,
	 * in depth-first order, and it returns synchronously after that.
	 * Traverse will visit all descendants of the structure, so make sure it is loaded first.
	 */
	traverse(visit: (structure: IStructure) => void): void;

	/**
	 * Traverses this structure by calling the provided visitor function
	 * on itself and all the structures contained (as part) by it,
	 * in depth-first order, and it returns synchronously after that.
	 * This visitor will only access the parts of the structure that are publicly visible,
	 * in other words, which are part of the interface of the structure.
	 */
	traversePublicParts(visit: (structure: IStructure) => void): void;

}


export type AbstractPartProperty = properties.PartProperty<any> | properties.PartListProperty<any>;

export interface IChildHandle {
	containingProperty: AbstractPartProperty;
	/** Detaches the child from `containingProperty` - can lead to deletion of the child. */
	detach(): void;
}


export abstract class Structure implements IStructure {

	_declaredAsNamespace: boolean = false;

	// Indicates that the internal data of this element is being updated, as a result of data received from the server, so no
	// storage events should be send
	_isUpdating: boolean = true;

	// This element was just constructed and not yet known server side
	_isNew: boolean = false;

	// used by qualified names cache to determine old name after a rename
	_registeredQualifiedName: string = undefined;

	/**
	 * These deltas where created before the create delta of this element was submitted to the server.
	 * As soon as this happens, the queue is processed and should stay empty.
	 * Each element is either an delta, or a new child that was added under a specific property.
	 */
	_pendingDeltasAfterCreate: (transport.IDelta | [Structure, string])[] = [];

	private _properties: AbstractProperty<any, any>[] = []; // cache, it is used very often, and doesn't change over time

	constructor(
		public _model: AbstractModel,
		public typeName: string,
		public id: string,
		public _isPartial: boolean = true,
		public container: aliases.IContainer = null
	) {
		if (!_model) {
			throw new Error("Missing model argument");
		}
		if (!id) {
			throw new Error("Missing id");
		}
		if (!typeName) {
			throw new Error("Missing id");
		}

		this._isNew = false;
		this._isUpdating = true;
	}

	_initializeNewInstance() {
		this._isNew = true;
		this._isPartial = false;
		this._isUpdating = false;
		this._initializeDefaultProperties();
		this._markCurrentValuesAsDefaults();
	}

	_initializeDefaultProperties() {
		// Empty stub, for new istances of this class, properties are initialized as described in the meta model
	}

	public get model(): IAbstractModel {
		return this._model;
	}

	public get versionInfo(): StructureVersionInfo {
		// assumption: versionInfo is *not* inherited.
		return this.constructor["versionInfo"];
	}

	public get unit(): units.IAbstractUnit {
		throw new Error("Abstract!");
	}

	public get isLoaded(): boolean {
		throw new Error("Abstract!");
	}

	/**
	 * Asserts that the complete element is available, and not just its public part.
	 */
	_assertLoaded(propertyForMessage?: AbstractProperty<any, any>) {
		if (!this.isLoaded) {
			throw new Error(propertyForMessage
				? (
					`This operation is not allowed on the property '${propertyForMessage.name}' because its `
					+ `parent object '${this.typeName}' with ID '${this.id}' was not fully loaded. `
					+ `Load the property's parent object with the '.load(callback)' command.`
				)
				: (
					`This operation is not allowed on the object '${this.typeName}' with ID '${this.id}' because `
					+ `it was not fully loaded. Load the object with the '.load(callback)' command.`
				)
			);
		}
	}

	_registerProperty(prop: AbstractProperty<any, any>) {
		this._properties.push(prop);
	}

	/**
	 * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
	 */
	_resolveReferences() {
		this.allProperties().forEach(prop => prop.resolveReferences());
	}

	/**
	 * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
	 */
	_processNameChange() {
		if (this.unit) {
			this.unit._model._processNameChange(this);
		}
		// else: not owned yet => cannot have incoming by-name references that need to be changed => no action required
	}

	/**
	 * Finds the given child among the properties of this structure,
	 * returning a handle to detach it later when appropriate based on in which property is was found.
	 */
	_childHandle(child: Structure): IChildHandle /* | undefined */ {
		const props = this.allProperties();
		for (let i = 0; i < props.length; i++) {
			const prop = props[i];
			if (prop instanceof properties.PartListProperty) {
				const partListProp = prop as properties.PartListProperty<any>;
				if (partListProp.observableValue.indexOf(child) > -1) {
					return {
						containingProperty: prop,
						detach: () => partListProp.removeChild(child)
					};
				}
			} else if (prop instanceof properties.PartProperty && prop.get() === child) {
				return {
					containingProperty: prop,
					detach: () => prop.set(null)
				};
			}
		}
		return undefined;
	}

	/**
	 * Detaches the given child from any (part) property that contained it.
	 */
	_detachChild(child: Structure): void {
		const handle = this._childHandle(child);
		if (handle) {	// (child might already have been detached)
			handle.detach();
		}
	}

	/**
	 * This model element is no longer part of the model, and can be cleaned up.
	 */
	_dispose() {
		// NB: version-wise 'unavailable' props are included!
		this._properties.forEach(prop => prop.dispose());
		// TODO: clean from element cache if element, clean from global cache if unit, delete this.unit.elementsCache[this.id];
	}

	/**
	 * Update an existing (probably partial) interface with real contents received from the server.
	 */
	_updateWithJson(json: transport.IStructureJson) {
		// Only allow to go from partial to full documents once, of course, later on, a full merge would be required
		this._isPartial = false;
		this._isUpdating = true;
		this._updateWithJsonImpl(json);
		this._isUpdating = false;
	}

	protected _updateWithJsonImpl(json: transport.IStructureJson) {
		for (let key in json) {
			if (key !== "$ID" && key !== "$Type" && this["__" + key] instanceof AbstractProperty) {
				(this["__" + key] as AbstractProperty<any, any>).updateWithRawValue(json[key]);
			}
		}
	}

	_sendCreateDelta(owner: aliases.Container, parentPropertyName: string) {
		throw new Error("Abstract!");
	}

	protected _scheduleDeltaAfterCreate(delta: transport.IDelta) {
		// if the create was not send yet to the server, delay this delta until that is done:
		if (this._isNew) {
			this._pendingDeltasAfterCreate.push(delta);
		} else {
			delta.unitId = this.unit.id;
			this.unit._model._sendDelta(delta);
		}
	}

	/**
	 * Sends the change delta in case a simple property has changed.
	 */
	_sendChangeDelta(propertyName: string, newValue: any, changeType: string = deltas.MutatorTypes.CHANGE, index: number = -1) {
		if (this._isUpdating) {
			return;
		}
		this._assertLoaded();

		let mutator = (function(): transport.IMutator {
			switch (changeType) {
				case deltas.MutatorTypes.CHANGE: {
					let changeMutator = {
						value: newValue,
						mutatorType: changeType
					} as transport.IChangeMutator;
					if (index >= 0) {
						changeMutator.updateIndex = index;
					}
					return changeMutator;
				}
				case deltas.MutatorTypes.ADD: return {
					value: newValue,
					mutatorType: changeType,
					insertionIndex: index
				} as transport.IAddMutator;
				case deltas.MutatorTypes.REMOVE: return {
					removalIndex: index,
					mutatorType: changeType
				} as transport.IRemoveMutator;
				case deltas.MutatorTypes.MOVE: return {
					fromIndex: 0, // XXX: figure this one out
					toIndex: index,
					mutatorType: changeType
				} as transport.IMoveMutator;
				default: {
					throw new Error(`changeType '${changeType}' unknown (in deltas.MutatorTypes)`);
				}
			}
		})();

		this._scheduleDeltaAfterCreate({
			unitId: undefined, // Will be set once added to the tree
			elementId: this.id, // TODO: superfluous for unit properties!
			deltaType: deltas.DeltaTypes.UPDATE_PROPERTY_VALUE,
			propertyName: propertyName,
			mutator: mutator
		} as transport.IUpdatePropertyValueDelta);
	}

	/**
	 * Sends the delete in case that we were removed from the model.
	 */
	protected _sendDeleteDelta() {
		if (this._isUpdating) {
			return;
		}
		this._assertLoaded();
		const deleteDelta = {
			unitId: this.unit && this.unit.id,
			elementId: this.id, // TODO: superfluous for units, are these the same deltas?
			deltaType: deltas.DeltaTypes.DELETE_ELEMENT
		} as transport.IDeleteElementDelta;
		if (this._isNew) {
			this._pendingDeltasAfterCreate.push(deleteDelta);
		} else {
			this.unit._model._sendDelta(deleteDelta);
		}
	}

	_markCurrentValuesAsDefaults() {
		this.allProperties().forEach(property => {
			if (property instanceof properties.PrimitiveProperty) {
				(property as properties.PrimitiveProperty<any>).markCurrentValueAsDefault();
			}
		});
	}

	/**
	 * Deletes a model from the model.
	 * This will automatically remove the item from its model parent,
	 * and update incoming references and send server changes.
	 */
	public delete() {
		// TODO: to be overriden for structural units
		this._dispose();
	}


	public toJSON(): Object {
		const json: any = {
			$id: this.id,
			$type: this.typeName
		};
		this.allProperties().forEach(property => {
			const propertyJson = property._toJSON();
			if (typeof propertyJson !== "undefined") {
				json[property["name"]] = propertyJson;
			}
		});
		return json;
	}

	public allProperties(): AbstractProperty<any, any>[] {
		return this._properties.filter(prop => prop.isAvailable);
	}

	public traverse(visit: (structure: IStructure) => void): void {
		this._assertLoaded();
		visit(this);
		this.allProperties().forEach(property => {
			if (property instanceof properties.PartProperty) {
				const value = property.get();
				if (value) {
					value.traverse(visit);
				}
			} else if (property instanceof properties.PartListProperty) {
				property.get().map(value => {
					if (value) {
						value.traverse(visit);
					}
				});
			}
		});
	}

	public traversePublicParts(visit: (structure: IStructure) => void): void {
		visit(this);
		this.allProperties().forEach(property => {
			if (!property.isPublic) {
				return;
			}
			if (property instanceof properties.PartProperty) {
				const value = property.get();
				if (value) {
					value.traversePublicParts(visit);
				}
			} else if (property instanceof properties.PartListProperty) {
				property.get().map(value => {
					if (value) {
						value.traversePublicParts(visit);
					}
				});
			}
		});
	}

	protected getContainerAs<T extends aliases.IContainer>(containerType): T {
		if (!(this.container instanceof containerType)) {
			throw new Error(`instance of ${this.typeName} is not contained by a ${(typeof containerType)}`);
		}
		return this.container as T;
	}
	/*
	 * Typing containerType and this method's return type as follows does not work:
	 *
	 *  protected getContainerAs<T extends aliases.Container><containerType:new(...args:any[])=>T { ...; return <T>this.container; }
	 *
	 * TypeScript does not allow T to be an abstract type, since then it's constructor (i.e., containerType) is non-callable.
	 * This arises e.g. for AppServices$ConsumedAppService which is contained by Projects$FolderBase.
	 */


	public deepCopyInto(newParent: elements.AbstractElement | units.IStructuralUnit, targetPropertyName?: string): Structure {
		// MWE: in future, should be wrapped in undo context / transaction

		// Maps old ids to new structures
		const idMap: utils.IMap<Structure> = {};
		// Futures that should fix not yet resolved by-id refs
		const unresolvedIdentifierFixers: ((idMap: utils.IMap<Structure>) => void)[] = [];

		const clone = this._deepCopyStructureInto(newParent, targetPropertyName, idMap, unresolvedIdentifierFixers);

		unresolvedIdentifierFixers.forEach(fixer => fixer(idMap));
		return clone;
	}

	_deepCopyStructureInto(
		newParent: elements.AbstractElement | units.IStructuralUnit,
		targetPropertyName: string,
		idMap,
		unresolvedIdentifierFixers
	): Structure {
		if (!newParent) {
			throw new Error("Cannot deep copy, no new parent provided");
		} else if (!newParent.isLoaded) {
			throw new Error("Cannot deep copy, cannot copy into a target that is not loaded");
		}

		let clone: Structure;
		if (this instanceof units.AbstractUnit || this instanceof units.ModelUnit) {
			// For constucting, ModelUnits follow semantics of AbstractUnits although they inherit from AbstractElement
			clone = instancehelpers.createUnit(newParent as units.StructuralUnit, this.constructor as any);

			if (this instanceof units.ModelUnit) {
				// ModelUnits can be referred to by Id by children
				idMap[this.id] = clone;
			}
		} else if (this instanceof elements.Element) {
			const targetProp = newParent["__" + targetPropertyName];
			if (!targetProp) {
				throw new Error("Cannot deep copy, new parent property does not exist: " + targetPropertyName);
			}
			const parentPropertyIsList = targetProp instanceof properties.PartListProperty;
			clone = instancehelpers.createElement(newParent, this.constructor as any, targetPropertyName, parentPropertyIsList);
			idMap[this.id] = clone;
		} else if (this instanceof units.StructuralUnit) {
			// See comments in StructuralChildProperties. Could be enabled techically, but probably not desirable
			throw new Error("DeepCopy of structural units like Folders and Modules is not support");
		} else {
			throw new Error("Illegal error in DeepCopy, type not supported: " + this.typeName);
		}

		this.allProperties()
			.filter(property => property.isAvailable)
			.forEach(property => property.deepCopyInto(clone, idMap, unresolvedIdentifierFixers));
		return clone;
	}
}

/**
 * Late dependencies on others, structures should be defined first for proper inheritance!
 */
import {instancehelpers} from "./instances";
import * as deltas from "./deltas";
import * as elements from "./elements";
import {AbstractProperty} from "./properties/abstract-property";
import * as properties from "./properties";
import * as units from "./units";
import {AbstractModel, IAbstractModel} from "./abstract-model";
import * as transport from "./transport-interfaces";
import {StructureVersionInfo} from "./version-checks";

// namespace is a workaround to prevent top level exposure in typedoc..
export namespace aliases {
	export type IContainer = units.IStructuralUnit | elements.IAbstractElement;
	export type Container = units.StructuralUnit | elements.AbstractElement;
}

