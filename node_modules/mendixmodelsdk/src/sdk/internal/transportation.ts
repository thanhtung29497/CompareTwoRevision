import {common} from "../../common";
import {SDK_VERSION} from "../../version";
import {configuration} from "../config";
import {utils} from "../utils";
import fs = require("fs");

let restler; // imported in constructor

const SHORT_TIMEOUT = 1 * 60 * 1000;
const LONG_TIMEOUT = 15 * 60 * 1000;

/**
 * The `transportation` module is responsible for performing requests on the (/a) Model API Server.
 */
/**
 * Implementations of this interface are capable of placing a request with the Model API Server over HTTP.
 * Default implementation: {@link RestTransportation}.
 */
export interface ITransportation {

	/**
	 * Fire off a HTTP request, with specified method, url, data, and success and failure callbacks.
	 */
	request<T>(method: string, url: string, data: Object, success: common.ICallback<T>, failure: common.IErrorCallback, longTimeout?: boolean);

	requestMultipartBinaryFileUpload<T>(
		method: string,
		url: string,
		data: Object,
		fileParameterName: string,
		filename: string | Blob,
		// FIXME  filename also allowing a Blob is a kludge solely for the Web Modeler - remove '| Blob' in next major version
		success: common.ICallback<T>,
		failure: common.IErrorCallback
	);

	requestFileDownload<T>(method: string, url: string, success: common.ICallback<T>, failure: common.IErrorCallback);

}

/**
 * Signature of a Model API-specific error/failure callback function, which passes an {@link IError}.
 */
interface IModelApiErrorCallback extends common.IErrorCallback {
	(err: IError): void;
}

/**
 * An error issued by the Model API.
 */
interface IError {
	error: string;
	description: string;
}

interface IResponseCallback<T> {
	(data: T, response?: any): void;
}

/**
 * Default implementation of {@link ITransportation} that communicates with the Model API Server over
 * HTTP using Restler.
 */
export class RestTransportation implements ITransportation {

	constructor(private config: configuration.ISdkConfig) {
		restler = require("restler");
		/**
		 * globalAgent.maxSockets: from documentation: By default set to Infinity [in Node 0.12, red].
		 * Determines how many concurrent sockets the agent can have open per origin.
		 * Origin is either a 'host:port' or 'host:port:localAddress' combination.
		 *
		 * This is set globally because Restler cannot set this per request, although it claims it can in the docs.
		 */
		require("http").globalAgent.maxSockets = 20;
		require("https").globalAgent.maxSockets = 20;
	}

	request<T>(
		method: string,
		url: string,
		data: Object,
		success: common.ICallback<T>,
		failure: common.IErrorCallback,
		longTimeout?: boolean
	) {
		const _method = this.sanitizedMethod(method);
		const _url = this.url(url);

		const options = this.generateStandardOptions();
		options["headers"]["content-type"] = "application/json";

		if (longTimeout) {
			options.timeout = LONG_TIMEOUT;
		}

		if (data) {
			options["data"] = JSON.stringify(data);
		}

		this.handleRequest(restler[_method](_url, options), _url, data, (responseData: T, response) => success(responseData), failure);
	}

	requestMultipartBinaryFileUpload<T>(
		method: string,
		url: string,
		data: Object,
		fileParameterName: string,
		filename: string | Blob,
		// FIXME  filename also allowing a Blob is a kludge solely for the Web Modeler - remove '| Blob' in next major version
		success: common.ICallback<T>,
		failure: common.IErrorCallback
	) {
		const _method = this.sanitizedMethod(method);
		const _url = this.url(url);

		const options = this.generateStandardOptions();
		options["multipart"] = true;
		options.timeout = LONG_TIMEOUT; // 5 minutes: uploading mpk's takes some time, and can be quite large.

		if (!filename) {
			throw new Error("File to upload is missing.");
		}

		const fileStats = fs.statSync(filename as string);
		const fileSizeInBytes = fileStats["size"];

		const fileContents = restler.file(filename, null, fileSizeInBytes);
		data[fileParameterName] = fileContents;

		options["data"] = data;

		this.handleRequest(restler[_method](_url, options), _url, data, (responseData: T, response) => success(responseData), failure);
	}

	requestFileDownload<T>(method: string, url: string, success: common.ICallback<T>, failure: common.IErrorCallback) {
		const _method = this.sanitizedMethod(method);
		const _url = this.url(url);
		const options = this.generateStandardOptions();
		options["decoding"] = "buffer"; // TODO: in the future we might want to use streams here. Currently Restler does not support streams.
		options.timeout = LONG_TIMEOUT; // downloaded MPK's take some time to build, and can be quite large.

		this.handleRequest(restler[_method](_url, options), _url, null, (responseData, response) => success(responseData as any), failure);
	}

	private sanitizedMethod(method: string) {
		let _method = method.toLowerCase();
		return (_method === "delete") ? "del" : _method;	// weird exception :'(
	}

	private url(urlEndpoint: string) {
		const subUrl = urlEndpoint.substring("/api".length);
		return utils.combineUrl(this.config.endPoint, subUrl);
	}

	private generateStandardOptions() {
		const options: any = {
			timeout: SHORT_TIMEOUT,
			headers: {
				"mendixmodelsdkversion": SDK_VERSION,
				"User-Agent": `mendixmodelsdk/${SDK_VERSION} ${process.platform} ${process.arch} node${process.versions.node}`
			}
		};

		// upcasts for correct type
		const backendCredentials = this.config.credentials as configuration.IBackendCredentials;
		const sdkCredentials = this.config.credentials as configuration.ISdkCredentials;

		if (this.config.credentials && this.config.credentials.username) {
			options.username = this.config.credentials.username;

			if (backendCredentials.password) {
				// Backend credentials
				options.password = backendCredentials.password;
				if (backendCredentials.openid) {
					options.headers = {
						openid: backendCredentials.openid
					};
				}
			} else if (sdkCredentials.apikey) {
				// Api key
				options.password = sdkCredentials.apikey;
			} else {
				throw new Error("Expected either an API key or password (for selected users only)");
			}
		} else {
			throw new Error("No credentials provided");
		}

		return options;
	}

	private handleRequest<T>(request, url: string, data: Object, success: IResponseCallback<T>, failure: common.IErrorCallback) {
		request
			.on("2XX", (responseData, response) => {
				success(responseData, response);
			})
			.on("4XX", (responseData, response) => {
				failure({
					error: responseData,
					statusCode: response.statusCode,
					url: url
				});
			})
			.on("5XX", (responseData, response) => {
				failure({
					error: responseData,
					statusCode: response.statusCode,
					url: url
				});
			})
			.on("complete", (result, response) => {
				// this callback allways fires; only catch results we haven't caught with 2XX, 4XX and 5XX callbacks
				if (result instanceof Error) {
					if (result["code"] === "ECONNREFUSED") {
						failure({
							error: "Not available",
							description: "The Mendix Model API Server is not available. Please try again later.",
							url: url
						});
					} else if (result["code"] === "EPIPE") {
						console.warn("Encountered EPIPE - "
							+ "assuming failure callback is already called for this request with status code 413 (Request Entity Too Large).");
					} else {
						failure({
							error: "No response",
							description: `The Mendix Model API Server failed to respond. Result code: ${result["code"]}`,
							url: url
						});
					}
				}
			})
			.on("timeout", () => {
				failure({
					error: "Timeout",
					description: "The Mendix Model API Server timed out.",
					url: url
				});
			});
	}

}
