import * as transport from "./transport-interfaces";
import {common} from "../../common";
import {AbstractModel} from "./abstract-model";


// Defining constants inside a class results in better typedocs.
export class DeltaTypes {
	static CREATE_ELEMENT: string = "CREATE_ELEMENT";
	static UPDATE_PROPERTY_VALUE: string = "UPDATE_PROPERTY_VALUE";
	static MOVE_ELEMENT: string = "MOVE_ELEMENT";
	static DELETE_ELEMENT: string = "DELETE_ELEMENT";
	static CREATE_UNIT: string = "CREATE_UNIT";
	static DELETE_UNIT: string = "DELETE_UNIT";
};

export class MutatorTypes {
	static CHANGE: string = "CHANGE";
	static ADD: string = "ADD";
	static REMOVE: string = "REMOVE";
	static MOVE: string = "MOVE";
};


/**
 * A POTSO that wraps a delta and success/failure callbacks.
 */
export class DeltaRequest {
	constructor(public delta: transport.IDelta, public onSuccess?: common.IVoidCallback, public onFailure?: common.IErrorCallback) { }
}

/**
 * A simple queue implementation for deltas.
 */
export class DeltaQueue {

	isClosing: boolean = false;

	private delay: number = 200; // ms
	private maxDeltasPerBatch: number = 1000;

	private queue: DeltaRequest[] = [];
	private pending: boolean = false;
	private hasError: boolean = false;
	private closeCallback: common.IVoidCallback;

	constructor(private model: AbstractModel, private logToConsole?: boolean) { }

	/**
	 * Closes the "connection" with the Model API Server in the sense that
	 * pending delta requests are processed, and that afterwards the given
	 * `callback` will be called.
	 * This function can only be called once.
	 */
	closeConnection(callback: common.IVoidCallback, errorCallback: common.IErrorCallback /* Not used yet */) {
		if (this.isClosing) {
			throw new Error("closeConnection already called");
		}
		this.isClosing = true;
		if (this.pending) {
			this.closeCallback = callback;
		} else {
			return void callback();
		}
	}

	/**
		* Pushes the given `delta` on the queue for scheduling/processing.
		*/
	push(delta: DeltaRequest) {
		if (this.isClosing) {
			throw new Error("Delta rejected, delta queue connection has closed.");
		}
		if (this.hasError) {
			throw new Error("Delta rejected because it has errors");
		}
		this.queue.push(delta);
		if (this.logToConsole) {
			console.log("Scheduled delta " + JSON.stringify(delta));
		}
		this.schedule();
	}

	/**
		* Schedules the next delta for processing using JS's event queue/loop.
		*/
	private schedule() {
		if (this.pending) {
			return;
		}
		this.pending = true;
		setTimeout(() => this.processNext(), this.delay);
	}

	private processNext() {
		if (this.queue.length === 0 || this.hasError) {
			this.pending = false;
			if (this.isClosing && this.closeCallback) {
				this.closeCallback();
			}
			return;
		}

		let deltaRequests = this.queue.slice(0, Math.min(this.queue.length, this.maxDeltasPerBatch));
		let deltas = deltaRequests.map(deltaRequest => deltaRequest.delta);
		this.model._client.sendDeltas(this.model.metadata.id, deltas, (results: any) => {
			let nSuccess = results.successResults.length;
			this.queue.splice(0, nSuccess);
			deltaRequests.slice(0, nSuccess).forEach(deltaRequest => {
				if (deltaRequest.onSuccess) {
					deltaRequest.onSuccess();
				}
			});
			if (results.firstError) {
				this.hasError = true;
				let failingDelta = deltaRequests[nSuccess];
				if (failingDelta.onFailure) {
					failingDelta.onFailure(results.firstError);
				} else {
					this.model._errorHandler(results.firstError);
				}
			}
			this.processNext();
		}, (err) => {
			this.hasError = true;
			deltaRequests.forEach(deltaRequest => {
				if (deltaRequest.onFailure) {
					deltaRequest.onFailure(err);
				}
			});
			this.model._errorHandler(err);
			this.processNext(); // handles pending closed callback
		});
	}

}
