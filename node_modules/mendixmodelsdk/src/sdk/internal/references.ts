import {observe, observable, asReference, IObservableValue} from "mobx";
import * as elements from "./elements";
import * as units from "./units";
import {common} from "../../common";

/**
 * Abstract base class for both {@link ReferenceByName by-name} and {@link ReferenceById by-id} references
 * to elements of type `T`, which are observed.
 */
export class AbstractReference<T extends elements.IAbstractElement> {

	protected isResolved: boolean = true;
	protected target: IObservableValue<T> = observable(asReference(null as T)) as any as IObservableValue<T>;
	protected isResolving: boolean = false;  // suppress on change events
	protected referenceId: string = null;

	/**
	 * Constructs and returns a new reference instance, that is owned (by a property of) an abstract element.
	 */
	constructor(public owner: elements.AbstractElement) { }

	/**
	 * Registers an observer in the form of a callback with this references and fires that callback
	 * immediately if the reference is already resolved.
	 * Used by properties to observe this reference, so that storage and logical updates can be applied.
	 */
	observe(callback: (newValue: T, oldValue: T) => void, fireImmediately?: boolean): common.IVoidCallback {
		return observe(this.target, (newValue, oldValue) => {
			// Do not notify properties that a value is changed when resolving, because no delta should be created.
			// UI will still be updated, since this.target is an observable.
			if (!this.isResolving) {
				callback(newValue, oldValue);
			}
		}, fireImmediately);
	}

	/**
	 * Returns the value of the wrapped reference.
	 */
	get(): T {
		return this.target.get();
	}

	/**
	 * Sets the value of the wrapped reference, taking care of resolution and life cycle.
	 */
	set(newValue: T) {
		if (newValue) {
			newValue.versionInfo.checkSameModelVersion(newValue.model, this.owner.model);
			newValue.versionInfo.checkStructureVersion(newValue as any, true);
		}

		if (this.isResolved) {
			this.unregisterRef();
		}
		this.target.set(newValue);
		this.registerRef();
	}

	/**
	 * Sets only the raw target id, without trying to resolve that.
	 */
	updateWithRawValue(value: string) {
		if (value !== this.referenceId) {
			this.unregisterRef();
			this.target.set(null);
			this.referenceId = value;
			this.isResolved = false;
		}
	}

	protected registerRef() {
		if (this.target.get()) {
			this.target.get()._addBackReference(this);
		}
	}

	protected unregisterRef() {
		if (this.target.get()) {
			this.target.get()._removeBackReference(this);
		}
	}

	resolve(): boolean {
		throw "Should be implemented by sub class";
	}

	dispose() {
		this.unregisterRef();
	}

}

export class ByIdReference<T extends elements.AbstractElement> extends AbstractReference<T> {

	set(newValue: T) {
		if (newValue) {
			/* This guarantees that no unresolvable references by id can end up in our storage.
			We could loosen this constraint when we have transactions with server side consistency checks,
			but otherwise this would be a subtle bug people could run into easily. */
			if (!newValue.unit) {
				throw new Error(
					`Cannot update property of '${this.owner.typeName}', the given object is not yet part of a unit. ` +
					`Please add the object to an unit first.`
				);
			}
		}
		super.set(newValue);
		this.assertValueHasSameUnit();
	}

	assertValueHasSameUnit() {
		const currentValue = super.get();
		if (currentValue && currentValue.unit && this.owner.unit && currentValue.unit !== this.owner.unit) {
			throw new Error(
				`In element of type ${this.owner.typeName}: ` +
				`The assigned value should be part of the same unit, expected '${this.owner.unit.id}' but found '${currentValue.unit.id}'.`
			);
		}
	}

	get(): T {
		if (!this.isResolved) {
			throw new Error("Illegal state: by-id reference is broken");   // by-id reference should never be broken
		}
		return super.get();
	}

	resolve() {
		if (!this.isResolved) {
			this.isResolving = true;
			if (!this.referenceId) {
				this.target.set(null);
			} else if (this.referenceId === "00000000-0000-0000-0000-000000000000") {
				throw new Error(
					`encountered null ID: unitID=${this.owner.unit.id}; ` +
					`ID of element containing by-id reference property: ID=${this.owner.id}`
				);
			} else {
				const elem = ((this.owner.unit as units.ModelUnit)._elementsCache[this.referenceId]) as T;
				if (!elem) {
					throw new Error("Broken reference; ID: " + this.referenceId);
				}
				this.target.set(elem);
				this.assertValueHasSameUnit();
				this.registerRef();
			}
			this.isResolving = false;
			this.isResolved = true;
		}
		return true;
	}

}


export class ByNameReference<T extends elements.IAbstractElement> extends AbstractReference<T> {

	constructor(owner: elements.AbstractElement, public targetType: string, public propertyName: string) {
		super(owner);
	}
	// TODO  it would be better to have the property as the 1st constructor argument (so owner === property.parent)

	set(newValue: T) {
		super.set(newValue);
		if (newValue) {
			this.referenceId = newValue.qualifiedName;
		}
	}

	resolve() {
		if (!this.isResolved) {
			this.isResolving = true;
			if (!this.referenceId) {
				this.target.set(null);
				this.isResolved = true;
			} else {
				const elem = this.owner.unit._model._resolveName(this.targetType, this.referenceId) as T;
				this.isResolved = !!elem;
				this.target.set(elem);
				this.registerRef();
				if (!this.isResolved) {	// resolve failed, for example if ref was broken in storage
					this.owner.unit._model._registerUnresolvedReference(this);
				}
			}
			this.isResolving = false;
		}
		return this.isResolved;
	}

	/**
	 * The target does no longer exist, but the stored reference should stay the same.
	 */
	unresolve() {
		// make sure the value of the latest referenceId is kept!
		this.isResolving = true;
		const current = this.get();
		if (current) {
			this.referenceId = current.qualifiedName;
		}
		this.owner.unit._model._registerUnresolvedReference(this);
		super.set(null);
		this.isResolved = false;
	}

	dispose() {
		if (!this.isResolved) {
			this.owner.unit._model._unregisterUnresolvedReference(this);
		}
		super.dispose();
	}

	qualifiedName(): string {
		if (!this.isResolved) {
			return this.referenceId;
		}
		const current = this.get();
		return current ? current.qualifiedName : "";
	}

}
