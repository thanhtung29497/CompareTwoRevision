import * as structures from "./structures";
import {AbstractModel} from "./abstract-model";

/**
 * The `elements` module contains various classes and functions
 * related to elements, specifically: (abstract) elements.
 */

/**
 * Abstract elements are structures that are referable by name.
 * Sub types: (I)Element and (I)ModelUnit.
 */
export interface IAbstractElement extends structures.IStructure {
	isLoaded: boolean;
	qualifiedName: string;
	_addBackReference(ref: references.AbstractReference<any>);
	_removeBackReference(ref: references.AbstractReference<any>);
	load<T extends IAbstractElement>(callback?: (elem: T) => void);
	load<T extends IAbstractElement>(): T;
	getBackReferences(): references.AbstractReference<AbstractElement>[];
	clearBackReferences(): void;
}

/**
 * See {@link IAbstractElement}.
 */
export abstract class AbstractElement extends structures.Structure implements IAbstractElement {

	container: structures.aliases.Container;

	/*
	 * In-memory by-id or by-name references from other elements to this element.
	 * These are the objects that need to be informed when names changes occur, or if the element is deleted.
	 */
	private _backReferences: references.AbstractReference<AbstractElement>[] = [];

	constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, container: structures.aliases.IContainer) {
		super(model, typeName, id, isPartial, container);
	}

	/**
	 * Checks whether all properties are available at the moment
	 *  - if false, a load is required to access these properties.
	 */
	public get isLoaded(): boolean {
		return this.unit.isLoaded;
	}

	/**
	 * Calculates the fully qualified name of this element,
	 * by visiting all parents that have $isNamespace set to `true`.
	 */
	public get qualifiedName(): string {
		let parts = [];
		let element: AbstractElement | units.StructuralUnit = this.container;
		while (element) {
			if (element._declaredAsNamespace) {
				parts.unshift(element["name"]);
			}
			element = element.container;
		}
		parts.push(this["name"]);
		return parts.filter(n => !!n).join(".");
	}

	/**
	 * Transforms a IElement interface into a Element class, loading the containing unit if necessary.
	 * (Those are technically already the same, but this function makes sure its properties are available.)
	 *
	 * - If invoked without callback, it checks whether the properties are available or it will throw;
	 * - If invoked with callback, it will load the data from the server if needed, and then invoke the callback.
	 */
	public load<T extends AbstractElement>(callback: (elem: T) => void, forceRefresh?: boolean);
	public load<T extends AbstractElement>(): T;
	load(callback?, forceRefresh = false) {
		if (!callback) {
			this._assertLoaded();
			return this;
		}
		this.unit._model.loadUnitById(this.unit.id, forceRefresh, () => {
			// this element should be loaded now!
			this._assertLoaded();
			callback(this);
		});
	}

	/**
	 * updateElementsContainer recursively sets the unit to which this elements belong
	 * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
	 * an element is actually added to the tree (buy pushing / assigning it to some part property)
	 */
	protected _updateElementsContainer(unit: units.ModelUnit) {
		this.allProperties().forEach(property => {
			if (property instanceof properties.PartProperty || property instanceof properties.PartListProperty) {
				property.updateElementContainer(unit);
			} else if (property instanceof properties.ByIdReferenceProperty) {
				property.updateElementContainer();
			}
		});
	}


	/**
	 * Return true if this is an abstractElement that might be referred to by some other element.
	 * If true, this element is maintained in the qualifiedNamesCache
	 */
	_isByNameReferrable(): boolean {
		return false;
	}

	/**
	 * Adds a back reference, i.e. a reference pointing to us,
	 * which needs to be informed of changes to this element (including deletion).
	 */
	_addBackReference(ref: references.AbstractReference<any>) {
		this._backReferences.push(ref);
	}

	/**
	 * Removes the given back reference.
	 */
	_removeBackReference(ref: references.AbstractReference<any>) {
		const idx = this._backReferences.indexOf(ref);
		if (idx >= 0) {
			this._backReferences.splice(idx, 1);
		}
	}

	public getBackReferences() {
		return this._backReferences;
	}

	public clearBackReferences() {
		this._backReferences.forEach(reference => (reference as references.ByNameReference<any>).unresolve());
	}

	public delete() {
		for (let i = this._backReferences.length - 1; i >= 0; i--) {
			const ref = this._backReferences[i];
			if (ref instanceof references.ByIdReference) {
				// by-id references? should apply cascading delete! See story 475769
				ref.owner.delete();
			} else if (ref instanceof references.ByNameReference) {
				// references by name should no longer resolve
				(ref as references.ByNameReference<any>).unresolve();
			}
		}
		this._backReferences = [];

		// remove from qualifiedNamesCache
		this._model._qualifiedNameCache.removeStructureFromCache(this);

		// avoid roundtrip delete -> remove from parent -> delete etc, so enforce that an element is removed through its parent:
		if (this.container) {
			this.container._detachChild(this);
		} else {
			this._sendDeleteDelta();
			super.delete();
		}
	}

}

/**
 * An element (short for: "model element") lives inside a unit
 * and contains (per being an IStructure) property values.
 */
export interface IElement extends IAbstractElement { }

export type IElementConstructor = typeof Element;

export class Element extends AbstractElement implements IElement {

	public container: AbstractElement;

	public _unit: units.ModelUnit;

	constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, unit: units.ModelUnit, container: AbstractElement) {
		super(model, typeName, id, isPartial, container);
		if (unit) {
			this._updateElementsContainer(unit);
		}
	}

	public get unit() {
		return this._unit;
	}

	/**
	 * Checks whether all attributes are available ATM
	 *  -  if false, a load is required to access these properties.
	 */
	public get isLoaded(): boolean {
		return this._isNew || this.unit.isLoaded;
	}

	_updateElementsContainer(unit: units.ModelUnit) {
		this._unit = unit;
		unit._elementsCache[this.id] = this;
		this._model = unit._model;
		super._updateElementsContainer(unit);
	}

	/**
	 * Sends the appropriate create delta to the server, and also sends all pending deltas,
	 * after this element has been assigned to some parent.
	 */
	_sendCreateDelta(owner: AbstractElement, parentPropertyName: string) {
		// TODO: part of this needs to be pulled up to Structure
		if (this._isUpdating) {
			return;
		}
		if (!this._isNew) {
			throw new Error("Illegal state: cannot send create delta for pre-existing element");
		}
		this._assertLoaded();

		if (owner && owner._isNew) {
			// Parent is not known at the server yet, we need to try again later
			owner._pendingDeltasAfterCreate.push([this, parentPropertyName]);
			return;
		}
		if (owner.unit) {
			this._updateElementsContainer(owner.unit as units.ModelUnit);
		}
		this.unit._model._sendDelta({
			parentId: owner.id,
			elementType: this.typeName,
			parentPropertyName: parentPropertyName,
			deltaType: deltas.DeltaTypes.CREATE_ELEMENT,
			unitId: this.unit.id,
			elementId: this.id
		} as transport.ICreateElementDelta);
		this._isNew = false;
		this._pendingDeltasAfterCreate.forEach(pending => {
			if (pending instanceof Array) {
				pending[0]._sendCreateDelta(this, pending[1]);
			} else {
				const delta = pending as transport.IDelta;
				delta.unitId = this.unit.id;
				this.unit._model._sendDelta(delta);
			}
		});
	}

	/**
	 * Sends the appropriate create delta to the server
	 * after this element has been moved to a new parent.
	 */
	_sendMoveDelta(newParent: AbstractElement, newPropertyName: string, index?: number) {
		if (this._isUpdating) {
			return;
		}
		this._assertLoaded();
		let moveDelta = {
			unitId: (this.unit && this.unit.id),
			elementId: this.id,
			deltaType: deltas.DeltaTypes.MOVE_ELEMENT,
			newParentId: newParent.id,
			newParentPropertyName: newPropertyName
		} as transport.IMoveElementDelta;

		if (index !== undefined) {
			moveDelta.newIndex = index;
		}

		// Tricky: move might happen to a new element, for which creating we need to wait before sending this delta.
		if (newParent._isNew) { // MWE: this check should be done recursively?
			// TODO: invariant: should be in transaction to prevent data loss!
			// Otherwise it is possible that the move is only done in the next delta batch
			// and the element can not be found anymore as the detachedElements cache is gone.
			// (Or persist detached elements?)
			newParent._pendingDeltasAfterCreate.push(moveDelta);
		} else {
			if (this._isNew) {
				this._pendingDeltasAfterCreate.push(moveDelta);
			} else {
				this.unit._model._sendDelta(moveDelta);
			}
		}
	}

	public deepCopyInto(newParent: AbstractElement, targetPropertyName: string): AbstractElement {
		if (!this.isLoaded) {
			throw new Error("Only loaded elements can be copied. Use .load() first");
		}

		return super.deepCopyInto(newParent, targetPropertyName) as AbstractElement;
	}

}

import * as references from "./references";
import * as deltas from "./deltas";
import * as properties from "./properties";
import * as units from "./units";
import * as transport from "./transport-interfaces";

