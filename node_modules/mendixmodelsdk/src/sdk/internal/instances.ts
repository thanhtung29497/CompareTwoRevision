import {AbstractModel} from "./abstract-model";
import * as versions from "./version-checks";
import * as structures from "./structures";
import * as units from "./units";
import * as elements from "./elements";
import * as transport  from "./transport-interfaces";
import {IObservableArray} from "mobx";
import {utils} from "../utils";

/**
 * The `instances` module contains various classes and functions
 * which revolve around creating/maintaining/updating actual model contents.
 */


/**
 * Generic type alias for `Mobservable.IObservableArray<T>`,
 * mainly to achieve some brevity in generated SDK code.
 */
export interface IList<T> extends IObservableArray<T> { }


/**
 * Base class for enumerations in the meta model.
 * Literals of an enumeration are generated as public static constants of the generated sub class
 * which are instances of the generated sub class.
 */
export abstract class IEnum {

	protected qualifiedTsTypeName: string;
	public versionInfo: versions.LifeCycle;

	constructor(private _name: string, lifeCycleInfo: versions.ILifeCycle) {
		this.versionInfo = new versions.LifeCycle(lifeCycleInfo);
	}

	get name(): string { return this._name; };

	toString() {
		return this._name;
	}

	qualifiedTsLiteralName() {
		return `${this.qualifiedTsTypeName}.${this._name}`;
	}

	checkEnumVersion(metaModelVersion: versions.Version, includeWarnings: boolean) {
		this.versionInfo.reportVersionIssues(metaModelVersion, `Enumeration value '${this.qualifiedTsLiteralName}'`, includeWarnings);
	}

}


// namespace is a workaround for typedoc
export namespace instancehelpers {

	/**
	 * Given some a (normalized) JSON representation of a unit,
	 * creates an instance of the corresponding `unit.AbstractUnit` sub class (structural/model)
	 * and populates that from the JSON.
	 * Should only be called if this unit was not already in memory.
	 */
	export function abstractUnitJsonToInstance(
		model: AbstractModel,
		json: transport.IAbstractUnitJson,
		isPartial: boolean
	): units.AbstractUnit {
		if (!json) {
			return null;
		}
		const unit = createStructure(
			lookupClass(json.$Type, model._allModelClasses()),
			model._unitsCache,
			(initializer: units.IAbstractUnitConstructor) => new initializer(model, json.$Type, json.$ID, isPartial, null),
			json
		);
		if (unit) {
			model._cache(unit);
		}
		return unit;
	}

	/**
	 * Given some a (normalized) JSON representation of a model element,
	 * creates an instance of the corresponding `elements.Element`
	 * and populates that from the JSON.
	 * Will update existing elements if this element was created before.
	 */
	export function modelElementJsonToInstance(
		model: AbstractModel,
		unit: units.ModelUnit,
		container: elements.AbstractElement,
		json: transport.IAbstractElementJson,
		isPartial: boolean
	): elements.Element {
		if (!json) {
			return null;
		}
		return createStructure(
			lookupClass(json.$Type, model._allModelClasses()),
			unit._elementsCache,
			(initializer: elements.IElementConstructor) => new initializer(model, json.$Type, json.$ID, isPartial, unit, container),
			json
		);
	}

	/**
	 * Creates a new element for a SDK user.
	 */
	export function createElement(owner, constructor: elements.IElementConstructor, parentPropName?: string, parentPropIsList?: boolean): any {
		if (!owner) {
			throw new Error("Please provide a container or model");
		}
		const model = owner instanceof AbstractModel ? owner : (owner as elements.AbstractElement)._model;
		const instance = new constructor(model, (constructor as any).typeName, utils.randomUuid(), false, null, null);
		checkStructureVersion(instance, true);
		instance._initializeNewInstance();
		if (parentPropName && (!(owner instanceof AbstractModel))) {
			if (parentPropIsList) {
				owner[parentPropName].push(instance);
			} else {
				owner[parentPropName] = instance;
			}
		}
		return instance;
	}

	/**
	 * Creates a new unit for a SDK user.
	 */
	export function createUnit(container: units.IStructuralUnit, constructor: units.IAbstractUnitConstructor): any {
		if (!(container instanceof units.StructuralUnit)) {
			throw new Error("Expected container");
		}
		const model = container._model;
		const instance = new constructor(model, (constructor as any).typeName, utils.randomUuid(), false, container);
		checkStructureVersion(instance, true);
		instance._initializeNewInstance();
		instance._handleCreateSelf();
		model._cache(instance);
		model._addUnitToStructuralParent(instance, container as units.StructuralUnit);
		return instance;
	}

	/**
	 * Type -> class (the constructor function, technically) lookup, e.g. "DomainModels$Entity" -> DomainModels.Entity
	 */
	export function lookupClass(qualifiedTypeName: string, classes: any) {
		if (!qualifiedTypeName) {
			return nullWithError("cannot look up initializer for a falsy qualified type name");
		}

		const $index = qualifiedTypeName.indexOf("$");
		if ($index < 0 || $index === qualifiedTypeName.length - 1) {
			return nullWithError(`qualified type '${qualifiedTypeName}' is not of the form '<meta model>$<type name>`);
		}

		const metaModelName = qualifiedTypeName.substring(0, $index).toLowerCase();
		const className = qualifiedTypeName.substring($index + 1);

		if (!classes[metaModelName]) {
			return nullWithError(`no meta model with name '${metaModelName}' exists`);
		}

		if (!classes[metaModelName][className]) {
			return nullWithError(`no type with name '${metaModelName}$${className} exists`);
		}

		return classes[metaModelName][className] as InstanceConstructor;
	}

	export function structureAffectsQualifiedNames(structure: structures.Structure) {
		return structure._declaredAsNamespace || (structure instanceof elements.AbstractElement && structure._isByNameReferrable());
	}

}


type InstanceConstructor = elements.IElementConstructor | units.IAbstractUnitConstructor;


function checkStructureVersion(instance: structures.Structure, includeWarnings: boolean) {
	instance.versionInfo.checkStructureVersion(instance, includeWarnings);
}


/**
 * Creates (deserializes) a structure based on incoming JSON.
 */
function createStructure(initializer: InstanceConstructor, cache: { [id: string]: any }, callback: (initializer) => any, json) {
	// element already known?
	if (cache[json.$ID]) {
		const element = cache[json.$ID];
		element._updateWithJson(json);
		// TODO: what if container was changed?
		return element;
	}
	if (initializer) {
		const instance = callback(initializer);
		instance._updateWithJsonImpl(json);
		instance._isUpdating = false; // initialization is done
		checkStructureVersion(instance, false);
		return instance;
	}
	return null;
}


function nullWithError(message: string) {
	console.error(message);
	return null;
}

