import {AbstractModel} from "./abstract-model";
import * as elements from "./elements";
import * as structures from "./structures";
import {common} from "../../common";

/**
 * The `units` module contains interfaces and base classes related to the concept of **units**.
 * For more information on this concept, see the README of this repository, under "About Mendix models".
 */

/**
 * An abstract unit is a vertex, and usually: a node, in the project tree, i.e. a macro-level construct.
 * Examples are: modules, folders, microflows, pages.
 * This interface is implemented by {@link AbstractUnit}.
 */
export interface IAbstractUnit extends structures.IStructure {

	/**
	 * The parent unit of this unit.
	 */
	container: IStructuralUnit;

	/**
	 * The name of the property of the parent's type which owns this unit.
	 */
	_containmentName: string;

	/**
	 * The {@link modelstore.IModelStore model store} holding the Mendix model this unit abides in.
	 */
	_model: AbstractModel;

	/**
	 * Whether this unit has been completely loaded and does not consist of the unit's interface
	 *  (which corresponds to the unit being partial).
	 */
	isLoaded: boolean;
	// TODO  consider rename -> isComplete

	/**
	 * Whether this unit is currently being loaded.
	 */
	_isLoading: boolean;

	/**
	 * Registers a callback taking this unit as argument, to be executed after the unit has been mark
	 * as completely loaded.
	 */
	_registerAfterLoadCallback(callback: (unit: IAbstractUnit) => void);

	/**
	 * Mark this unit as not having been loaded.
	 */
	_markNotLoaded();

	/**
	 * Mark this unit as having been loaded.
	 */
	_markLoaded();

	/**
	 * Mark this unit as being loaded.
	 */
	_markLoading();

}


export type IAbstractUnitConstructor = typeof ModelUnit | typeof AbstractUnit;

/**
 * Base class for implementations of {@link IAbstractUnit}.
 */
export abstract class AbstractUnit extends structures.Structure implements IAbstractUnit {

	public container: StructuralUnit;  // class-variant, more specific type than  IAbstractUnit#container
	_containmentName: string;
	_model: AbstractModel;

	constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, container: IStructuralUnit) {
		super(model, typeName, id, isPartial, container);
	}

	private _afterLoadCallbacks: { (unit: IAbstractUnit): void }[] = [];

	_isLoading: boolean = false;

	/**
	 * Checks whether all attributes are available at this instant;
	 * if false, a load is required to access these properties.
	 */
	public get isLoaded(): boolean {
		return !this._isPartial;
	}

	_markNotLoaded() {
		this._isLoading = false;
		this._isPartial = true;
	}

	_markLoaded() {
		this._isLoading = false;
		this._isPartial = false;
		this._afterLoadCallbacks.splice(0).forEach(cb => cb(this));
	}

	_markLoading() {
		if (this._isLoading || this.isLoaded) {
			throw new Error("Illegal state: cannot re-load a unit that's already loaded");
		}
		this._isLoading = true;
	}

	_registerAfterLoadCallback(callback: (unit: IAbstractUnit) => void) {
		this._afterLoadCallbacks.push(callback);
	}

	_updateWithJsonImpl(json: transport.IAbstractUnitJson) {
		super._updateWithJsonImpl(json.contents as any);
	}

	_dispose() {
		this._model._uncache(this);
		super._dispose();
	}

	/**
	 * Sends the create delta for this unit and all pending deltas.
	 */
	_handleCreateSelf() {
		this.unit._model._sendDelta({
			deltaType: deltas.DeltaTypes.CREATE_UNIT,
			unitId: this.id,
			containerId: this.container.id,
			containmentName: this._containmentName,
			contentType: this.typeName
		} as transport.ICreateUnitDelta);
		this._isNew = false;

		this._pendingDeltasAfterCreate.forEach(pending => {
			// FIXME: MWE: this is ugly, put lambdas in the queue or something. also see elements.ts
			if (pending instanceof Array) {
				(pending[0] as elements.Element)._sendCreateDelta(this as any as ModelUnit, pending[1]);
			} else {
				const delta = pending as transport.IDelta;
				delta.unitId = this.unit.id;
				this.unit._model._sendDelta(delta);
			}
		});
	}

	public deepCopyInto(newParent: IStructuralUnit): AbstractUnit {
		return super.deepCopyInto(newParent) as AbstractUnit;
	}

}

/*
 * A structural unit is a node (not a leaf) in the project tree.
 * Examples: folders & modules.
 */
export interface IStructuralUnit extends IAbstractUnit { }

/**
 * Implementation of {@link IStructuralUnit}.
 */
export class StructuralUnit extends AbstractUnit implements IStructuralUnit {

	constructor(model: AbstractModel, typeName: string, id: string, _ignoredIsPartial: boolean, container: IStructuralUnit) {
		// _ignoredPartial argument is here, because structural units are always loaded completely,
		// but it is nice to keep the constructors for all units uniform so that the factories are simpler.
		super(model, typeName, id, false, container);
	}

	public get unit() {
		return this;
	}

	public deepCopyInto(newParent: IStructuralUnit): AbstractUnit {
		// MWE: note that this is techinically possible, but what should be the semantics?
		// also clone structural children? Then the need to be loaded first. See also
		// comments in StructuralChild properties.
		throw new Error("Structural units like folders and modules cannot be cloned.");
	}

}

/**
 * Model Units
 *
 * A model unit is a leaf (not a node) in the project tree and the root containing model {@link elements.Element} elements.
 * It is both a(n abstract) unit as well as "model element-like" by virtue of being an MxAbstractElement,
 * but minus the following features of MxElement:
 *  public - a model unit is public by nature
 *  container - a model unit is itself the root of the tree of elements it contains
 *
 * A unit acts as scope to resolve by-id references and keeps a cache of elements it owns.
 */
export interface IModelUnit extends IAbstractUnit, elements.IAbstractElement {
	container: IStructuralUnit;
	delete(): void;
}

export interface IElementsCache {
	[id: string]: elements.AbstractElement;
}

/**
 * Implementation of {@link IModelUnit}.
 */
export class ModelUnit extends elements.AbstractElement implements IModelUnit { // ... should be double extends ...

	public container: StructuralUnit;
	_containmentName: string;

	_elementsCache: IElementsCache = {}; // all elements that are contained in this model unit - used to resolve references-by-id for example

	_isLoading: boolean = false;

	// Note: flagged as unused by tslint but needs to be in (see failing unit tests otherwise)!
	private _afterLoadCallbacks: { (unit: IAbstractUnit): void }[] = [];

	/* mimics multiple inheritance */
	_markNotLoaded: common.IVoidCallback = AbstractUnit.prototype._markNotLoaded;
	_markLoaded: common.IVoidCallback = AbstractUnit.prototype._markLoaded;
	_markLoading: common.IVoidCallback = AbstractUnit.prototype._markLoading;
	_registerAfterLoadCallback: (callback: common.ICallback<IAbstractUnit>) => void = AbstractUnit.prototype._registerAfterLoadCallback;
	_handleCreateSelf: common.IVoidCallback = AbstractUnit.prototype._handleCreateSelf;

	constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, container: IStructuralUnit) {
		super(model, typeName, id, isPartial, container);
		this._elementsCache[this.id] = this;
	}

	protected _updateWithJsonImpl(json: transport.IAbstractUnitJson) {
		AbstractUnit.prototype._updateWithJsonImpl.call(this, json); // delegate
	}

	public get unit() {
		return this;
	}

	public get isLoaded(): boolean {
		return !this._isPartial;
	}

	/**
	 * Given an element id, returns the element in the current model unit with that id, or null
	 */
	public findElementById(id: string): elements.AbstractElement {
		return this._elementsCache.hasOwnProperty(id) ? this._elementsCache[id] : null;
	}

	_dispose() {
		this._model._uncache(this);
		super._dispose(); // follow AbstractElement chain
	}

	public deepCopyInto(newParent: IStructuralUnit): ModelUnit {
		if (!this.isLoaded) {
			throw new Error("Only loaded elements can be copied. Use .load() first");
		}

		return structures.Structure.prototype.deepCopyInto.call(this, newParent) as ModelUnit;
	}

	public delete(): void {
		this.unit._model._sendDelta({
			deltaType: deltas.DeltaTypes.DELETE_UNIT,
			unitId: this.id
		} as transport.IDeleteUnitDelta);
		this._dispose();
	}

}

import * as deltas from "./deltas";
import * as transport from "./transport-interfaces";
