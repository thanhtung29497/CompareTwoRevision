import {ICheck, ICheckBodyForVersion, ICheckIssue, ICheckMessage} from "./checks-types";
import {IStructure} from "../internal/structures";
import {evaluateExpression, isNothing} from "./expressions-evaluator";
import {IQueryResolver} from "./queries";
import {lookupByVersion} from "./versioning";
import {expressionsTypes as expressions} from "../../gen/expressions-types";
import {Context} from "./context";


// only used for testing:
export function evaluateCheck(check: ICheck, structure: IStructure, queryResolver: IQueryResolver): ICheckIssue[] {
	const checkBody = lookupByVersion(check.versionCheckBodies, structure.model.metaModelVersion);
	return evaluateCheckBody(check.name, checkBody, structure, queryResolver);
}


export function evaluateCheckBody(
	checkName: string,
	checkBody: ICheckBodyForVersion,
	structure: IStructure,
	queryResolver: IQueryResolver
): ICheckIssue[] {

	function evaluateExpressionProtected(
		expr: expressions.MxExpression,
		context: Context,	// may be nothing
		description: string,
		fallBackOnError: () => any,
		warnOnNothing = false
	) {
		try {
			const exprEval = evaluateExpression(expr, structure, queryResolver, context);
			if (warnOnNothing && isNothing(exprEval)) {
				console.warn(`${description} on instance of '${structure.typeName}' -> nothing`);
			}
			return exprEval;
		} catch (e) {
			console.error(`could not evaluate ${description} on instance of '${structure.typeName}' due to: ${e}`);
			return fallBackOnError();
		}
	}

	let context = Context.createWithThis(structure);
	if (checkBody.variables) {
		checkBody.variables.forEach(variable => {
			context = context.withValue(
				variable.name,
				evaluateExpressionProtected(variable.value, null, `value expression for variable '${variable.name}'`, () => undefined)
			);
		});
	}

	/*
	 * Protect evaluation of check condition against throws and provide some debugging info in that case.
	 * It is not regular that the check condition evaluates to nothing, so that's reported as well.
	 */
	const conditionEval = evaluateExpressionProtected(
		checkBody.checkCondition.rule,
		context,
		`check condition of check '${checkName}'`,
		() => (checkBody.checkCondition.$type === "MxCheckConditionForList") ? [] : undefined,
		true	// warn on nothing
	);

	const isListy = (() => {
		switch (checkBody.checkCondition.$type) {
			case "MxCheckConditionForBoolean": return false;
			case "MxCheckConditionForList": return true;
			default:
				throw new Error(`unhandled type for MxCheck.checkCondition: ${checkBody.checkCondition.$type}`);
	}})();

	const faultyStructures: IStructure[] = isListy
		? conditionEval as IStructure[]
		: (!!conditionEval ? [structure] : []);		// undefined -> false

	return faultyStructures.map(forStructure => {
		return {
			structure: forStructure,
			message: calculateMessage(
				structure,			// structure check was run on, which is 'this' in message arguments
				checkBody.message,
				queryResolver,
				isListy ? context.withValue(checkBody.checkCondition.errorVar.name, forStructure) : context
			),
			severity: checkBody.severity,
			incorrectProperty: checkBody.incorrectProperty,
			checkName: checkName
		};
	});

}


/* (exported for testing) */
export function calculateMessage(structure: IStructure, message: ICheckMessage, queryResolver: IQueryResolver, context?: Context): string {
	const evaluatedArgs = message.arguments ? message.arguments.map(arg => evaluateExpression(arg, structure, queryResolver, context)) : [];
	return message.text.replace(/\{(\d+?)\}/g, (match: string, key?: string) => evaluatedArgs[key]);
}

