import {ICheck, ICheckBodyForVersion, ICheckIssue} from "./checks-types";
import {evaluateCheckBody} from "./checks-evaluator";
import {IStructure} from "../internal/structures";
import {ModelUnit} from "../internal/units";
import {IQueryResolver} from "./queries";
import {loadChecks} from "./metadata-loaders";
import {lookupByVersion} from "./versioning";
import {utils} from "../utils";
import {AbstractModel} from "../internal/abstract-model";


export type IChecksResolver = (qualifiedStructureName: string) => ICheck[];

export function makeChecksResolver(checks: ICheck[] = loadChecks()): IChecksResolver {
	const map: { [qualifiedStructureName: string]: ICheck[] } = {};

	checks.forEach(check => {
		check.allCompatibleTypes.forEach(qualifiedStructureName => {
			let checksList = map[qualifiedStructureName];
			if (!checksList) {
				checksList = map[qualifiedStructureName] = [];
			}
			checksList.push(check);
		});
	});

	return (qualifiedStructureName: string) => map[qualifiedStructureName];
}


function reportUnresolvedByNameReferences(unit: ModelUnit): ICheckIssue[] {
	return (unit.model as AbstractModel)._unresolvedReferencesFor(unit).map(ref => {
		const typeName = ref.targetType.split("$")[1];
		return {
			structure: ref.owner,
			message: `Failed to resolve reference. There is no [${typeName}] with this [${ref.qualifiedName()}]. `
				+ `Please select an existing [${typeName}]`,
			severity: "error",
			incorrectProperty: ref.propertyName,
			checkName: "UnresolvedByNameReference (generic)"
		};
	});
}


export function runChecksOn(unit: ModelUnit, checksResolver: IChecksResolver, queryResolver: IQueryResolver): ICheckIssue[] {
	if (!unit.isLoaded) {
		throw new Error("can only run checks on loaded unit");
	}

	const checkTasksPerLevelPerGroup = tasks(unit, checksResolver);

	const allIssues: ICheckIssue[][] = [];

	allIssues.push(reportUnresolvedByNameReferences(unit));

	for (let group in checkTasksPerLevelPerGroup) {
		let stopAfterThisLevel = false;
		const checkTasksPerLevel = checkTasksPerLevelPerGroup[group];
		for (let level in checkTasksPerLevel) {
			if (stopAfterThisLevel) {
				break;
			}
			if (!checkTasksPerLevel[level]) {
				continue;
			}
			for (let task of checkTasksPerLevel[level]) {
				const issues = evaluateCheckBody(task.checkName, task.checkBody, task.structure, queryResolver);
				if (issues.length > 0) {
					allIssues.push(issues);
					// always run all checks of level 0 (no level group) and 1 (1st level group):
					if (level !== "0") {	// (compare with string since for (let level: string...))
						stopAfterThisLevel = true;
					}
				}
			}
		}
	}

	return utils.flatten(allIssues);
}


const alwaysRunSpec = { group: 0, level: 0 };

/**
 * Gathers checks to be run against structures and groups them by check group and then by level.
 */
function tasks(unit: ModelUnit, checksResolver: IChecksResolver): ICheckTask[][][] {
	const mmVersion = unit.model.metaModelVersion;
	const checkTasksPerLevelPerGroup: ICheckTask[][][] = [];

	function lazilyCreatingGet<T>(buckets: T[][], index: number) {
		let bucket = buckets[index];
		if (!bucket) {
			bucket = [];
			buckets[index] = bucket;
		}
		return bucket;
	}

	unit.traverse(structure => {
		const checks = checksResolver(structure.typeName);
		if (checks) {
			checks.forEach(check => {
				const checkBody = lookupByVersion(check.versionCheckBodies, mmVersion);
				const runSpec = checkBody.runSpec || alwaysRunSpec;
				let checkTasksPerLevel = lazilyCreatingGet(checkTasksPerLevelPerGroup, runSpec.group);
				let checkTasks = lazilyCreatingGet(checkTasksPerLevel, runSpec.level);
				checkTasks.push({
					structure: structure,
					checkBody: checkBody,
					checkName: check.name
				});
			});
		}
	});

	return checkTasksPerLevelPerGroup;
}

interface ICheckTask {
	structure: IStructure;
	checkBody: ICheckBodyForVersion;
	checkName: string;
}

