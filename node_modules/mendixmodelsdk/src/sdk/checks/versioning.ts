import {Version} from "../internal/version-checks";


export interface IVersionRange {
	from?: string;
	to?: string;
}

export interface IVersioned {
	range?: IVersionRange;
}

export function lookupByVersion<T extends IVersioned>(versionedThings: T[], mmVersion: Version): T {
	if (!versionedThings || versionedThings.length === 0) {
		throw new Error("No versioned things provided.");
	}
	let matchingVersionThing = null;
	for (let versionOfThing of versionedThings) {
		if (	!versionOfThing.range
			|| (
					(!versionOfThing.range.from || mmVersion.isAfterOrEqual(Version.parse(versionOfThing.range.from)))	// [ -infty | vFrom, ...)
				&&
					(!versionOfThing.range.to   || mmVersion.isBefore(Version.parse(versionOfThing.range.to)))			// [..., infty | vTo ]
			)
		) {
			if (matchingVersionThing) {
				throw Error(`More than one valid match on ${mmVersion}; ranges: ${versionedThings.map(rangeToString).join(", ")}.`);
			} else {
				matchingVersionThing = versionOfThing;
			}
		}
	}
	if (matchingVersionThing) {
		return matchingVersionThing;
	}
	throw new Error(`No versioned thing which matches meta model version ${mmVersion} provided; `);
}


function rangeToString<T extends IVersioned>(versionedThing: T): string {
	const leftBoundary = (versionedThing.range && versionedThing.range.from) ? versionedThing.range.from : "-∞";
	const rightBoundary = (versionedThing.range && versionedThing.range.to) ? versionedThing.range.to : "∞";
	return `[${leftBoundary}, ${rightBoundary})`;
}

