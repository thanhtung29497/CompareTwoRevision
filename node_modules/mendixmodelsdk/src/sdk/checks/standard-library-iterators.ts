import {flowRight, find} from "lodash";
import {isNothing} from "./expressions-evaluator";


export const standardIterators: {
	[name: string]: (operand: any[] | void, boundExpr: IteratorLambda<any, any>) => any;
} = {
		// (in alphabetic order, for easy lookup:)
		EVERY: every,
		FILTER: filter,
		FIND_FIRST: findFirst,
		MAP: map,
		SOME: some
	};


/** Convenience type for tri-valued logic. */
type Boolean = boolean | void;


/**
 * Algebraic data type (!) of (ostensibly: iterator-)functions/lambdas
 * taking a value and its previous value of a list,
 * with previousValue === null for the head list item.
 */
export type IteratorLambda<T, R> = (value: T, index: number, array: Array<T>) => R;

/**
 * Produces an iterator lambda on Booleans that maps undefined values to false.
 */
function normalize<U, R>(lambda: IteratorLambda<U, Boolean>): IteratorLambda<U, boolean> {
	return flowRight(b => !!b, lambda) as IteratorLambda<U, boolean>;
}


/**
 * A class to capture the state of an iteration which consists of the array of which is iterated,
 * the current index and the current value - which equals array[index] if index is valid and undefined otherwise.
 * It helps in implementing the previous operator (and even more generic offset operators)
 * by updating the iteration state in the current context to it.previous().
 * This is a cleaner way than to keep track of the previous value and passing that to expressions
 * bound in the iterator.
 */
export class IterationState<T> {

	constructor(public index: number, public array: Array<T>) {}

	value() {
		return this.index !== undefined && ((0 <= this.index) && this.index < this.array.length)
			? this.array[this.index]
			: undefined;
	}

	previous() {
		return this.index > 0
			? new IterationState<T>(this.index - 1, this.array)
			: new IterationState<T>(undefined, this.array);
	}

};


function every<T>(items: T[] | void, boundExpr: IteratorLambda<T, Boolean>): Boolean {
	if (isNothing(items)) {
		return false;
	}

	const fItems = (items as T[]).map(boundExpr);
	if (fItems.some(fItem => isNothing(fItem))) {
		return false;
	}

	return fItems.every(fItem => !!fItem);
}

function findFirst<T>(items: T[] | void, boundExpr: IteratorLambda<T, Boolean>): T | void {
	if (isNothing(items)) {
		return undefined;
	}

	return find(items as T[], normalize(boundExpr));
}

function filter<T>(items: T[] | void, boundExpr: IteratorLambda<T, Boolean>): T[] | void {
	if (isNothing(items)) {
		return undefined;
	}

	return (items as T[]).filter(normalize(boundExpr));
}

function map<T, R>(items: T[] | void, boundExpr: IteratorLambda<T, R | void>): R[] | void {
	if (isNothing(items)) {
		return undefined;
	}

	return (items as T[]).map(boundExpr).filter(item => item !== undefined) as R[];
}

function some<T>(items: T[] | void, boundExpr: IteratorLambda<T, Boolean>): Boolean {
	if (isNothing(items)) {
		return false;
	}
	if ((items as T[]).length === 0) {
		return false;
	}
	const fItems = (items as T[]).map(boundExpr);
	if (fItems.some(fItem => !!fItem)) {
		return true;
	}
	if (fItems.every(fItem => isNothing(fItem))) {
		return undefined;
	}
	return false;
}

