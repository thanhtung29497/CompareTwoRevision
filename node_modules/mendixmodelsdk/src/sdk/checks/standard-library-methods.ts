import {utils} from "../utils";
import {isNothing} from "./expressions-evaluator";
import {Structure, IStructure, aliases} from "../internal/structures";
import {AbstractElement} from "../internal/elements";
import {AbstractUnit, IAbstractUnit} from "../internal/units";
import {validateSyntax} from "./name-util";

import {isNumber, isArray, isString, uniq, last as _last} from "lodash";
import {isObservableArray} from "mobx";


export const standardLibraryMethods: {
	[name: string]: (source: any | void, args: any[] | void) => any;		// (not "arguments")
} = {
	// (in alphabetic order, for easy lookup:)
	asType: asType,
	concat: concat,
	container: container,
	containerAs: containerAs,
	contains: contains,
	firstContainerOfType: firstContainerOfType,
	firstContainerOfTypes: firstContainerOfTypes,
	flatten: flatten,
	get: get,
	hasDuplicates: hasDuplicates,
	isDefined: isDefined,
	isEmpty: isEmpty,
	isEmptyOrUndefined: isEmptyOrUndefined,
	isOfType: isOfType,
	isUndefined: isUndefined,
	last: last,
	length: length,
	modelUnit: modelUnit,
	notEmpty: notEmpty,
	parts: parts,
	partsOfType: partsOfType,
	qualifiedName: qualifiedName,
	toLowerCase: toLowerCase,
	typeFilter: typeFilter,
	startsWith: startsWith,
	validateName: validateName
};


function isNotList<T>(items: T[] | void): boolean {
	return isNothing(items) || !(isArray(items) || isObservableArray(items));
}

function firstArg(args: any[] | void): any {
	return isNotList(args) ? undefined : args[0];
}


function asType<T extends IStructure>(source: T | void, args: any[] | void): T | void {
	const typeLiteral = firstArg(args);

	return (
				isNothing(source)
			|| !(source instanceof Structure)
			|| isNothing(typeLiteral)
			|| !(typeLiteral instanceof StructureTypeLiteral)
			|| !(source instanceof typeLiteral.clazz)
		)
			? undefined
			: source;
}

function concat<T>(items: T[] | void, args: any[] | void): T[] | void {
	const toConcat = firstArg(args);
	if (isNotList(toConcat) || isNotList(items)) {
		return undefined;
	}
	return (items as T[]).concat(toConcat);
}

function container<T>(source: any | void): aliases.IContainer | void {
	return isNothing(source)
		? undefined
		: source.container;
}

function containerAs(source: any | void, args: any[] | void): IStructure | void {
	const typeLiteral = firstArg(args);

	if (isNothing(source) || !(source instanceof Structure) || isNothing(typeLiteral)) {
		return undefined;
	}

	const _container = container(source);
	if (isNothing(_container)) {
		return undefined;
	}

	return asType(_container, [typeLiteral]);
}

function contains<T>(items: T[] | void, args: any[] | void) {
	const element = firstArg(args);

	if (isNotList(items) || isNothing(element)) {
		return undefined;
	}

	return (items as T[]).indexOf(element) > -1;
}

function firstContainerOfType(source: any | void, args: any[] | void): IStructure | void {
	const typeLiteral = firstArg(args);

	if (isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
		return undefined;
	}

	return firstContainerOfTypes(source, [typeLiteral]);
}

function firstContainerOfTypes(source: any | void, args: any[] | void): IStructure | void {
	const typeLiterals = isNotList(args) ? [] : (args as any[]).filter(typeLiteral => typeLiteral instanceof StructureTypeLiteral);

	if (isNothing(source) || !(source instanceof Structure) || typeLiterals.length === 0) {
		return undefined;
	}

	let currentStructure = (source as IStructure).container;
	while (!isNothing(currentStructure) && !(typeLiterals.some(typeLiteral => currentStructure instanceof typeLiteral.clazz))) {
		currentStructure = currentStructure.container;
	}
	return currentStructure;
}

function flatten<T>(items: T[][] | void): T[] | void {
	if (isNotList(items)) {
		return undefined;
	}

	return utils.flatten(items as T[][]);
}

function get<T>(items: T[] | void, args: any[]): T | void {
	if (isNotList(items) || isNotList(args) || !isNumber(args[0])) {
		return undefined;
	}

	const index: number = args[0];
	return (index < 1 || (items as T[]).length < index) ? undefined : items[index - 1];
}

function hasDuplicates<T>(items: T[] | void): Boolean {
	if (isNotList(items)) {
		return undefined;
	}

	const list = items as T[];
	return uniq(list).length < list.length;
}

function isDefined(source: any): boolean {
	return !isNothing(source);
}

function isEmpty<T>(items: T[] | void): boolean {
	return (isNotList(items))
		? undefined
		: ((items as T[]).length === 0);
}

function isEmptyOrUndefined<T>(items: T[] | void): boolean {
	return isNothing(items) || isEmpty(items);
}

function isOfType<T extends IStructure>(source: T | void, args: any[] | void): Boolean {
	const typeLiteral = firstArg(args);

	return (
				isNothing(source)
			|| !(source instanceof Structure)
			|| isNothing(typeLiteral)
			|| !(typeLiteral instanceof StructureTypeLiteral)
		)
			? undefined
			: (source instanceof typeLiteral.clazz);
}

function isUndefined<T>(source: T | void): boolean {
	return isNothing(source);
}

function last<T>(items: T[] | void): T | void {
	return (isNotList(items))
		? undefined
		: _last(items as T[]);
}

function length<T>(items: T[] | void): number | void {
	return (isNotList(items))
		? undefined
		: (items as T[]).length;
}

function modelUnit<T extends Structure>(source: T | void): IAbstractUnit | void {
	if (isNothing(source) || !(source instanceof Structure)) {
		return undefined;
	}
	return (source instanceof AbstractUnit)
		? source as any as AbstractUnit
			// TODO  try and remove the ugly "as any"
		: (source as T).unit;
}

function notEmpty<T>(items: T[] | void): Boolean {
	return (isNotList(items))
		? undefined
		: ((items as T[]).length > 0);
}

function parts(source: Structure | void): Structure[] {
	if (isNothing(source)) {
		return [];
	}

	if (!(source instanceof Structure)) {
		return undefined;
	}

	const something = source as Structure;

	const structures: Structure[] = [];

	something.traverse(structure => {
		if (structure !== something) {
			structures.push(structure as Structure);
		}
	});

	return structures;
}

function partsOfType<T extends Structure>(source: T | void, args: any[] | void): T[] {
	if (isNothing(source)) {
		return [];
	}

	const something = source as T;

	const typeLiteral = firstArg(args);
	if (!(something instanceof Structure) || isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
		return undefined;
	}

	const structures: T[] = [];

	something.traverse(structure => {
		if (structure !== something && structure instanceof typeLiteral.clazz) {
			structures.push(structure as T);
		}
	});

	return structures;
}

function qualifiedName(source: IStructure | void): string | void {
	return isNothing(source) || !(source instanceof AbstractElement)
		? undefined
		: (source as AbstractElement).qualifiedName;
}

function toLowerCase(source: string | void): string | void {
	if (isNothing(source)) {
		return undefined;
	}

	return (source as string).toLowerCase();
}

function typeFilter<T>(items: T[] | void, args: any[] | void): T[] | void {
	const typeLiteral = firstArg(args);

	if (isNothing(items) || isNothing(typeLiteral) || !(typeLiteral instanceof StructureTypeLiteral)) {
		return undefined;
	}

	return (items as T[]).filter(item => item instanceof typeLiteral.clazz);
}

function startsWith(source: string | void, args: any[] | void): Boolean {
	if (isNothing(source) || isNotList(args) || !isString(args[0])) {
		return undefined;
	}

	return (source as string).indexOf(args[0] as string) === 0;
}

function validateName(source: string | void): string | void {
	return validateSyntax(source as string);
}


export class StructureTypeLiteral {
	constructor(public clazz: any /* TODO  sharpen type */) { }
}

