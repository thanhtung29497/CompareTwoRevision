import {indexOf} from "lodash";


/**
 * Functionality to check whether names are valid.
 *
 * Sources:
 *  https://sprintr.home.mendix.com/link/document/091ba8bc-5fe8-460f-abc1-df2b8212159e
 *  https://gitlab.srv.hq.mendix.net/modeler/modeler/blob/master/Mendix.Modeler.Core/Common/Model/NameUtil.cs#L12
 */

const sortedReservedWords = [
	// Java keywords:
	"abstract",
	"assert",
	"boolean",
	"break",
	"byte",
	"case",
	"catch",
	"char",
	"class",
	"const",
	"continue",
	"default",
	"do",
	"double",
	"else",
	"enum",
	"extends",
	"false",
	"final",
	"finally",
	"float",
	"for",
	"if",
	"goto",
	"implements",
	"import",
	"instanceof",
	"int",
	"interface",
	"long",
	"native",
	"new",
	"null",
	"package",
	"private",
	"protected",
	"public",
	"return",
	"short",
	"static",
	"strictfp",
	"super",
	"switch",
	"synchronized",
	"this",
	"throw",
	"throws",
	"transient",
	"true",
	"try",
	"void",
	"volatile",
	"while",
	// Mendix-specific keywords:
	"currentUser",
	"object",
	"type",
	"guid",
	"id",
	"submetaobjectname",
	"createddate",
	"changeddate",
	"owner",
	"changedby",
	"empty",
	"MendixObject",
	"context",
	"__filename__",
	// Windows keywords:
	"con"
].map((word) => word.toLowerCase()).sort();

const isReservedWord = (name: string) => indexOf(sortedReservedWords, name.toLowerCase(), true) > -1;

const validNameRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;

/**
 * Validates the name syntactically without looking at the context (so no uniqueness check).
 * @returns {string} with error message or null in which case name is valid.
 */
export function validateSyntax(name: string): string | void {
	if (!name || name.length === 0) {
		return `Name cannot be empty`;
	}

	if (name.length > 255) {
		return `Name is too long`;
	}

	if (!validNameRegex.test(name)) {
		return `Names should start with a letter and can only contain letters, digits and underscores`;
	}

	if (isReservedWord(name)) {
		return `Name is a reserved word`;
	}

	return null;
}

