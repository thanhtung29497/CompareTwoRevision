import {expressionsTypes as expressions} from "../../gen/expressions-types";
import {instancehelpers} from "../../sdk/internal/instances";
import {AbstractModel} from "../../sdk/internal/abstract-model";
import {IStructure, Structure} from "../internal/structures";
import {standardIterators, IterationState} from "./standard-library-iterators";
import {standardLibraryMethods, StructureTypeLiteral} from "./standard-library-methods";
import {IQueryResolver, IQuery} from "./queries";
import {lookupByVersion} from "./versioning";
import {Context} from "./context";


/**
 * Union/sum type to be able to recurse over types other than MxExpression.
 * This should match with ExpressionsTypesHelper#evaluatableTypes in the Model SDK generator.
 */
export type Evaluatable = expressions.MxExpression | expressions.MxFeatureCall;

type Evaluator = (evaluatable: Evaluatable) => any;	// (but "expr" is typically used as name for 1st argument)


export function evaluateExpression(
	expr: Evaluatable,
	structure: IStructure,
	queryResolver: IQueryResolver,
	context?: Context
): any {

	// share model across all helper functions (fall-backs are purely for testing...):
	const model = structure ? structure.model : undefined;
	const modelClasses = structure ? (model as AbstractModel)._allModelClasses() : {};

	return _eval(expr, structure, context || Context.createWithThis(structure));

	function _eval(evaluatable: Evaluatable, source: any, context: Context): any {
		const polyMap: { [typeName: string]: Evaluator } = {

			// for every non-abstract sub type of Evaluatable, provide an interpretation -- please sort by type name:

			"MxBinaryExpression": (expr: expressions.MxBinaryExpression) => evalBinary(expr, source, context),

			"MxBooleanLiteralExpression": (expr: expressions.MxBooleanLiteralExpression) => expr.value,

			"MxColorLiteralExpression": (expr: expressions.MxColorLiteralExpression) => {
				return { red: expr.red, green: expr.green, blue: expr.blue };
			},

			"MxDoubleLiteralExpression": (expr: expressions.MxDoubleLiteralExpression) => expr.value,

			"MxFeatureCallWrapper": (expr: expressions.MxFeatureCallWrapper) => _eval(expr.featureCall, source, context),

			"MxFollowExcluding": (expr: expressions.MxFollowExcluding) => evalFollowExcluding(expr, source, context),

			"MxFollowIncluding": (expr: expressions.MxFollowExcluding) => evalFollowIncluding(expr, source, context),

			"MxIntegerLiteralExpression": (expr: expressions.MxIntegerLiteralExpression) => expr.value,

			"MxIteratorCall": (expr: expressions.MxIteratorCall) => evalIteratorCall(expr, source, context),

			"MxListLiteralExpression": (expr: expressions.MxListLiteralExpression) => {
				const evalItems = expr.items.map(item => _eval(item, source, context));
				return evalItems.some(evalItem => isNothing(evalItem)) ? undefined : evalItems;
					// simple failure semantics: propagate undefined
			},

			"MxMethodCall": (expr: expressions.MxMethodCall) => evalMethodCall(expr, source, context),

			"MxPrefixExpression": (expr: expressions.MxPrefixExpression) => {
				const exprEval = _eval(expr.expression, source, context);
				return isNothing(exprEval) ? exprEval : (!exprEval);	// simple failure semantics: propagate undefined
			},

			"MxPreviousExpression": (expr: expressions.MxPreviousExpression) =>
				context.getIterationState(expr.variable.referredVariable).previous().value(),

			"MxPropertyCall": (expr: expressions.MxPropertyCall) => isNothing(source) ? undefined : source[expr.referredProperty],

			"MxQualifiedEnumLiteralExpression": (expr: expressions.MxQualifiedEnumLiteralExpression) => evalQualifiedEnumLiteral(expr),

			"MxSizeLiteralExpression": (expr: expressions.MxSizeLiteralExpression) => { return { height: expr.height, width: expr.width }; },

			"MxStringLiteralExpression": (expr: expressions.MxStringLiteralExpression) => expr.value,

			"MxStructureLiteralExpression": (expr: expressions.MxStructureLiteralExpression) => evalStructureLiteral(expr, source, context),

			"MxSwitch": (expr: expressions.MxSwitch) => evalSwitch(expr, source, context),

			"MxThisExpression": (expr: expressions.MxThisExpression) => context.getThis(),

			"MxTypeStructureLiteralExpression": (expr: expressions.MxTypeStructureLiteralExpression) =>
				new StructureTypeLiteral(instancehelpers.lookupClass(expr.referredStructure, modelClasses)),

			"MxUndefinedExpression": (expr: expressions.MxUndefinedExpression) => undefined,

			"MxVariableRefExpression": (expr: expressions.MxVariableRefExpression) => context.getValue(expr.referredVariable)

		};
		const evalFn = polyMap[evaluatable.$type];
		if (!evalFn) {
			throw new Error(`unhandled expression type: ${evaluatable.$type}`);
		}
		const baseEval = evalFn(evaluatable);
		// for some debugging convenience: call logBaseEval(evaluatable, source, baseEval) using expressions-debug-util
		return evalApplicable(evaluatable as expressions.MxExpression, baseEval, context);
	}

	function evalApplicable(expr: expressions.MxExpression, baseEval: any, context: Context): any {
		return !expr.appliedFeature	// no check for nothingness: e.g. '.isUndefined()' can turn nothing into something
			? baseEval				// simple failure semantics: propagate undefined
			: _eval(expr.appliedFeature, baseEval, context);
	}

	function evalBinary(expr: expressions.MxBinaryExpression, source: any, context: Context): any {
		if (expr.operator === "NONE") {
			throw new Error("sentinel value of MxOperator not allowed in runtime");
		}

		const evalLeft = _eval(expr.left, source, context);
		const evalRight = _eval(expr.right, source, context);		// (no shortcutting)
		if (isNothing(evalLeft) || isNothing(evalRight)) {
			switch (expr.operator) {
				case "UNEQUALS": return true;
				case "AND": return undefined;
				case "OR": {
					if (isNothing(evalLeft) && isNothing(evalRight)) {
						return false;
					}
					// take the [not-un]defined one:
					return isNothing(evalLeft) ? evalRight : evalLeft;
				}
				default: return false;
			}
		}

		switch (expr.operator) {
			case "AND": return evalLeft && evalRight;
			case "EQUALS": return evalLeft === evalRight;
			case "GREATER": return evalLeft > evalRight;	// (no type coercion)
			case "GREATER_OR_EQUALS": return (evalLeft > evalRight) || (evalLeft === evalRight);	// (some type coercion)
			case "LESS": return evalLeft < evalRight;	// (no type coercion)
			case "LESS_OR_EQUALS": return (evalLeft < evalRight) || (evalLeft === evalRight);	// (some type coercion)
			case "OR": return evalLeft || evalRight;
			case "UNEQUALS": return evalLeft !== evalRight;
			default: return undefined;
		}
	}

	function evalFollowExcluding(expr: expressions.MxFollowExcluding, source: any, context: Context): any[] {
		const evalIncluding = evalFollowIncluding(expr, source, context);
		return isNothing(evalIncluding) || !Array.isArray(evalIncluding) ? evalIncluding : evalIncluding.slice(1);
	}

	// Note: takes expr of type MxAbstractFollow!
	function evalFollowIncluding(expr: expressions.MxAbstractFollow, source: any, context: Context): any[] {
		if (isNothing(source)) {
			return undefined;
		}
		const visited: any[] = [];
		let currentElement = source;
		while (!isNothing(currentElement)) {	// (always true for 1st iteration)
			if (visited.indexOf(currentElement) > -1) {	// (check before adding)
				visited.push(currentElement);	// cycle!
				break;
			}
			visited.push(currentElement);
			currentElement = _eval(expr.path, currentElement, context.withValue(expr.variable.name, currentElement));
		}
		return visited;
	}

	function evalIteratorCall(expr: expressions.MxIteratorCall, source: any, context: Context): any {
		const iterator = standardIterators[expr.type];
		if (!iterator) {
			throw new Error(`Iterator not implemented: '${expr.type}'`);
		}
		return iterator(
			source,
			(value, index, array) => _eval(
				expr.body,
				undefined /* could be "source" but nothing seems to be more correct */,
				context.withIterationState(expr.variable.name, new IterationState<any>(index, array))
			)
		);
	}

	function evalMethodCall(expr: expressions.MxMethodCall, source: any, context: Context): any {
		const method = standardLibraryMethods[expr.referredMethod];
		if (method) {
			const argValues = (expr.arguments || []).map(argExpr => _eval(argExpr, source, context)).slice();
			// for some debugging convenience:
			// 		call logMethodCall(expr, source, argValues, result) using expressions-debug-util,
			// 		with result = method(source, argValues)
			return method(source, argValues);
		}
		if (isNothing(source)) {	// check nothingness only for query since nothing can be valid/useful input for methods
			return undefined;
		}
		if (!(source instanceof Structure)) {
			throw new Error(`Cannot call query '${expr.referredMethod}' on non-Structure`);
		}
		const query : IQuery = queryResolver(expr.referredMethod, source.typeName);
		if (query) {
			const queryBody = lookupByVersion(query.queryVersions, model.metaModelVersion);
			let queryContext = context.withThis(source);

			if( query.parameters) {
				const argValues = (expr.arguments || []).map(argExpr => _eval(argExpr, source, context)).slice();
				query.parameters.forEach((item, index) => {
					queryContext = queryContext.withValue(query.parameters[index].name, argValues[index]);
				});
			}
			if (queryBody.variables) {
				for (let variable of queryBody.variables) {
					queryContext = queryContext.withValue(variable.name, _eval(variable.value, source, queryContext));
				}
			}
			return _eval(queryBody.value, source, queryContext);
		}
		throw new Error(`Method not implemented by either standard lib or as query on instance of ${source.typeName}: ${expr.referredMethod}`);
	}

	function evalQualifiedEnumLiteral(expr: expressions.MxQualifiedEnumLiteralExpression) {
		const enumClazz = instancehelpers.lookupClass(expr.enumeration, modelClasses);
		if (!enumClazz) {
			return undefined;
		}
		const literal = enumClazz[expr.literal];
		if (!literal) {
			return undefined;
		}
		return literal;
	}

	function evalStructureLiteral(expr: expressions.MxStructureLiteralExpression, source: any, context: Context): any {
		const assignments: { [propertyName: string]: any } = {};
		for (let assignment of expr.assignments) {
			const evalAssignment = _eval(assignment.value, source, context);
			if (isNothing(evalAssignment)) {
				return undefined;
			}
			assignments[assignment.property] = evalAssignment;
		}
		const clazz = instancehelpers.lookupClass(expr.structure, modelClasses);
		if (!clazz) {
			return undefined;
		}
		const newStructure = clazz.create(model);
		if (!newStructure) {
			return undefined;
		}
		for (let propertyName in assignments) {
			newStructure["__" + propertyName].set(assignments[propertyName]);
		}
		return newStructure;
	}

	function evalSwitch(expr: expressions.MxSwitch, source: any, context: Context): any {
		const switchContext = context.withValue(expr.variable.name, source);
		for (let switchCase of expr.cases) {
			if (evalSwitchCase(switchCase, source, switchContext)) {
				return _eval(switchCase.value, undefined, switchContext);
			}
		}
		return undefined;
	}

	function evalSwitchCase(switchCase: expressions.MxSwitchCase, source: any, context: Context): Boolean {
		const typeMatches = (() => {
			if (!switchCase.expectedType) {
				return true;
			}
			const typeLiteral = _eval(switchCase.expectedType, undefined, context);
			return isNothing(typeLiteral) ? false : source instanceof typeLiteral.clazz;
		})();
		return typeMatches && /* condition matches: */ (!switchCase.condition || !!_eval(switchCase.condition, undefined, context));
	}

}


/**
 * Checks whether the argument is "nothing", i.e. either undefined or null.
 */
export function isNothing(arg: any) {
	return (arg === undefined || arg === null);
}

