import node_uuid = require("node-uuid");
import * as internal from "./internal";
import {JavaScriptSerializer} from "./extras/as-model-sdk-code-serializer";

/**
 * The `utils` module contains various utility interfaces and functions.
 */
export namespace utils {

	/**
	 * Generates a random UUID to set the ID of an element or unit to.
	 * There is no intrinsic ID collision detection/avoidance mechanism but it's good enough in practice.
	 */
	export function randomUuid() {
		return node_uuid.v4();
	}

	/**
	 * Flattens an array of arrays of items of type `T`, returning a single array
	 * that consists of the concatenation of the original arrays.
	 * This is especially useful for arrays of arrays of observables since the `lodash`
	 * doesn't handle these correctly.
	 */
	export function flatten<T>(array: T[][]): T[] {
		/*
		* Note: lodash does not handle observable arrays correctly in the flatten function.
		* We could use the raw values instead, but this one is more strongly-typed anyway.
		*/
		let result = [];
		for (let i = 0, l = array.length; i < l; i++) {
			result.splice.apply(result, ([(result as any).length, 0] as T[]).concat(array[i].slice()));
		}
		return result;
	}

	/**
	 * Combines the given `parts` and returns them as an URL, avoiding duplicate slashes.
	 */
	export function combineUrl(...parts: string[]) {
		return parts.reduce((previousValue, currentValue) => {
			// strip all trailing slashes from previousValue, strip all leading slashes from currentValue, and combine the two with a slash
			return previousValue.replace(/\/+$/, "") + "/" + currentValue.replace(/^\/+/, "");
		});
	}

	/**
	 * Given a unit, generates JavaScript(/TypeScript) code that would re-create the same unit.
	 * Useful as scaffolding for model generators.
	 */
	export function serializeToJs(unit: internal.IAbstractUnit): string {
		return JavaScriptSerializer.serializeToJs(unit);
	}

	export interface IMap<T> {
		[key: string]: T;
	}

	export function removeFromArray<T>(list: T[], item: T) {
		const idx = list.indexOf(item);
		if (idx !== -1) {
			list.splice(idx, 1);
		}
	}

	export function getOrCreateMapEntry<T>(map: IMap<T>, key: string, initializer: () => T): T {
		const result = map[key];
		return result !== undefined ? result : (map[key] = initializer());
	}

	let alreadyPrintedWarnings: { [warning: string]: boolean } = {};
	/**
	 * Prints a warning, but only if it has not been printed before
	 */
	export function warnOnce(message: string) {
		if (alreadyPrintedWarnings[message]) {
			return;
		}
		alreadyPrintedWarnings[message] = true;
		console.warn(message);
	}

	/**
	 * resets the state of remembered warnings; so that all warnings are reported again.
	 */
	export function resetAlreadyPrintedWarningsState() {
		alreadyPrintedWarnings = {};
	}

	export function assertNotNull<T>(value: T, propertyName: string, listy = false) {
		if (typeof value === "undefined" || value === null) {
			throw new Error(listy ? `Cannot push null to ${propertyName}` : `Cannot set ${propertyName} to null`);
		}
	}

}
