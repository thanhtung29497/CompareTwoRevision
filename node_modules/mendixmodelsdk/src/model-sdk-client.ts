import * as internal from "./sdk/internal";
import {configuration} from "./sdk/config";
import {common} from "./common";
import {AbstractModel} from "./sdk/internal/abstract-model";
import {IDeployJobStatus, IEnvironmentStatus} from "./sdk/internal/transport-interfaces";
import {IModelApiClient, IEditorData} from "./sdk/internal/model-api-client";
import * as lodash from "lodash";
import {utils} from "./sdk/utils";
import {IWorkingCopy} from "./sdk/internal/transport-interfaces";

/**
 * Client class of the Mendix Model SDK.
 * By instantiating this class with appropriate configuration, you can create and read working copies.
 */
export class ModelSdkClientImpl<IT extends internal.IAbstractModel, CT extends internal.AbstractModel> {

	private client: internal.IModelApiClient;

	public constructor(
		private connectionConfig: configuration.ISdkConfig,
		private modelConstructor: {
			new (_client: IModelApiClient, _errorHandler: common.IErrorCallback, _connectionConfig: configuration.ISdkConfig): CT
		}
	) {
		const defaultConfig: configuration.ISdkConfig = {
			endPoint: "https://model.api.mendix.com"
		};

		const sdkConfig: configuration.ISdkConfig = lodash.extend({}, defaultConfig, connectionConfig);

		this.client = sdkConfig.client
			? this.client = connectionConfig.client
			: new internal.ModelApiClientImpl(sdkConfig.transportation || new internal.RestTransportation(sdkConfig));
	}

	/**
	 * Create a new working copy on the model server, and reads it for immediate editing.
	 */
	public createWorkingCopy(
		workingCopyParameters: configuration.ICreateWorkingCopyParameters,
		callback: common.ICallback<IT>,
		errorCallback: common.IErrorCallback
	) {
		configuration.checkCallbacks(callback, errorCallback);

		AbstractModel.create(
			this.client,
			workingCopyParameters,
			workingCopyInfo => {
				console.log(`Created working copy ${workingCopyInfo.id}`);
				this.openWorkingCopy(workingCopyInfo.id, callback, errorCallback);
			},
			errorCallback
		);
	}

	/**
	 * Reads a working copy on the model server so it can be edited.
	 */
	public openWorkingCopy(workingCopyId: string, callback: common.ICallback<IT>, errorCallback: common.IErrorCallback) {
		configuration.checkWorkingCopyId(workingCopyId);
		configuration.checkCallbacks(callback, errorCallback);

		utils.resetAlreadyPrintedWarningsState();
		AbstractModel.read(
			this.client, workingCopyId,
			this.connectionConfig,
			new this.modelConstructor(this.client, errorCallback, this.connectionConfig), callback, errorCallback
		);
	}

	/**
	 * Gets meta data of a working copy
	 */
	public loadWorkingCopyMetaData(
		workingCopyId: string,
		callback: common.ICallback<internal.IWorkingCopy>,
		errorCallback: common.IErrorCallback
	) {
		configuration.checkWorkingCopyId(workingCopyId);
		configuration.checkCallbacks(callback, errorCallback);
		this.client.loadWorkingCopyMetaData(workingCopyId, callback, errorCallback);
	}

	/**
	 * Deletes this working copy from the server, and the (SDK) client.
	 */
	public deleteWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.deleteWorkingCopy(workingCopyId, callback, errorCallback);
	}

	/**
	 * Grants access to the member specified to his/her OpenID on this working copy.
	 */
	public grantAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.grantAccess(workingCopyId, memberOpenId, callback, errorCallback);
	}

	/**
	 * Revokes access of the member specified to his/her OpenID on this working copy.
	 */
	public revokeAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.revokeAccess(workingCopyId, memberOpenId, callback, errorCallback);
	}

	/**
	 * Grants access to the member specified to his/her OpenID to the default working copy of this project.
	 */
	public grantAccessByProject(
		projectId: string,
		memberOpenId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.grantAccessByProject(projectId, memberOpenId, callback, errorCallback);
	}

	/**
	 * Revokes access of the member specified to his/her OpenID to the default working copy of this project.
	 */
	public revokeAccessByProject(
		projectId: string,
		memberOpenId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.revokeAccessByProject(projectId, memberOpenId, callback, errorCallback);
	}

	/**
	 * Returns whether the member specified to his/her OpenID has (been granted) access to this working copy.
	 */
	public checkAccess(
		workingCopyId: string,
		memberOpenId: string,
		callback: common.ICallback<boolean>,
		errorCallback: common.IErrorCallback
	) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.checkAccess(workingCopyId, memberOpenId, callback, errorCallback);
	}

	/**
	 * Exports this working copy as MPK.
	 */
	public exportMpk(workingCopyId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.exportMpk(workingCopyId, outFilePath, callback, errorCallback);
	}

	/**
	 * Start deploy this working copy and create new job.
	 */
	public startAppUpdate(
		workingCopyId: string,
		callback: common.ICallback<IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.startAppUpdate(workingCopyId, callback, errorCallback);
	}

	/**
	 * Start deploy this working copy and create new job.
	 */
	public getAppUpdateStatus(
		workingCopyId: string,
		jobId: string,
		callback: common.ICallback<IDeployJobStatus>,
		errorCallback: common.IErrorCallback
	) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.getAppUpdateStatus(workingCopyId, jobId, callback, errorCallback);
	}

	public getAppEnvironmentStatus(workingCopyId: string, callback: common.ICallback<IEnvironmentStatus>, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.getAppEnvironmentStatus(workingCopyId, callback, errorCallback);
	}

	/**
	 * Retrieves an array of all working copies you are a member of.
	 */
	public getMyWorkingCopies(callback: common.ICallback<IWorkingCopy[]>, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.getMyWorkingCopies(callback, errorCallback);
	}

	/**
	 * Retrieves an array of UUIDs for helper working copies for each supported Mendix version.
	 *
	 * These are pre-defined working copies that are accessible for read operations,
	 * and contain units that might come in handy when creating pages from templates.
	 */
	public getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.getEditorData(callback, errorCallback);
	}

	/**
	 * Retrieves the working copy id that the given project ID maps to.
	 */
	public getWorkingCopyByProject(projectId: string, callback: common.ICallback<string>, errorCallback: common.IErrorCallback) {
		configuration.checkCallbacks(callback, errorCallback);

		this.client.getWorkingCopyByProject(projectId, callback, errorCallback);
	}

	/**
	 * Update the project-to-working copy mapping with the given data.
	 */
	public updateWorkingCopyByProject(
		projectId: string,
		workingCopyId: string,
		callback: common.IVoidCallback,
		errorCallback: common.IErrorCallback
	) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.updateWorkingCopyByProject(projectId, workingCopyId, callback, errorCallback);
	}

	/**
	 * Deletes the project-to-working copy mapping for given project ID.
	 */
	public deleteWorkingCopyByProject(projectId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.deleteWorkingCopyByProject(projectId, callback, errorCallback);
	}

	/**
	 * Lock the working copy (will be locked for the currently authenticated openid)
	 */
	public lockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.lockWorkingCopy(workingCopyId, callback, errorCallback);
	}

	/**
	 * Unlock the working copy (will be unlocked for the currently authenticated openid, will fail if it's locked by another openid)
	 */
	public unlockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback) {
		configuration.assertBackendAccess(this.connectionConfig);
		configuration.checkCallbacks(callback, errorCallback);

		this.client.unlockWorkingCopy(workingCopyId, callback, errorCallback);
	}

}
