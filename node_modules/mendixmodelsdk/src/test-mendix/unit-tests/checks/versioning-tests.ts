

import {lookupByVersion} from "../../../sdk/checks/versioning";
import {Version} from "../../../sdk/internal/version-checks";

import {assert} from "chai";


describe("versioning by range", () => {

	const v = (versionString: string) => Version.parse(versionString);
	function r(from: string, to: string) {
		const range: any = {};
		if (from) {
			range.from = from;
		}
		if (to) {
			range.to = to;
		}
		return { range: range };
	}

	it("should balk at no input", () => {
		[ undefined, null, [] ].forEach(input => {
			assert.throws(() => { lookupByVersion(input, v("6.5.4")); }, "No versioned things provided.");
		});
	});

	it("should look up correctly", () => {
		const versions = [
			r(null, "1.0.0"),
			r("1.0.0", "2.0.0"),
			r("2.0.0", null)
		];
		assert.equal(lookupByVersion(versions, v("0.5.0")), versions[0]);
		assert.equal(lookupByVersion(versions, v("1.0.0")), versions[1]);
		assert.equal(lookupByVersion(versions, v("1.5.0")), versions[1]);
		assert.equal(lookupByVersion(versions, v("2.0.0")), versions[2]);
		assert.equal(lookupByVersion(versions, v("2.0.1")), versions[2]);
	});

	it("should throw on no matches", () => {
		assert.throws(() => { lookupByVersion([ r("1.0.0", "2.0.0") ], v("0.0.1")); }, /No versioned thing/);
		assert.throws(() => { lookupByVersion([ r("1.0.0", "2.0.0") ], v("2.0.1")); }, /No versioned thing/);
	});

	it("should throw on multiple matches", () => {
		assert.throws(() => { lookupByVersion([ r(null, "2.0.0"), r("1.0.0", null) ], v("1.5.0")); }, /More than one valid match/);
		assert.throws(() => { lookupByVersion([ r(null, null), r("1.0.0", "2.0.0") ], v("1.5.0")); }, /More than one valid match/);
		assert.throws(() => { lookupByVersion([ r("1.0.0", "2.0.0"), r("1.4.0", null) ], v("1.5.0")); }, /More than one valid match/);
	});

});
