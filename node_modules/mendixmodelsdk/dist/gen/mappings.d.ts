import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import { projects } from "./projects";
export declare namespace mappings {
    class ElementType extends internal.IEnum {
        static Undefined: ElementType;
        static Inheritance: ElementType;
        static Choice: ElementType;
        static Object: ElementType;
        static Value: ElementType;
        static Sequence: ElementType;
        static All: ElementType;
        static NamedArray: ElementType;
        static Array: ElementType;
        static Wrapper: ElementType;
        protected qualifiedTsTypeName: string;
    }
    class ObjectHandlingBackupEnum extends internal.IEnum {
        static Create: ObjectHandlingBackupEnum;
        static Ignore: ObjectHandlingBackupEnum;
        static Error: ObjectHandlingBackupEnum;
        protected qualifiedTsTypeName: string;
    }
    class ObjectHandlingEnum extends internal.IEnum {
        static Create: ObjectHandlingEnum;
        static Find: ObjectHandlingEnum;
        static Custom: ObjectHandlingEnum;
        protected qualifiedTsTypeName: string;
    }
    /**
     * Interfaces and instance classes for types from the Mendix sub meta model `Mappings`.
     */
    /**
     * In version 6.6.0: introduced
     */
    interface IElement extends internal.IElement {
        model: IModel;
        containerAsJsonStructure: jsonstructures.IJsonStructure;
        containerAsElement: IElement;
        load(): Element;
        load(callback: (element: Element) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

     *
     * In version 6.6.0: introduced
     */
    abstract class Element extends internal.Element implements IElement {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJsonStructure: jsonstructures.JsonStructure;
        readonly containerAsElement: Element;

        elementType: ElementType;

        primitiveType: xmlschemas.XmlPrimitiveType;

        /**
         * The value of this property is conceptually of type mappings.ElementPath.
         */
        path: string;

        isDefaultType: boolean;

        minOccurs: number;

        maxOccurs: number;

        nillable: boolean;

        exposedName: string;

        maxLength: number;

        fractionDigits: number;

        totalDigits: number;

        errorMessage: string;

        warningMessage: string;

        children: internal.IList<Element>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/mapping-documents relevant section in reference guide}
     */
    interface IMappingDocument extends projects.IDocument {
        model: IModel;
        containerAsFolderBase: projects.IFolderBase;
        load(): MappingDocument;
        load(callback: (element: MappingDocument) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/mapping-documents relevant section in reference guide}
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MappingDocument extends projects.Document implements IMappingDocument {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsFolderBase: projects.FolderBase;

        rootMappingElements: internal.IList<ObjectMappingElement>;

        xmlSchema: xmlschemas.IXmlSchema;
        readonly xmlSchemaQualifiedName: string;

        /**
         * In version 6.4.0: introduced
         */
        jsonStructure: jsonstructures.IJsonStructure;
        readonly jsonStructureQualifiedName: string;

        rootElementName: string;

        importedWebService: webservices.IImportedWebService;
        readonly importedWebServiceQualifiedName: string;

        serviceName: string;

        operationName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase);

    }
    interface IMappingElement extends internal.IElement {
        model: IModel;
        containerAsMappingDocument: IMappingDocument;
        containerAsObjectMappingElement: IObjectMappingElement;
        load(): MappingElement;
        load(callback: (element: MappingElement) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MappingElement extends internal.Element implements IMappingElement {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMappingDocument: MappingDocument;
        readonly containerAsObjectMappingElement: ObjectMappingElement;

        documentation: string;

        elementType: ElementType;

        /**
         * The value of this property is conceptually of type mappings.ElementPath.
         */
        path: string;

        minOccurs: number;

        maxOccurs: number;

        nillable: boolean;

        /**
         * In version 6.6.0: introduced
         */
        exposedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IMappingMicroflowCall extends internal.IElement {
        model: IModel;
        containerAsObjectMappingElement: IObjectMappingElement;
        load(): MappingMicroflowCall;
        load(callback: (element: MappingMicroflowCall) => void, forceRefresh?: boolean): any;
    }
    class MappingMicroflowCall extends internal.Element implements IMappingMicroflowCall {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsObjectMappingElement: ObjectMappingElement;

        microflow: microflows.IMicroflow;
        readonly microflowQualifiedName: string;

        parameterMappings: internal.IList<MappingMicroflowParameter>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MappingMicroflowCall instance in the SDK and on the server.
         * The new MappingMicroflowCall will be automatically stored in the 'mappingMicroflowCall' property
         * of the parent ObjectMappingElement element passed as argument.
         */
        static createIn(container: ObjectMappingElement): MappingMicroflowCall;
        /**
         * Creates and returns a new MappingMicroflowCall instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MappingMicroflowCall;

    }
    interface IMappingMicroflowParameter extends internal.IElement {
        model: IModel;
        containerAsMappingMicroflowCall: IMappingMicroflowCall;
        load(): MappingMicroflowParameter;
        load(callback: (element: MappingMicroflowParameter) => void, forceRefresh?: boolean): any;
    }
    class MappingMicroflowParameter extends internal.Element implements IMappingMicroflowParameter {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMappingMicroflowCall: MappingMicroflowCall;

        parameter: microflows.IMicroflowParameter;
        readonly parameterQualifiedName: string;

        levelOfParent: number;

        /**
         * The value of this property is conceptually of type mappings.ElementPath.
         */
        valueElementPath: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MappingMicroflowParameter instance in the SDK and on the server.
         * The new MappingMicroflowParameter will be automatically stored in the 'parameterMappings' property
         * of the parent MappingMicroflowCall element passed as argument.
         */
        static createIn(container: MappingMicroflowCall): MappingMicroflowParameter;
        /**
         * Creates and returns a new MappingMicroflowParameter instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MappingMicroflowParameter;

    }
    interface IObjectMappingElement extends IMappingElement {
        model: IModel;
        containerAsMappingDocument: IMappingDocument;
        containerAsObjectMappingElement: IObjectMappingElement;
        load(): ObjectMappingElement;
        load(callback: (element: ObjectMappingElement) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class ObjectMappingElement extends MappingElement implements IObjectMappingElement {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMappingDocument: MappingDocument;
        readonly containerAsObjectMappingElement: ObjectMappingElement;

        mappingMicroflowCall: MappingMicroflowCall;

        children: internal.IList<MappingElement>;

        entity: domainmodels.IEntity;
        readonly entityQualifiedName: string;

        association: domainmodels.IAssociationBase;
        readonly associationQualifiedName: string;

        objectHandling: ObjectHandlingEnum;

        objectHandlingBackup: ObjectHandlingBackupEnum;

        /**
         * In version 6.4.0: introduced
         */
        isDefaultType: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IValueMappingElement extends IMappingElement {
        model: IModel;
        containerAsObjectMappingElement: IObjectMappingElement;
        load(): ValueMappingElement;
        load(callback: (element: ValueMappingElement) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class ValueMappingElement extends MappingElement implements IValueMappingElement {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsObjectMappingElement: ObjectMappingElement;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        xmlDataType: string;

        isKey: boolean;

        isXmlAttribute: boolean;

        /**
         * In version 6.1.0: introduced
         */
        xmlPrimitiveType: xmlschemas.XmlPrimitiveType;

        isContent: boolean;

        attribute: domainmodels.IAttribute;
        readonly attributeQualifiedName: string;

        converter: microflows.IMicroflow;
        readonly converterQualifiedName: string;

        /**
         * In version 6.4.1: deleted
         */
        expectedContentTypes: string;

        maxLength: number;

        fractionDigits: number;

        totalDigits: number;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
}
import { domainmodels } from "./domainmodels";
import { jsonstructures } from "./jsonstructures";
import { microflows } from "./microflows";
import { webservices } from "./webservices";
import { xmlschemas } from "./xmlschemas";
import { IModel } from "./base-model";
