import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import { common } from "../common";
import { projects } from "./projects";
export declare namespace domainmodels {
    class ActionMoment extends internal.IEnum {
        static Before: ActionMoment;
        static After: ActionMoment;
        protected qualifiedTsTypeName: string;
    }
    class AssociationOwner extends internal.IEnum {
        static Default: AssociationOwner;
        static Both: AssociationOwner;
        protected qualifiedTsTypeName: string;
    }
    class AssociationType extends internal.IEnum {
        static Reference: AssociationType;
        static ReferenceSet: AssociationType;
        protected qualifiedTsTypeName: string;
    }
    class DeletingBehavior extends internal.IEnum {
        static DeleteMeAndReferences: DeletingBehavior;
        static DeleteMeButKeepReferences: DeletingBehavior;
        static DeleteMeIfNoReferences: DeletingBehavior;
        protected qualifiedTsTypeName: string;
    }
    class EventType extends internal.IEnum {
        static Create: EventType;
        static Commit: EventType;
        static Delete: EventType;
        static RollBack: EventType;
        protected qualifiedTsTypeName: string;
    }
    class IndexedAttributeType extends internal.IEnum {
        static Normal: IndexedAttributeType;
        static CreatedDate: IndexedAttributeType;
        static ChangedDate: IndexedAttributeType;
        protected qualifiedTsTypeName: string;
    }
    class MemberAccessRights extends internal.IEnum {
        static None: MemberAccessRights;
        static ReadOnly: MemberAccessRights;
        static ReadWrite: MemberAccessRights;
        protected qualifiedTsTypeName: string;
    }
    class RangeType extends internal.IEnum {
        static GreaterThanOrEqualTo: RangeType;
        static SmallerThanOrEqualTo: RangeType;
        static Between: RangeType;
        protected qualifiedTsTypeName: string;
    }
    /**
     * Interfaces and instance classes for types from the Mendix sub meta model `DomainModels`.
     */
    /**
     * See: {@link https://docs.mendix.com/refguide7/access-rules relevant section in reference guide}
     */
    interface IAccessRule extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        containerAsAccessRuleContainerBase: security.IAccessRuleContainerBase;
        load(): AccessRule;
        load(callback: (element: AccessRule) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/access-rules relevant section in reference guide}
     */
    class AccessRule extends internal.Element implements IAccessRule {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;
        readonly containerAsAccessRuleContainerBase: security.AccessRuleContainerBase;

        memberAccesses: internal.IList<MemberAccess>;

        moduleRoles: internal.IList<security.IModuleRole>;
        readonly moduleRolesQualifiedNames: string[];

        documentation: string;

        allowCreate: boolean;

        allowDelete: boolean;

        defaultMemberAccessRights: MemberAccessRights;

        /**
         * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
         */
        xPathConstraint: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * The new AccessRule will be automatically stored in the 'accessRules' property
         * of the parent Entity element passed as argument.
         */
        static createInEntityUnderAccessRules(container: Entity): AccessRule;
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * The new AccessRule will be automatically stored in the 'accessRules' property
         * of the parent security.AccessRuleContainerBase element passed as argument.
         */
        static createInAccessRuleContainerBaseUnderAccessRules(container: security.AccessRuleContainerBase): AccessRule;
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AccessRule;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotations relevant section in reference guide}
     */
    interface IAnnotation extends internal.IElement {
        model: IModel;
        containerAsDomainModel: IDomainModel;
        load(): Annotation;
        load(callback: (element: Annotation) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotations relevant section in reference guide}
     */
    class Annotation extends internal.Element implements IAnnotation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDomainModel: DomainModel;

        caption: string;

        location: common.IPoint;

        width: number;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * The new Annotation will be automatically stored in the 'annotations' property
         * of the parent DomainModel element passed as argument.
         */
        static createIn(container: DomainModel): Annotation;
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Annotation;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations TODO: This is whre it belongs, but the word AssociationBase is never used}
     */
    interface IAssociationBase extends internal.IElement {
        model: IModel;
        containerAsDomainModel: IDomainModel;
        name: string;
        type: AssociationType;
        owner: AssociationOwner;
        /**
         * This property is required and cannot be set to null.
         */
        parent: IEntity;
        load(): AssociationBase;
        load(callback: (element: AssociationBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations TODO: This is whre it belongs, but the word AssociationBase is never used}
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class AssociationBase extends internal.Element implements IAssociationBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDomainModel: DomainModel;

        name: string;

        dataStorageGuid: string;

        type: AssociationType;

        owner: AssociationOwner;

        deleteBehavior: AssociationDeleteBehavior;

        parent: Entity;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);


    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations relevant section in reference guide}
     */
    interface IAssociation extends IAssociationBase {
        model: IModel;
        containerAsDomainModel: IDomainModel;
        /**
         * This property is required and cannot be set to null.
         */
        child: IEntity;
        load(): Association;
        load(callback: (element: Association) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations relevant section in reference guide}
     */
    class Association extends AssociationBase implements IAssociation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDomainModel: DomainModel;

        child: Entity;

        parentConnection: common.IPoint;

        childConnection: common.IPoint;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Association instance in the SDK and on the server.
         * The new Association will be automatically stored in the 'associations' property
         * of the parent DomainModel element passed as argument.
         */
        static createIn(container: DomainModel): Association;
        /**
         * Creates and returns a new Association instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Association;

    }
    interface IAssociationDeleteBehavior extends internal.IElement {
        model: IModel;
        containerAsAssociationBase: IAssociationBase;
        load(): AssociationDeleteBehavior;
        load(callback: (element: AssociationDeleteBehavior) => void, forceRefresh?: boolean): any;
    }
    class AssociationDeleteBehavior extends internal.Element implements IAssociationDeleteBehavior {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAssociationBase: AssociationBase;

        parentDeleteBehavior: DeletingBehavior;

        childDeleteBehavior: DeletingBehavior;

        parentErrorMessage: texts.Text;

        childErrorMessage: texts.Text;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
         * The new AssociationDeleteBehavior will be automatically stored in the 'deleteBehavior' property
         * of the parent AssociationBase element passed as argument.
         */
        static createIn(container: AssociationBase): AssociationDeleteBehavior;
        /**
         * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AssociationDeleteBehavior;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/attributes relevant section in reference guide}
     */
    interface IAttribute extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        name: string;
        /**
         * This property is required and cannot be set to null.
         */
        type: IAttributeType;
        /**
         * This property is required and cannot be set to null.
         *
         * In version 6.6.0: added public
         */
        value: IValueType;
        load(): Attribute;
        load(callback: (element: Attribute) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/attributes relevant section in reference guide}
     */
    class Attribute extends internal.Element implements IAttribute {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        name: string;

        dataStorageGuid: string;

        type: AttributeType;

        documentation: string;

        /**
         * In version 6.6.0: added public
         */
        value: ValueType;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * The new Attribute will be automatically stored in the 'attributes' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): Attribute;
        /**
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Attribute;


    }
    interface IAttributeType extends internal.IElement {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): AttributeType;
        load(callback: (element: AttributeType) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class AttributeType extends internal.Element implements IAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface INumericAttributeTypeBase extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): NumericAttributeTypeBase;
        load(callback: (element: NumericAttributeTypeBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class NumericAttributeTypeBase extends AttributeType implements INumericAttributeTypeBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IIntegerAttributeTypeBase extends INumericAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): IntegerAttributeTypeBase;
        load(callback: (element: IntegerAttributeTypeBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class IntegerAttributeTypeBase extends NumericAttributeTypeBase implements IIntegerAttributeTypeBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IAutoNumberAttributeType extends IIntegerAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): AutoNumberAttributeType;
        load(callback: (element: AutoNumberAttributeType) => void, forceRefresh?: boolean): any;
    }
    class AutoNumberAttributeType extends IntegerAttributeTypeBase implements IAutoNumberAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * The new AutoNumberAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): AutoNumberAttributeType;
        /**
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AutoNumberAttributeType;

    }
    interface IBinaryAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): BinaryAttributeType;
        load(callback: (element: BinaryAttributeType) => void, forceRefresh?: boolean): any;
    }
    class BinaryAttributeType extends AttributeType implements IBinaryAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * The new BinaryAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): BinaryAttributeType;
        /**
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): BinaryAttributeType;

    }
    interface IBooleanAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): BooleanAttributeType;
        load(callback: (element: BooleanAttributeType) => void, forceRefresh?: boolean): any;
    }
    class BooleanAttributeType extends AttributeType implements IBooleanAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * The new BooleanAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): BooleanAttributeType;
        /**
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): BooleanAttributeType;

    }
    /**
     * In version 6.6.0: added public
     */
    interface IValueType extends internal.IElement {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): ValueType;
        load(callback: (element: ValueType) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

     *
     * In version 6.6.0: added public
     */
    abstract class ValueType extends internal.Element implements IValueType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * In version 6.6.0: added public
     */
    interface ICalculatedValue extends IValueType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): CalculatedValue;
        load(callback: (element: CalculatedValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.6.0: added public
     */
    class CalculatedValue extends ValueType implements ICalculatedValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;

        microflow: microflows.IMicroflow;
        readonly microflowQualifiedName: string;

        passEntity: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CalculatedValue instance in the SDK and on the server.
         * The new CalculatedValue will be automatically stored in the 'value' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): CalculatedValue;
        /**
         * Creates and returns a new CalculatedValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CalculatedValue;

    }
    interface ICrossAssociation extends IAssociationBase {
        model: IModel;
        containerAsDomainModel: IDomainModel;
        /**
         * This property is required and cannot be set to null.
         */
        child: IEntity;
        childQualifiedName: string;
        load(): CrossAssociation;
        load(callback: (element: CrossAssociation) => void, forceRefresh?: boolean): any;
    }
    class CrossAssociation extends AssociationBase implements ICrossAssociation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDomainModel: DomainModel;

        child: IEntity;
        readonly childQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CrossAssociation instance in the SDK and on the server.
         * The new CrossAssociation will be automatically stored in the 'crossAssociations' property
         * of the parent DomainModel element passed as argument.
         */
        static createIn(container: DomainModel): CrossAssociation;
        /**
         * Creates and returns a new CrossAssociation instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CrossAssociation;

    }
    interface IDecimalAttributeTypeBase extends INumericAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): DecimalAttributeTypeBase;
        load(callback: (element: DecimalAttributeTypeBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class DecimalAttributeTypeBase extends NumericAttributeTypeBase implements IDecimalAttributeTypeBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IFloatAttributeTypeBase extends IDecimalAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): FloatAttributeTypeBase;
        load(callback: (element: FloatAttributeTypeBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class FloatAttributeTypeBase extends DecimalAttributeTypeBase implements IFloatAttributeTypeBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * In version 6.0.0: deprecated
     */
    interface ICurrencyAttributeType extends IFloatAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): CurrencyAttributeType;
        load(callback: (element: CurrencyAttributeType) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.0.0: deprecated
     */
    class CurrencyAttributeType extends FloatAttributeTypeBase implements ICurrencyAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * The new CurrencyAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): CurrencyAttributeType;
        /**
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CurrencyAttributeType;

    }
    interface IDateTimeAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): DateTimeAttributeType;
        load(callback: (element: DateTimeAttributeType) => void, forceRefresh?: boolean): any;
    }
    class DateTimeAttributeType extends AttributeType implements IDateTimeAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;

        localizeDate: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * The new DateTimeAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): DateTimeAttributeType;
        /**
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DateTimeAttributeType;

    }
    interface IDecimalAttributeType extends IDecimalAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): DecimalAttributeType;
        load(callback: (element: DecimalAttributeType) => void, forceRefresh?: boolean): any;
    }
    class DecimalAttributeType extends DecimalAttributeTypeBase implements IDecimalAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * The new DecimalAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): DecimalAttributeType;
        /**
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DecimalAttributeType;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/domain-model relevant section in reference guide}
     */
    interface IDomainModel extends projects.IModuleDocument {
        model: IModel;
        containerAsModule: projects.IModule;
        entities: internal.IList<IEntity>;
        associations: internal.IList<IAssociation>;
        crossAssociations: internal.IList<ICrossAssociation>;
        load(): DomainModel;
        load(callback: (element: DomainModel) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/domain-model relevant section in reference guide}
     */
    class DomainModel extends projects.ModuleDocument implements IDomainModel {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsModule: projects.Module;

        documentation: string;

        entities: internal.IList<Entity>;

        annotations: internal.IList<Annotation>;

        associations: internal.IList<Association>;

        crossAssociations: internal.IList<CrossAssociation>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IModule);
        /**
         * Creates a new DomainModel unit in the SDK and on the server.
         * Expects one argument, the projects.IModule in which this unit is contained.
         */
        static createIn(container: projects.IModule): DomainModel;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/entities relevant section in reference guide}
     */
    interface IEntity extends internal.IElement {
        model: IModel;
        containerAsDomainModel: IDomainModel;
        name: string;
        /**
         * This property is required and cannot be set to null.
         */
        generalization: IGeneralizationBase;
        attributes: internal.IList<IAttribute>;
        load(): Entity;
        load(callback: (element: Entity) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/entities relevant section in reference guide}
     */
    class Entity extends internal.Element implements IEntity {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDomainModel: DomainModel;

        name: string;

        dataStorageGuid: string;

        location: common.IPoint;

        documentation: string;

        generalization: GeneralizationBase;

        attributes: internal.IList<Attribute>;

        validationRules: internal.IList<ValidationRule>;

        eventHandlers: internal.IList<EventHandler>;

        indexes: internal.IList<Index>;

        accessRules: internal.IList<AccessRule>;

        image: images.IImage;
        readonly imageQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Entity instance in the SDK and on the server.
         * The new Entity will be automatically stored in the 'entities' property
         * of the parent DomainModel element passed as argument.
         */
        static createIn(container: DomainModel): Entity;
        /**
         * Creates and returns a new Entity instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Entity;


    }
    interface IEnumerationAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        /**
         * This property is required and cannot be set to null.
         */
        enumeration: enumerations.IEnumeration;
        enumerationQualifiedName: string;
        load(): EnumerationAttributeType;
        load(callback: (element: EnumerationAttributeType) => void, forceRefresh?: boolean): any;
    }
    class EnumerationAttributeType extends AttributeType implements IEnumerationAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;

        enumeration: enumerations.IEnumeration;
        readonly enumerationQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
         * The new EnumerationAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): EnumerationAttributeType;
        /**
         * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EnumerationAttributeType;

    }
    interface IRuleInfo extends internal.IElement {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): RuleInfo;
        load(callback: (element: RuleInfo) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class RuleInfo extends internal.Element implements IRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IEqualsToRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): EqualsToRuleInfo;
        load(callback: (element: EqualsToRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class EqualsToRuleInfo extends RuleInfo implements IEqualsToRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;

        useValue: boolean;

        equalsToValue: string;

        equalsToAttribute: IAttribute;
        readonly equalsToAttributeQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
         * The new EqualsToRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): EqualsToRuleInfo;
        /**
         * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EqualsToRuleInfo;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/event-handlers relevant section in reference guide}
     */
    interface IEventHandler extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        load(): EventHandler;
        load(callback: (element: EventHandler) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/event-handlers relevant section in reference guide}
     */
    class EventHandler extends internal.Element implements IEventHandler {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        moment: ActionMoment;

        event: EventType;

        microflow: microflows.IMicroflow;
        readonly microflowQualifiedName: string;

        raiseErrorOnFalse: boolean;

        passEventObject: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EventHandler instance in the SDK and on the server.
         * The new EventHandler will be automatically stored in the 'eventHandlers' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): EventHandler;
        /**
         * Creates and returns a new EventHandler instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EventHandler;

    }
    /**
     * In version 6.0.0: deprecated
     */
    interface IFloatAttributeType extends IFloatAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): FloatAttributeType;
        load(callback: (element: FloatAttributeType) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.0.0: deprecated
     */
    class FloatAttributeType extends FloatAttributeTypeBase implements IFloatAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * The new FloatAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): FloatAttributeType;
        /**
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): FloatAttributeType;

    }
    interface IGeneralizationBase extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        load(): GeneralizationBase;
        load(callback: (element: GeneralizationBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class GeneralizationBase extends internal.Element implements IGeneralizationBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IGeneralization extends IGeneralizationBase {
        model: IModel;
        containerAsEntity: IEntity;
        /**
         * This property is required and cannot be set to null.
         */
        generalization: IEntity;
        generalizationQualifiedName: string;
        load(): Generalization;
        load(callback: (element: Generalization) => void, forceRefresh?: boolean): any;
    }
    class Generalization extends GeneralizationBase implements IGeneralization {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        generalization: IEntity;
        readonly generalizationQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Generalization instance in the SDK and on the server.
         * The new Generalization will be automatically stored in the 'generalization' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): Generalization;
        /**
         * Creates and returns a new Generalization instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Generalization;

    }
    interface IHashedStringAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): HashedStringAttributeType;
        load(callback: (element: HashedStringAttributeType) => void, forceRefresh?: boolean): any;
    }
    class HashedStringAttributeType extends AttributeType implements IHashedStringAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * The new HashedStringAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): HashedStringAttributeType;
        /**
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): HashedStringAttributeType;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/indexes relevant section in reference guide}
     */
    interface IIndex extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        load(): Index;
        load(callback: (element: Index) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/indexes relevant section in reference guide}
     */
    class Index extends internal.Element implements IIndex {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        dataStorageGuid: string;

        attributes: internal.IList<IndexedAttribute>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Index instance in the SDK and on the server.
         * The new Index will be automatically stored in the 'indexes' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): Index;
        /**
         * Creates and returns a new Index instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Index;

    }
    interface IIndexedAttribute extends internal.IElement {
        model: IModel;
        containerAsIndex: IIndex;
        load(): IndexedAttribute;
        load(callback: (element: IndexedAttribute) => void, forceRefresh?: boolean): any;
    }
    class IndexedAttribute extends internal.Element implements IIndexedAttribute {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsIndex: Index;

        type: IndexedAttributeType;

        attribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
         * The new IndexedAttribute will be automatically stored in the 'attributes' property
         * of the parent Index element passed as argument.
         */
        static createIn(container: Index): IndexedAttribute;
        /**
         * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): IndexedAttribute;

    }
    interface IIntegerAttributeType extends IIntegerAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): IntegerAttributeType;
        load(callback: (element: IntegerAttributeType) => void, forceRefresh?: boolean): any;
    }
    class IntegerAttributeType extends IntegerAttributeTypeBase implements IIntegerAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * The new IntegerAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): IntegerAttributeType;
        /**
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): IntegerAttributeType;

    }
    interface ILongAttributeType extends IIntegerAttributeTypeBase {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): LongAttributeType;
        load(callback: (element: LongAttributeType) => void, forceRefresh?: boolean): any;
    }
    class LongAttributeType extends IntegerAttributeTypeBase implements ILongAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * The new LongAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): LongAttributeType;
        /**
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): LongAttributeType;

    }
    interface IMaxLengthRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): MaxLengthRuleInfo;
        load(callback: (element: MaxLengthRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class MaxLengthRuleInfo extends RuleInfo implements IMaxLengthRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;

        maxLength: number;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
         * The new MaxLengthRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): MaxLengthRuleInfo;
        /**
         * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MaxLengthRuleInfo;

    }
    interface IMemberAccess extends internal.IElement {
        model: IModel;
        containerAsAccessRule: IAccessRule;
        load(): MemberAccess;
        load(callback: (element: MemberAccess) => void, forceRefresh?: boolean): any;
    }
    class MemberAccess extends internal.Element implements IMemberAccess {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAccessRule: AccessRule;

        attribute: IAttribute;
        readonly attributeQualifiedName: string;

        association: IAssociationBase;
        readonly associationQualifiedName: string;

        accessRights: MemberAccessRights;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MemberAccess instance in the SDK and on the server.
         * The new MemberAccess will be automatically stored in the 'memberAccesses' property
         * of the parent AccessRule element passed as argument.
         */
        static createIn(container: AccessRule): MemberAccess;
        /**
         * Creates and returns a new MemberAccess instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MemberAccess;

    }
    interface INoGeneralization extends IGeneralizationBase {
        model: IModel;
        containerAsEntity: IEntity;
        persistable: boolean;
        load(): NoGeneralization;
        load(callback: (element: NoGeneralization) => void, forceRefresh?: boolean): any;
    }
    class NoGeneralization extends GeneralizationBase implements INoGeneralization {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        hasChangedDate: boolean;

        hasCreatedDate: boolean;

        hasOwner: boolean;

        hasChangedBy: boolean;

        persistable: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new NoGeneralization instance in the SDK and on the server.
         * The new NoGeneralization will be automatically stored in the 'generalization' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): NoGeneralization;
        /**
         * Creates and returns a new NoGeneralization instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): NoGeneralization;

    }
    interface IRangeRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): RangeRuleInfo;
        load(callback: (element: RangeRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class RangeRuleInfo extends RuleInfo implements IRangeRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;

        typeOfRange: RangeType;

        useMinValue: boolean;

        useMaxValue: boolean;

        minValue: string;

        maxValue: string;

        minAttribute: IAttribute;
        readonly minAttributeQualifiedName: string;

        maxAttribute: IAttribute;
        readonly maxAttributeQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
         * The new RangeRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): RangeRuleInfo;
        /**
         * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RangeRuleInfo;

    }
    interface IRegExRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): RegExRuleInfo;
        load(callback: (element: RegExRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class RegExRuleInfo extends RuleInfo implements IRegExRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;

        regularExpression: regularexpressions.IRegularExpression;
        readonly regularExpressionQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
         * The new RegExRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): RegExRuleInfo;
        /**
         * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RegExRuleInfo;

    }
    interface IRequiredRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): RequiredRuleInfo;
        load(callback: (element: RequiredRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class RequiredRuleInfo extends RuleInfo implements IRequiredRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
         * The new RequiredRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): RequiredRuleInfo;
        /**
         * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RequiredRuleInfo;

    }
    /**
     * In version 6.6.0: added public
     */
    interface IStoredValue extends IValueType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): StoredValue;
        load(callback: (element: StoredValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.6.0: added public
     */
    class StoredValue extends ValueType implements IStoredValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;

        defaultValue: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new StoredValue instance in the SDK and on the server.
         * The new StoredValue will be automatically stored in the 'value' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): StoredValue;
        /**
         * Creates and returns a new StoredValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): StoredValue;

    }
    interface IStringAttributeType extends IAttributeType {
        model: IModel;
        containerAsAttribute: IAttribute;
        load(): StringAttributeType;
        load(callback: (element: StringAttributeType) => void, forceRefresh?: boolean): any;
    }
    class StringAttributeType extends AttributeType implements IStringAttributeType {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAttribute: Attribute;

        length: number;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * The new StringAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        static createIn(container: Attribute): StringAttributeType;
        /**
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): StringAttributeType;

    }
    interface IUniqueRuleInfo extends IRuleInfo {
        model: IModel;
        containerAsValidationRule: IValidationRule;
        load(): UniqueRuleInfo;
        load(callback: (element: UniqueRuleInfo) => void, forceRefresh?: boolean): any;
    }
    class UniqueRuleInfo extends RuleInfo implements IUniqueRuleInfo {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsValidationRule: ValidationRule;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
         * The new UniqueRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        static createIn(container: ValidationRule): UniqueRuleInfo;
        /**
         * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): UniqueRuleInfo;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/validation-rules relevant section in reference guide}
     */
    interface IValidationRule extends internal.IElement {
        model: IModel;
        containerAsEntity: IEntity;
        load(): ValidationRule;
        load(callback: (element: ValidationRule) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/validation-rules relevant section in reference guide}
     */
    class ValidationRule extends internal.Element implements IValidationRule {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsEntity: Entity;

        attribute: IAttribute;
        readonly attributeQualifiedName: string;

        errorMessage: texts.Text;

        ruleInfo: RuleInfo;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ValidationRule instance in the SDK and on the server.
         * The new ValidationRule will be automatically stored in the 'validationRules' property
         * of the parent Entity element passed as argument.
         */
        static createIn(container: Entity): ValidationRule;
        /**
         * Creates and returns a new ValidationRule instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ValidationRule;

    }
}
import { enumerations } from "./enumerations";
import { images } from "./images";
import { microflows } from "./microflows";
import { regularexpressions } from "./regularexpressions";
import { security } from "./security";
import { texts } from "./texts";
import { IModel } from "./base-model";
