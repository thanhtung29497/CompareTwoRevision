import * as internal from "../sdk/internal";
export import StructureVersionInfo = internal.StructureVersionInfo;
import { common } from "../common";
import { projects } from "./projects";
export declare namespace microflows {
    class ActionActivityColor extends internal.IEnum {
        static Default: ActionActivityColor;
        static Red: ActionActivityColor;
        static Orange: ActionActivityColor;
        static Yellow: ActionActivityColor;
        static Green: ActionActivityColor;
        static Blue: ActionActivityColor;
        static Purple: ActionActivityColor;
        static Gray: ActionActivityColor;
        protected qualifiedTsTypeName: string;
    }
    class AggregateFunctionEnum extends internal.IEnum {
        static Sum: AggregateFunctionEnum;
        static Average: AggregateFunctionEnum;
        static Count: AggregateFunctionEnum;
        static Minimum: AggregateFunctionEnum;
        static Maximum: AggregateFunctionEnum;
        protected qualifiedTsTypeName: string;
    }
    class ChangeActionItemType extends internal.IEnum {
        static Set: ChangeActionItemType;
        static Add: ChangeActionItemType;
        static Remove: ChangeActionItemType;
        protected qualifiedTsTypeName: string;
    }
    class ChangeListActionType extends internal.IEnum {
        static Set: ChangeListActionType;
        static Add: ChangeListActionType;
        static Remove: ChangeListActionType;
        static Clear: ChangeListActionType;
        protected qualifiedTsTypeName: string;
    }
    class CommitEnum extends internal.IEnum {
        static Yes: CommitEnum;
        static YesWithoutEvents: CommitEnum;
        static No: CommitEnum;
        protected qualifiedTsTypeName: string;
    }
    class ErrorHandlingType extends internal.IEnum {
        static Rollback: ErrorHandlingType;
        static Custom: ErrorHandlingType;
        static CustomWithoutRollBack: ErrorHandlingType;
        static Continue: ErrorHandlingType;
        protected qualifiedTsTypeName: string;
    }
    class HttpMethod extends internal.IEnum {
        static Post: HttpMethod;
        static Get: HttpMethod;
        static Put: HttpMethod;
        static Patch: HttpMethod;
        static Delete: HttpMethod;
        protected qualifiedTsTypeName: string;
    }
    class LanguageSettingType extends internal.IEnum {
        static CurrentUser: LanguageSettingType;
        static ProjectDefault: LanguageSettingType;
        static Variable: LanguageSettingType;
        protected qualifiedTsTypeName: string;
    }
    class LogLevel extends internal.IEnum {
        static Trace: LogLevel;
        static Debug: LogLevel;
        static Info: LogLevel;
        static Warning: LogLevel;
        static Error: LogLevel;
        static Critical: LogLevel;
        protected qualifiedTsTypeName: string;
    }
    class NullValueOption extends internal.IEnum {
        static SendAsNil: NullValueOption;
        static LeaveOutElement: NullValueOption;
        protected qualifiedTsTypeName: string;
    }
    class RequestHandlingType extends internal.IEnum {
        static Mapping: RequestHandlingType;
        static Simple: RequestHandlingType;
        static Advanced: RequestHandlingType;
        static Binary: RequestHandlingType;
        static Custom: RequestHandlingType;
        protected qualifiedTsTypeName: string;
    }
    class ResultHandlingType extends internal.IEnum {
        static Mapping: ResultHandlingType;
        static String: ResultHandlingType;
        static FileDocument: ResultHandlingType;
        static None: ResultHandlingType;
        protected qualifiedTsTypeName: string;
    }
    class ShowMessageType extends internal.IEnum {
        static Information: ShowMessageType;
        static Warning: ShowMessageType;
        static Error: ShowMessageType;
        protected qualifiedTsTypeName: string;
    }
    class SortOrderEnum extends internal.IEnum {
        static Ascending: SortOrderEnum;
        static Descending: SortOrderEnum;
        protected qualifiedTsTypeName: string;
    }
    class TargetDocumentType extends internal.IEnum {
        static HTML: TargetDocumentType;
        static PDF: TargetDocumentType;
        static DOCX: TargetDocumentType;
        static DOC: TargetDocumentType;
        static RTF: TargetDocumentType;
        static ODT: TargetDocumentType;
        protected qualifiedTsTypeName: string;
    }
    /**
     * Interfaces and instance classes for types from the Mendix sub meta model `Microflows`.
     */
    /**
     * TODO: Abstract
     */
    interface IMicroflowObject extends internal.IElement {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): MicroflowObject;
        load(callback: (element: MicroflowObject) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: Abstract
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MicroflowObject extends internal.Element implements IMicroflowObject {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        relativeMiddlePoint: common.IPoint;

        size: common.ISize;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO: abstract element
     */
    interface IActivity extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): Activity;
        load(callback: (element: Activity) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: abstract element
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class Activity extends MicroflowObject implements IActivity {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/activities relevant section in reference guide}
     */
    interface IActionActivity extends IActivity {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): ActionActivity;
        load(callback: (element: ActionActivity) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/activities relevant section in reference guide}
     */
    class ActionActivity extends Activity implements IActionActivity {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        action: MicroflowAction;

        caption: string;

        autoGenerateCaption: boolean;

        backgroundColor: ActionActivityColor;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ActionActivity instance in the SDK and on the server.
         * The new ActionActivity will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): ActionActivity;
        /**
         * Creates and returns a new ActionActivity instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ActionActivity;

    }
    /**
     * TODO
     */
    interface IRequestHandling extends internal.IElement {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): RequestHandling;
        load(callback: (element: RequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class RequestHandling extends internal.Element implements IRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO
     */
    interface IAdvancedRequestHandling extends IRequestHandling {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): AdvancedRequestHandling;
        load(callback: (element: AdvancedRequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class AdvancedRequestHandling extends RequestHandling implements IAdvancedRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        parameterMappings: internal.IList<WebServiceOperationAdvancedParameterMapping>;

        /**
         * In version 6.7.0: introduced
         */
        nullValueOption: NullValueOption;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
         * The new AdvancedRequestHandling will be automatically stored in the 'requestHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderRequestHandling(container: RestCallAction): AdvancedRequestHandling;
        /**
         * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
         * The new AdvancedRequestHandling will be automatically stored in the 'requestBodyHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): AdvancedRequestHandling;
        /**
         * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
         * The new AdvancedRequestHandling will be automatically stored in the 'requestHeaderHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): AdvancedRequestHandling;
        /**
         * Creates and returns a new AdvancedRequestHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AdvancedRequestHandling;

    }
    /**
     * TODO
     */
    interface IMicroflowAction extends internal.IElement {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): MicroflowAction;
        load(callback: (element: MicroflowAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MicroflowAction extends internal.Element implements IMicroflowAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        errorHandlingType: ErrorHandlingType;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/aggregate-list relevant section in reference guide}
     */
    interface IAggregateListAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): AggregateListAction;
        load(callback: (element: AggregateListAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/aggregate-list relevant section in reference guide}
     */
    class AggregateListAction extends MicroflowAction implements IAggregateListAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        inputListVariableName: string;

        attribute: domainmodels.IAttribute;
        readonly attributeQualifiedName: string;

        aggregateFunction: AggregateFunctionEnum;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AggregateListAction instance in the SDK and on the server.
         * The new AggregateListAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): AggregateListAction;
        /**
         * Creates and returns a new AggregateListAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AggregateListAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotation relevant section in reference guide}
     */
    interface IAnnotation extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): Annotation;
        load(callback: (element: Annotation) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotation relevant section in reference guide}
     */
    class Annotation extends MicroflowObject implements IAnnotation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        caption: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * The new Annotation will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): Annotation;
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Annotation;

    }
    /**
     * TODO abstract
     */
    interface IFlow extends internal.IElement {
        model: IModel;
        containerAsMicroflowBase: IMicroflowBase;
        load(): Flow;
        load(callback: (element: Flow) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO abstract
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class Flow extends internal.Element implements IFlow {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowBase: MicroflowBase;

        origin: MicroflowObject;

        destination: MicroflowObject;

        originConnectionIndex: number;

        destinationConnectionIndex: number;

        originBezierVector: common.ISize;

        destinationBezierVector: common.ISize;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotation-flow relevant section in reference guide}
     */
    interface IAnnotationFlow extends IFlow {
        model: IModel;
        containerAsMicroflowBase: IMicroflowBase;
        load(): AnnotationFlow;
        load(callback: (element: AnnotationFlow) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotation-flow relevant section in reference guide}
     */
    class AnnotationFlow extends Flow implements IAnnotationFlow {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowBase: MicroflowBase;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AnnotationFlow instance in the SDK and on the server.
         * The new AnnotationFlow will be automatically stored in the 'flows' property
         * of the parent MicroflowBase element passed as argument.
         */
        static createIn(container: MicroflowBase): AnnotationFlow;
        /**
         * Creates and returns a new AnnotationFlow instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AnnotationFlow;

    }
    /**
     * TODO: Missing in ref guide ?
     */
    interface IAppServiceCallAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): AppServiceCallAction;
        load(callback: (element: AppServiceCallAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: Missing in ref guide ?
     */
    class AppServiceCallAction extends MicroflowAction implements IAppServiceCallAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        appServiceAction: appservices.IAppServiceAction;
        readonly appServiceActionQualifiedName: string;

        parameterMappings: internal.IList<AppServiceCallParameterMapping>;

        useVariable: boolean;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AppServiceCallAction instance in the SDK and on the server.
         * The new AppServiceCallAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): AppServiceCallAction;
        /**
         * Creates and returns a new AppServiceCallAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AppServiceCallAction;

    }
    /**
     * TODO: Missing in ref guide ?
     */
    interface IAppServiceCallParameterMapping extends internal.IElement {
        model: IModel;
        containerAsAppServiceCallAction: IAppServiceCallAction;
        load(): AppServiceCallParameterMapping;
        load(callback: (element: AppServiceCallParameterMapping) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: Missing in ref guide ?
     */
    class AppServiceCallParameterMapping extends internal.Element implements IAppServiceCallParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAppServiceCallAction: AppServiceCallAction;

        parameter: appservices.IAppServiceActionParameter;
        readonly parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AppServiceCallParameterMapping instance in the SDK and on the server.
         * The new AppServiceCallParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent AppServiceCallAction element passed as argument.
         */
        static createIn(container: AppServiceCallAction): AppServiceCallParameterMapping;
        /**
         * Creates and returns a new AppServiceCallParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AppServiceCallParameterMapping;

    }
    /**
     * TODO
     */
    interface IRetrieveSource extends internal.IElement {
        model: IModel;
        containerAsRetrieveAction: IRetrieveAction;
        load(): RetrieveSource;
        load(callback: (element: RetrieveSource) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class RetrieveSource extends internal.Element implements IRetrieveSource {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRetrieveAction: RetrieveAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO
     */
    interface IAssociationRetrieveSource extends IRetrieveSource {
        model: IModel;
        containerAsRetrieveAction: IRetrieveAction;
        load(): AssociationRetrieveSource;
        load(callback: (element: AssociationRetrieveSource) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class AssociationRetrieveSource extends RetrieveSource implements IAssociationRetrieveSource {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRetrieveAction: RetrieveAction;

        startVariableName: string;

        association: domainmodels.IAssociationBase;
        readonly associationQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new AssociationRetrieveSource instance in the SDK and on the server.
         * The new AssociationRetrieveSource will be automatically stored in the 'retrieveSource' property
         * of the parent RetrieveAction element passed as argument.
         */
        static createIn(container: RetrieveAction): AssociationRetrieveSource;
        /**
         * Creates and returns a new AssociationRetrieveSource instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): AssociationRetrieveSource;

    }
    /**
     * In version 6.7.0: introduced
     */
    interface IJavaActionParameterValue extends internal.IElement {
        model: IModel;
        containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
        load(): JavaActionParameterValue;
        load(callback: (element: JavaActionParameterValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

     *
     * In version 6.7.0: introduced
     */
    abstract class JavaActionParameterValue extends internal.Element implements IJavaActionParameterValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJavaActionParameterMapping: JavaActionParameterMapping;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * In version 6.7.0: introduced
     */
    interface IBasicJavaActionParameterValue extends IJavaActionParameterValue {
        model: IModel;
        containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
        load(): BasicJavaActionParameterValue;
        load(callback: (element: BasicJavaActionParameterValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.7.0: introduced
     */
    class BasicJavaActionParameterValue extends JavaActionParameterValue implements IBasicJavaActionParameterValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJavaActionParameterMapping: JavaActionParameterMapping;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new BasicJavaActionParameterValue instance in the SDK and on the server.
         * The new BasicJavaActionParameterValue will be automatically stored in the 'value' property
         * of the parent JavaActionParameterMapping element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createIn(container: JavaActionParameterMapping): BasicJavaActionParameterValue;
        /**
         * Creates and returns a new BasicJavaActionParameterValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): BasicJavaActionParameterValue;

    }
    interface IListOperation extends internal.IElement {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): ListOperation;
        load(callback: (element: ListOperation) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class ListOperation extends internal.Element implements IListOperation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;

        listVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IBinaryListOperation extends IListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): BinaryListOperation;
        load(callback: (element: BinaryListOperation) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class BinaryListOperation extends ListOperation implements IBinaryListOperation {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;

        secondListOrObjectVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * In version 6.9.0: introduced
     */
    interface IBinaryRequestHandling extends IRequestHandling {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): BinaryRequestHandling;
        load(callback: (element: BinaryRequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.9.0: introduced
     */
    class BinaryRequestHandling extends RequestHandling implements IBinaryRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        expression: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
         * The new BinaryRequestHandling will be automatically stored in the 'requestHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderRequestHandling(container: RestCallAction): BinaryRequestHandling;
        /**
         * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
         * The new BinaryRequestHandling will be automatically stored in the 'requestBodyHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): BinaryRequestHandling;
        /**
         * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
         * The new BinaryRequestHandling will be automatically stored in the 'requestHeaderHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): BinaryRequestHandling;
        /**
         * Creates and returns a new BinaryRequestHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): BinaryRequestHandling;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/break-event relevant section in reference guide}
     */
    interface IBreakEvent extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): BreakEvent;
        load(callback: (element: BreakEvent) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/break-event relevant section in reference guide}
     */
    class BreakEvent extends MicroflowObject implements IBreakEvent {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new BreakEvent instance in the SDK and on the server.
         * The new BreakEvent will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): BreakEvent;
        /**
         * Creates and returns a new BreakEvent instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): BreakEvent;

    }
    /**
     * TODO
     */
    interface ICaseValue extends internal.IElement {
        model: IModel;
        containerAsSequenceFlow: ISequenceFlow;
        load(): CaseValue;
        load(callback: (element: CaseValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class CaseValue extends internal.Element implements ICaseValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSequenceFlow: SequenceFlow;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/cast-object relevant section in reference guide}
     */
    interface ICastAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CastAction;
        load(callback: (element: CastAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/cast-object relevant section in reference guide}
     */
    class CastAction extends MicroflowAction implements ICastAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CastAction instance in the SDK and on the server.
         * The new CastAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CastAction;
        /**
         * Creates and returns a new CastAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CastAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-list relevant section in reference guide}
     */
    interface IChangeListAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ChangeListAction;
        load(callback: (element: ChangeListAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-list relevant section in reference guide}
     */
    class ChangeListAction extends MicroflowAction implements IChangeListAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        changeVariableName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        value: string;

        type: ChangeListActionType;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ChangeListAction instance in the SDK and on the server.
         * The new ChangeListAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ChangeListAction;
        /**
         * Creates and returns a new ChangeListAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ChangeListAction;

    }
    /**
     * TODO
     */
    interface IChangeMembersAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ChangeMembersAction;
        load(callback: (element: ChangeMembersAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class ChangeMembersAction extends MicroflowAction implements IChangeMembersAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        items: internal.IList<MemberChange>;

        refreshInClient: boolean;

        commit: CommitEnum;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-object relevant section in reference guide}
     */
    interface IChangeObjectAction extends IChangeMembersAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ChangeObjectAction;
        load(callback: (element: ChangeObjectAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-object relevant section in reference guide}
     */
    class ChangeObjectAction extends ChangeMembersAction implements IChangeObjectAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        changeVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ChangeObjectAction instance in the SDK and on the server.
         * The new ChangeObjectAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ChangeObjectAction;
        /**
         * Creates and returns a new ChangeObjectAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ChangeObjectAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-variable relevant section in reference guide}
     */
    interface IChangeVariableAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ChangeVariableAction;
        load(callback: (element: ChangeVariableAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/change-variable relevant section in reference guide}
     */
    class ChangeVariableAction extends MicroflowAction implements IChangeVariableAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        changeVariableName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        value: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ChangeVariableAction instance in the SDK and on the server.
         * The new ChangeVariableAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ChangeVariableAction;
        /**
         * Creates and returns a new ChangeVariableAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ChangeVariableAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/close-form relevant section in reference guide}
     */
    interface ICloseFormAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CloseFormAction;
        load(callback: (element: CloseFormAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/close-form relevant section in reference guide}
     */
    class CloseFormAction extends MicroflowAction implements ICloseFormAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CloseFormAction instance in the SDK and on the server.
         * The new CloseFormAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CloseFormAction;
        /**
         * Creates and returns a new CloseFormAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CloseFormAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/committing-objects relevant section in reference guide}
     */
    interface ICommitAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CommitAction;
        load(callback: (element: CommitAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/committing-objects relevant section in reference guide}
     */
    class CommitAction extends MicroflowAction implements ICommitAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        withEvents: boolean;

        commitVariableName: string;

        refreshInClient: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CommitAction instance in the SDK and on the server.
         * The new CommitAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CommitAction;
        /**
         * Creates and returns a new CommitAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CommitAction;

    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    interface IRange extends internal.IElement {
        model: IModel;
        containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
        containerAsImportMappingCall: IImportMappingCall;
        load(): Range;
        load(callback: (element: Range) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class Range extends internal.Element implements IRange {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDatabaseRetrieveSource: DatabaseRetrieveSource;
        readonly containerAsImportMappingCall: ImportMappingCall;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    interface IConstantRange extends IRange {
        model: IModel;
        containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
        containerAsImportMappingCall: IImportMappingCall;
        load(): ConstantRange;
        load(callback: (element: ConstantRange) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    class ConstantRange extends Range implements IConstantRange {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDatabaseRetrieveSource: DatabaseRetrieveSource;
        readonly containerAsImportMappingCall: ImportMappingCall;

        singleObject: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ConstantRange instance in the SDK and on the server.
         * The new ConstantRange will be automatically stored in the 'range' property
         * of the parent DatabaseRetrieveSource element passed as argument.
         */
        static createInDatabaseRetrieveSourceUnderRange(container: DatabaseRetrieveSource): ConstantRange;
        /**
         * Creates and returns a new ConstantRange instance in the SDK and on the server.
         * The new ConstantRange will be automatically stored in the 'range' property
         * of the parent ImportMappingCall element passed as argument.
         */
        static createInImportMappingCallUnderRange(container: ImportMappingCall): ConstantRange;
        /**
         * Creates and returns a new ConstantRange instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ConstantRange;

    }
    interface IContains extends IBinaryListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Contains;
        load(callback: (element: Contains) => void, forceRefresh?: boolean): any;
    }
    class Contains extends BinaryListOperation implements IContains {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Contains instance in the SDK and on the server.
         * The new Contains will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Contains;
        /**
         * Creates and returns a new Contains instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Contains;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/continue-event relevant section in reference guide}
     */
    interface IContinueEvent extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): ContinueEvent;
        load(callback: (element: ContinueEvent) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/continue-event relevant section in reference guide}
     */
    class ContinueEvent extends MicroflowObject implements IContinueEvent {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ContinueEvent instance in the SDK and on the server.
         * The new ContinueEvent will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): ContinueEvent;
        /**
         * Creates and returns a new ContinueEvent instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ContinueEvent;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-list relevant section in reference guide}
     */
    interface ICreateListAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CreateListAction;
        load(callback: (element: CreateListAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-list relevant section in reference guide}
     */
    class CreateListAction extends MicroflowAction implements ICreateListAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        entity: domainmodels.IEntity;
        readonly entityQualifiedName: string;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CreateListAction instance in the SDK and on the server.
         * The new CreateListAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CreateListAction;
        /**
         * Creates and returns a new CreateListAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CreateListAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-object relevant section in reference guide}
     */
    interface ICreateObjectAction extends IChangeMembersAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CreateObjectAction;
        load(callback: (element: CreateObjectAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-object relevant section in reference guide}
     */
    class CreateObjectAction extends ChangeMembersAction implements ICreateObjectAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        entity: domainmodels.IEntity;
        readonly entityQualifiedName: string;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CreateObjectAction instance in the SDK and on the server.
         * The new CreateObjectAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CreateObjectAction;
        /**
         * Creates and returns a new CreateObjectAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CreateObjectAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-variable relevant section in reference guide}
     */
    interface ICreateVariableAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): CreateVariableAction;
        load(callback: (element: CreateVariableAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/create-variable relevant section in reference guide}
     */
    class CreateVariableAction extends MicroflowAction implements ICreateVariableAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        variableName: string;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        variableDataType: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        initialValue: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CreateVariableAction instance in the SDK and on the server.
         * The new CreateVariableAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): CreateVariableAction;
        /**
         * Creates and returns a new CreateVariableAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CreateVariableAction;

    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    interface ICustomRange extends IRange {
        model: IModel;
        containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
        containerAsImportMappingCall: IImportMappingCall;
        load(): CustomRange;
        load(callback: (element: CustomRange) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    class CustomRange extends Range implements ICustomRange {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDatabaseRetrieveSource: DatabaseRetrieveSource;
        readonly containerAsImportMappingCall: ImportMappingCall;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        limitExpression: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        offsetExpression: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CustomRange instance in the SDK and on the server.
         * The new CustomRange will be automatically stored in the 'range' property
         * of the parent DatabaseRetrieveSource element passed as argument.
         */
        static createInDatabaseRetrieveSourceUnderRange(container: DatabaseRetrieveSource): CustomRange;
        /**
         * Creates and returns a new CustomRange instance in the SDK and on the server.
         * The new CustomRange will be automatically stored in the 'range' property
         * of the parent ImportMappingCall element passed as argument.
         */
        static createInImportMappingCallUnderRange(container: ImportMappingCall): CustomRange;
        /**
         * Creates and returns a new CustomRange instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CustomRange;

    }
    /**
     * TODO
     */
    interface ICustomRequestHandling extends IRequestHandling {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): CustomRequestHandling;
        load(callback: (element: CustomRequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class CustomRequestHandling extends RequestHandling implements ICustomRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        template: StringTemplate;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
         * The new CustomRequestHandling will be automatically stored in the 'requestHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderRequestHandling(container: RestCallAction): CustomRequestHandling;
        /**
         * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
         * The new CustomRequestHandling will be automatically stored in the 'requestBodyHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): CustomRequestHandling;
        /**
         * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
         * The new CustomRequestHandling will be automatically stored in the 'requestHeaderHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): CustomRequestHandling;
        /**
         * Creates and returns a new CustomRequestHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): CustomRequestHandling;

    }
    /**
     * TODO
     */
    interface IDatabaseRetrieveSource extends IRetrieveSource {
        model: IModel;
        containerAsRetrieveAction: IRetrieveAction;
        load(): DatabaseRetrieveSource;
        load(callback: (element: DatabaseRetrieveSource) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class DatabaseRetrieveSource extends RetrieveSource implements IDatabaseRetrieveSource {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRetrieveAction: RetrieveAction;

        entity: domainmodels.IEntity;
        readonly entityQualifiedName: string;

        range: Range;

        /**
         * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
         */
        xPathConstraint: string;

        sortItemList: SortItemList;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DatabaseRetrieveSource instance in the SDK and on the server.
         * The new DatabaseRetrieveSource will be automatically stored in the 'retrieveSource' property
         * of the parent RetrieveAction element passed as argument.
         */
        static createIn(container: RetrieveAction): DatabaseRetrieveSource;
        /**
         * Creates and returns a new DatabaseRetrieveSource instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DatabaseRetrieveSource;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/deleting-objects relevant section in reference guide}
     */
    interface IDeleteAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): DeleteAction;
        load(callback: (element: DeleteAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/deleting-objects relevant section in reference guide}
     */
    class DeleteAction extends MicroflowAction implements IDeleteAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        deleteVariableName: string;

        refreshInClient: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DeleteAction instance in the SDK and on the server.
         * The new DeleteAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): DeleteAction;
        /**
         * Creates and returns a new DeleteAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DeleteAction;

    }
    interface IDocumentTemplateParameterMapping extends internal.IElement {
        model: IModel;
        containerAsGenerateDocumentAction: IGenerateDocumentAction;
        load(): DocumentTemplateParameterMapping;
        load(callback: (element: DocumentTemplateParameterMapping) => void, forceRefresh?: boolean): any;
    }
    class DocumentTemplateParameterMapping extends internal.Element implements IDocumentTemplateParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsGenerateDocumentAction: GenerateDocumentAction;

        widgetName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DocumentTemplateParameterMapping instance in the SDK and on the server.
         * The new DocumentTemplateParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent GenerateDocumentAction element passed as argument.
         */
        static createIn(container: GenerateDocumentAction): DocumentTemplateParameterMapping;
        /**
         * Creates and returns a new DocumentTemplateParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DocumentTemplateParameterMapping;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/download-file relevant section in reference guide}
     */
    interface IDownloadFileAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): DownloadFileAction;
        load(callback: (element: DownloadFileAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/download-file relevant section in reference guide}
     */
    class DownloadFileAction extends MicroflowAction implements IDownloadFileAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        fileDocumentVariableName: string;

        showFileInBrowser: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new DownloadFileAction instance in the SDK and on the server.
         * The new DownloadFileAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): DownloadFileAction;
        /**
         * Creates and returns a new DownloadFileAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): DownloadFileAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/end-event relevant section in reference guide}
     */
    interface IEndEvent extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): EndEvent;
        load(callback: (element: EndEvent) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/end-event relevant section in reference guide}
     */
    class EndEvent extends MicroflowObject implements IEndEvent {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        returnValue: string;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EndEvent instance in the SDK and on the server.
         * The new EndEvent will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): EndEvent;
        /**
         * Creates and returns a new EndEvent instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EndEvent;

    }
    /**
     * In version 6.8.0: introduced
     */
    interface IEntityTypeJavaActionParameterValue extends IJavaActionParameterValue {
        model: IModel;
        containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
        load(): EntityTypeJavaActionParameterValue;
        load(callback: (element: EntityTypeJavaActionParameterValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.8.0: introduced
     */
    class EntityTypeJavaActionParameterValue extends JavaActionParameterValue implements IEntityTypeJavaActionParameterValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJavaActionParameterMapping: JavaActionParameterMapping;

        entity: domainmodels.IEntity;
        readonly entityQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EntityTypeJavaActionParameterValue instance in the SDK and on the server.
         * The new EntityTypeJavaActionParameterValue will be automatically stored in the 'value' property
         * of the parent JavaActionParameterMapping element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createIn(container: JavaActionParameterMapping): EntityTypeJavaActionParameterValue;
        /**
         * Creates and returns a new EntityTypeJavaActionParameterValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EntityTypeJavaActionParameterValue;

    }
    /**
     * TODO
     */
    interface IEnumerationCase extends ICaseValue {
        model: IModel;
        containerAsSequenceFlow: ISequenceFlow;
        load(): EnumerationCase;
        load(callback: (element: EnumerationCase) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class EnumerationCase extends CaseValue implements IEnumerationCase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSequenceFlow: SequenceFlow;

        value: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new EnumerationCase instance in the SDK and on the server.
         * The new EnumerationCase will be automatically stored in the 'caseValue' property
         * of the parent SequenceFlow element passed as argument.
         */
        static createIn(container: SequenceFlow): EnumerationCase;
        /**
         * Creates and returns a new EnumerationCase instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): EnumerationCase;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/error-event relevant section in reference guide}
     */
    interface IErrorEvent extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): ErrorEvent;
        load(callback: (element: ErrorEvent) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/error-event relevant section in reference guide}
     */
    class ErrorEvent extends MicroflowObject implements IErrorEvent {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ErrorEvent instance in the SDK and on the server.
         * The new ErrorEvent will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): ErrorEvent;
        /**
         * Creates and returns a new ErrorEvent instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ErrorEvent;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/merge relevant section in reference guide}
     */
    interface IExclusiveMerge extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): ExclusiveMerge;
        load(callback: (element: ExclusiveMerge) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/merge relevant section in reference guide}
     */
    class ExclusiveMerge extends MicroflowObject implements IExclusiveMerge {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ExclusiveMerge instance in the SDK and on the server.
         * The new ExclusiveMerge will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): ExclusiveMerge;
        /**
         * Creates and returns a new ExclusiveMerge instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ExclusiveMerge;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/exclusive-split relevant section in reference guide}
     */
    interface IExclusiveSplit extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): ExclusiveSplit;
        load(callback: (element: ExclusiveSplit) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/exclusive-split relevant section in reference guide}
     */
    class ExclusiveSplit extends MicroflowObject implements IExclusiveSplit {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        splitCondition: SplitCondition;

        caption: string;

        errorHandlingType: ErrorHandlingType;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ExclusiveSplit instance in the SDK and on the server.
         * The new ExclusiveSplit will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): ExclusiveSplit;
        /**
         * Creates and returns a new ExclusiveSplit instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ExclusiveSplit;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/export-mapping-action relevant section in reference guide}
     */
    interface IExportXmlAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ExportXmlAction;
        load(callback: (element: ExportXmlAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/export-mapping-action relevant section in reference guide}
     */
    class ExportXmlAction extends MicroflowAction implements IExportXmlAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        mapping: exportmappings.IExportMapping;
        readonly mappingQualifiedName: string;

        mappingArgumentVariableName: string;

        outputMethod: OutputMethod;

        isValidationRequired: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ExportXmlAction instance in the SDK and on the server.
         * The new ExportXmlAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ExportXmlAction;
        /**
         * Creates and returns a new ExportXmlAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ExportXmlAction;

    }
    /**
     * TODO : Abstract
     */
    interface ISplitCondition extends internal.IElement {
        model: IModel;
        containerAsExclusiveSplit: IExclusiveSplit;
        load(): SplitCondition;
        load(callback: (element: SplitCondition) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO : Abstract
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class SplitCondition extends internal.Element implements ISplitCondition {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExclusiveSplit: ExclusiveSplit;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IExpressionSplitCondition extends ISplitCondition {
        model: IModel;
        containerAsExclusiveSplit: IExclusiveSplit;
        load(): ExpressionSplitCondition;
        load(callback: (element: ExpressionSplitCondition) => void, forceRefresh?: boolean): any;
    }
    class ExpressionSplitCondition extends SplitCondition implements IExpressionSplitCondition {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExclusiveSplit: ExclusiveSplit;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        expression: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ExpressionSplitCondition instance in the SDK and on the server.
         * The new ExpressionSplitCondition will be automatically stored in the 'splitCondition' property
         * of the parent ExclusiveSplit element passed as argument.
         */
        static createIn(container: ExclusiveSplit): ExpressionSplitCondition;
        /**
         * Creates and returns a new ExpressionSplitCondition instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ExpressionSplitCondition;

    }
    /**
     * TODO
     */
    interface IOutputMethod extends internal.IElement {
        model: IModel;
        containerAsExportXmlAction: IExportXmlAction;
        load(): OutputMethod;
        load(callback: (element: OutputMethod) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class OutputMethod extends internal.Element implements IOutputMethod {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExportXmlAction: ExportXmlAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO
     */
    interface IFileDocumentExport extends IOutputMethod {
        model: IModel;
        containerAsExportXmlAction: IExportXmlAction;
        load(): FileDocumentExport;
        load(callback: (element: FileDocumentExport) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class FileDocumentExport extends OutputMethod implements IFileDocumentExport {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExportXmlAction: ExportXmlAction;

        targetDocumentVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new FileDocumentExport instance in the SDK and on the server.
         * The new FileDocumentExport will be automatically stored in the 'outputMethod' property
         * of the parent ExportXmlAction element passed as argument.
         */
        static createIn(container: ExportXmlAction): FileDocumentExport;
        /**
         * Creates and returns a new FileDocumentExport instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): FileDocumentExport;

    }
    interface IInspectAttribute extends IListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): InspectAttribute;
        load(callback: (element: InspectAttribute) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class InspectAttribute extends ListOperation implements IInspectAttribute {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        expression: string;

        attribute: domainmodels.IAttribute;
        readonly attributeQualifiedName: string;

        /**
         * In version 7.0.0: introduced
         */
        association: domainmodels.IAssociationBase;
        readonly associationQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    interface IFilter extends IInspectAttribute {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Filter;
        load(callback: (element: Filter) => void, forceRefresh?: boolean): any;
    }
    class Filter extends InspectAttribute implements IFilter {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Filter instance in the SDK and on the server.
         * The new Filter will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Filter;
        /**
         * Creates and returns a new Filter instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Filter;

    }
    interface IFind extends IInspectAttribute {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Find;
        load(callback: (element: Find) => void, forceRefresh?: boolean): any;
    }
    class Find extends InspectAttribute implements IFind {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Find instance in the SDK and on the server.
         * The new Find will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Find;
        /**
         * Creates and returns a new Find instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Find;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/generate-document relevant section in reference guide}
     */
    interface IGenerateDocumentAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): GenerateDocumentAction;
        load(callback: (element: GenerateDocumentAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/generate-document relevant section in reference guide}
     */
    class GenerateDocumentAction extends MicroflowAction implements IGenerateDocumentAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        parameterMappings: internal.IList<DocumentTemplateParameterMapping>;

        fileVariableName: string;

        languageVariableName: string;

        documentType: TargetDocumentType;

        languageSetting: LanguageSettingType;

        documentTemplate: documenttemplates.IDocumentTemplate;
        readonly documentTemplateQualifiedName: string;

        overrideTopMargin: boolean;

        overrideBottomMargin: boolean;

        overrideLeftMargin: boolean;

        overrideRightMargin: boolean;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        marginLeftInInch: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        marginRightInInch: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        marginTopInInch: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        marginBottomInInch: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new GenerateDocumentAction instance in the SDK and on the server.
         * The new GenerateDocumentAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): GenerateDocumentAction;
        /**
         * Creates and returns a new GenerateDocumentAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): GenerateDocumentAction;

    }
    interface IHead extends IListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Head;
        load(callback: (element: Head) => void, forceRefresh?: boolean): any;
    }
    class Head extends ListOperation implements IHead {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Head instance in the SDK and on the server.
         * The new Head will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Head;
        /**
         * Creates and returns a new Head instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Head;

    }
    interface IHttpConfiguration extends internal.IElement {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): HttpConfiguration;
        load(callback: (element: HttpConfiguration) => void, forceRefresh?: boolean): any;
    }
    class HttpConfiguration extends internal.Element implements IHttpConfiguration {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        overrideLocation: boolean;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        customLocation: string;

        /**
         * In version 6.6.0: introduced
         */
        customLocationTemplate: StringTemplate;

        useAuthentication: boolean;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        httpAuthenticationUserName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        authenticationPassword: string;

        headerEntries: internal.IList<HttpHeaderEntry>;

        /**
         * In version 6.6.0: introduced
         */
        httpMethod: HttpMethod;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
         * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
         * of the parent WebServiceCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.0.0, 6.0.1, 6.1.0, 6.2.0, 6.3.0, 6.4.0, 6.4.1, 6.5.0
         */
        static createIn(container: WebServiceCallAction): HttpConfiguration;
        /**
         * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
         * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderHttpConfiguration(container: RestCallAction): HttpConfiguration;
        /**
         * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
         * The new HttpConfiguration will be automatically stored in the 'httpConfiguration' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderHttpConfiguration(container: WebServiceCallAction): HttpConfiguration;
        /**
         * Creates and returns a new HttpConfiguration instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): HttpConfiguration;

    }
    /**
     * TODO
     */
    interface IHttpHeaderEntry extends internal.IElement {
        model: IModel;
        containerAsHttpConfiguration: IHttpConfiguration;
        load(): HttpHeaderEntry;
        load(callback: (element: HttpHeaderEntry) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class HttpHeaderEntry extends internal.Element implements IHttpHeaderEntry {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsHttpConfiguration: HttpConfiguration;

        key: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        value: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new HttpHeaderEntry instance in the SDK and on the server.
         * The new HttpHeaderEntry will be automatically stored in the 'headerEntries' property
         * of the parent HttpConfiguration element passed as argument.
         */
        static createIn(container: HttpConfiguration): HttpHeaderEntry;
        /**
         * Creates and returns a new HttpHeaderEntry instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): HttpHeaderEntry;

    }
    /**
     * TODO
     */
    interface IImportMappingCall extends internal.IElement {
        model: IModel;
        containerAsResultHandling: IResultHandling;
        load(): ImportMappingCall;
        load(callback: (element: ImportMappingCall) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class ImportMappingCall extends internal.Element implements IImportMappingCall {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsResultHandling: ResultHandling;

        mapping: importmappings.IImportMapping;
        readonly mappingQualifiedName: string;

        mappingArgumentVariableName: string;

        range: Range;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ImportMappingCall instance in the SDK and on the server.
         * The new ImportMappingCall will be automatically stored in the 'importMappingCall' property
         * of the parent ResultHandling element passed as argument.
         */
        static createIn(container: ResultHandling): ImportMappingCall;
        /**
         * Creates and returns a new ImportMappingCall instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ImportMappingCall;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/import-mapping-action relevant section in reference guide}
     */
    interface IImportXmlAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ImportXmlAction;
        load(callback: (element: ImportXmlAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/import-mapping-action relevant section in reference guide}
     */
    class ImportXmlAction extends MicroflowAction implements IImportXmlAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        xmlDocumentVariableName: string;

        resultHandling: ResultHandling;

        isValidationRequired: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ImportXmlAction instance in the SDK and on the server.
         * The new ImportXmlAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ImportXmlAction;
        /**
         * Creates and returns a new ImportXmlAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ImportXmlAction;

    }
    /**
     * TODO
     */
    interface IInheritanceCase extends ICaseValue {
        model: IModel;
        containerAsSequenceFlow: ISequenceFlow;
        load(): InheritanceCase;
        load(callback: (element: InheritanceCase) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class InheritanceCase extends CaseValue implements IInheritanceCase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSequenceFlow: SequenceFlow;

        value: domainmodels.IEntity;
        readonly valueQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new InheritanceCase instance in the SDK and on the server.
         * The new InheritanceCase will be automatically stored in the 'caseValue' property
         * of the parent SequenceFlow element passed as argument.
         */
        static createIn(container: SequenceFlow): InheritanceCase;
        /**
         * Creates and returns a new InheritanceCase instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): InheritanceCase;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/inheritance-split relevant section in reference guide}
     */
    interface IInheritanceSplit extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): InheritanceSplit;
        load(callback: (element: InheritanceSplit) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/inheritance-split relevant section in reference guide}
     */
    class InheritanceSplit extends MicroflowObject implements IInheritanceSplit {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        splitVariableName: string;

        caption: string;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new InheritanceSplit instance in the SDK and on the server.
         * The new InheritanceSplit will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): InheritanceSplit;
        /**
         * Creates and returns a new InheritanceSplit instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): InheritanceSplit;

    }
    interface IIntersect extends IBinaryListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Intersect;
        load(callback: (element: Intersect) => void, forceRefresh?: boolean): any;
    }
    class Intersect extends BinaryListOperation implements IIntersect {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Intersect instance in the SDK and on the server.
         * The new Intersect will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Intersect;
        /**
         * Creates and returns a new Intersect instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Intersect;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/java-action-call relevant section in reference guide}
     */
    interface IJavaActionCallAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): JavaActionCallAction;
        load(callback: (element: JavaActionCallAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/java-action-call relevant section in reference guide}
     */
    class JavaActionCallAction extends MicroflowAction implements IJavaActionCallAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        javaAction: javaactions.IJavaAction;
        readonly javaActionQualifiedName: string;

        parameterMappings: internal.IList<JavaActionParameterMapping>;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new JavaActionCallAction instance in the SDK and on the server.
         * The new JavaActionCallAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): JavaActionCallAction;
        /**
         * Creates and returns a new JavaActionCallAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): JavaActionCallAction;

    }
    interface IJavaActionParameterMapping extends internal.IElement {
        model: IModel;
        containerAsJavaActionCallAction: IJavaActionCallAction;
        load(): JavaActionParameterMapping;
        load(callback: (element: JavaActionParameterMapping) => void, forceRefresh?: boolean): any;
    }
    class JavaActionParameterMapping extends internal.Element implements IJavaActionParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJavaActionCallAction: JavaActionCallAction;

        parameter: javaactions.IJavaActionParameter;
        readonly parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         *
         * In version 6.7.0: deleted
         */
        argument: string;

        /**
         * In version 6.7.0: introduced
         */
        value: JavaActionParameterValue;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new JavaActionParameterMapping instance in the SDK and on the server.
         * The new JavaActionParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent JavaActionCallAction element passed as argument.
         */
        static createIn(container: JavaActionCallAction): JavaActionParameterMapping;
        /**
         * Creates and returns a new JavaActionParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): JavaActionParameterMapping;

    }
    interface IListEquals extends IBinaryListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): ListEquals;
        load(callback: (element: ListEquals) => void, forceRefresh?: boolean): any;
    }
    class ListEquals extends BinaryListOperation implements IListEquals {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ListEquals instance in the SDK and on the server.
         * The new ListEquals will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): ListEquals;
        /**
         * Creates and returns a new ListEquals instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ListEquals;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/list-operation relevant section in reference guide}
     */
    interface IListOperationAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ListOperationAction;
        load(callback: (element: ListOperationAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/list-operation relevant section in reference guide}
     */
    class ListOperationAction extends MicroflowAction implements IListOperationAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        operation: ListOperation;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ListOperationAction instance in the SDK and on the server.
         * The new ListOperationAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ListOperationAction;
        /**
         * Creates and returns a new ListOperationAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ListOperationAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/log-message relevant section in reference guide}
     */
    interface ILogMessageAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): LogMessageAction;
        load(callback: (element: LogMessageAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/log-message relevant section in reference guide}
     */
    class LogMessageAction extends MicroflowAction implements ILogMessageAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        level: LogLevel;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        node: string;

        messageTemplate: StringTemplate;

        includeLatestStackTrace: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new LogMessageAction instance in the SDK and on the server.
         * The new LogMessageAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): LogMessageAction;
        /**
         * Creates and returns a new LogMessageAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): LogMessageAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/loop relevant section in reference guide}
     */
    interface ILoopedActivity extends IActivity {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): LoopedActivity;
        load(callback: (element: LoopedActivity) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/loop relevant section in reference guide}
     */
    class LoopedActivity extends Activity implements ILoopedActivity {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        objectCollection: MicroflowObjectCollection;

        iteratedListVariableName: string;

        loopVariableName: string;

        errorHandlingType: ErrorHandlingType;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new LoopedActivity instance in the SDK and on the server.
         * The new LoopedActivity will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): LoopedActivity;
        /**
         * Creates and returns a new LoopedActivity instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): LoopedActivity;

    }
    /**
     * TODO
     */
    interface IMappingRequestHandling extends IRequestHandling {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): MappingRequestHandling;
        load(callback: (element: MappingRequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class MappingRequestHandling extends RequestHandling implements IMappingRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        mapping: exportmappings.IExportMapping;
        readonly mappingQualifiedName: string;

        mappingArgumentVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
         * The new MappingRequestHandling will be automatically stored in the 'requestHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderRequestHandling(container: RestCallAction): MappingRequestHandling;
        /**
         * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
         * The new MappingRequestHandling will be automatically stored in the 'requestBodyHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): MappingRequestHandling;
        /**
         * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
         * The new MappingRequestHandling will be automatically stored in the 'requestHeaderHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): MappingRequestHandling;
        /**
         * Creates and returns a new MappingRequestHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MappingRequestHandling;

    }
    /**
     * TODO
     */
    interface IMemberChange extends internal.IElement {
        model: IModel;
        containerAsChangeMembersAction: IChangeMembersAction;
        load(): MemberChange;
        load(callback: (element: MemberChange) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class MemberChange extends internal.Element implements IMemberChange {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsChangeMembersAction: ChangeMembersAction;

        attribute: domainmodels.IAttribute;
        readonly attributeQualifiedName: string;

        association: domainmodels.IAssociationBase;
        readonly associationQualifiedName: string;

        type: ChangeActionItemType;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        value: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MemberChange instance in the SDK and on the server.
         * The new MemberChange will be automatically stored in the 'items' property
         * of the parent ChangeMembersAction element passed as argument.
         */
        static createIn(container: ChangeMembersAction): MemberChange;
        /**
         * Creates and returns a new MemberChange instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MemberChange;

    }
    /**
     * TODO: Abstract
     */
    interface IMicroflowBase extends projects.IDocument {
        model: IModel;
        containerAsFolderBase: projects.IFolderBase;
        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        returnType: string;
        load(): MicroflowBase;
        load(callback: (element: MicroflowBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: Abstract
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MicroflowBase extends projects.Document implements IMicroflowBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsFolderBase: projects.FolderBase;

        objectCollection: MicroflowObjectCollection;

        flows: internal.IList<Flow>;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        returnType: string;

        applyEntityAccess: boolean;

        markAsUsed: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/microflows relevant section in reference guide}
     */
    interface IMicroflow extends IMicroflowBase {
        model: IModel;
        containerAsFolderBase: projects.IFolderBase;
        load(): Microflow;
        load(callback: (element: Microflow) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/microflows relevant section in reference guide}
     */
    class Microflow extends MicroflowBase implements IMicroflow {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsFolderBase: projects.FolderBase;

        allowedModuleRoles: internal.IList<security.IModuleRole>;
        readonly allowedModuleRolesQualifiedNames: string[];

        allowConcurrentExecution: boolean;

        concurrencyErrorMessage: texts.Text;

        concurrencyErrorMicroflow: IMicroflow;
        readonly concurrencyErrorMicroflowQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase);
        /**
         * Creates a new Microflow unit in the SDK and on the server.
         * Expects one argument, the projects.IFolderBase in which this unit is contained.
         */
        static createIn(container: projects.IFolderBase): Microflow;


    }
    interface IMicroflowCall extends internal.IElement {
        model: IModel;
        containerAsMicroflowCallAction: IMicroflowCallAction;
        load(): MicroflowCall;
        load(callback: (element: MicroflowCall) => void, forceRefresh?: boolean): any;
    }
    class MicroflowCall extends internal.Element implements IMicroflowCall {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowCallAction: MicroflowCallAction;

        microflow: IMicroflow;
        readonly microflowQualifiedName: string;

        parameterMappings: internal.IList<MicroflowCallParameterMapping>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowCall instance in the SDK and on the server.
         * The new MicroflowCall will be automatically stored in the 'microflowCall' property
         * of the parent MicroflowCallAction element passed as argument.
         */
        static createIn(container: MicroflowCallAction): MicroflowCall;
        /**
         * Creates and returns a new MicroflowCall instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowCall;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/microflow-call relevant section in reference guide}
     */
    interface IMicroflowCallAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): MicroflowCallAction;
        load(callback: (element: MicroflowCallAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/microflow-call relevant section in reference guide}
     */
    class MicroflowCallAction extends MicroflowAction implements IMicroflowCallAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        /**
         * In version 6.0.0: removed optional
         */
        microflowCall: MicroflowCall;

        useReturnVariable: boolean;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowCallAction instance in the SDK and on the server.
         * The new MicroflowCallAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): MicroflowCallAction;
        /**
         * Creates and returns a new MicroflowCallAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowCallAction;

    }
    interface IMicroflowCallParameterMapping extends internal.IElement {
        model: IModel;
        containerAsMicroflowCall: IMicroflowCall;
        load(): MicroflowCallParameterMapping;
        load(callback: (element: MicroflowCallParameterMapping) => void, forceRefresh?: boolean): any;
    }
    class MicroflowCallParameterMapping extends internal.Element implements IMicroflowCallParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowCall: MicroflowCall;

        parameter: IMicroflowParameter;
        readonly parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowCallParameterMapping instance in the SDK and on the server.
         * The new MicroflowCallParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent MicroflowCall element passed as argument.
         */
        static createIn(container: MicroflowCall): MicroflowCallParameterMapping;
        /**
         * Creates and returns a new MicroflowCallParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowCallParameterMapping;

    }
    /**
     * In version 6.9.0: introduced
     */
    interface IMicroflowJavaActionParameterValue extends IJavaActionParameterValue {
        model: IModel;
        containerAsJavaActionParameterMapping: IJavaActionParameterMapping;
        load(): MicroflowJavaActionParameterValue;
        load(callback: (element: MicroflowJavaActionParameterValue) => void, forceRefresh?: boolean): any;
    }
    /**
     * In version 6.9.0: introduced
     */
    class MicroflowJavaActionParameterValue extends JavaActionParameterValue implements IMicroflowJavaActionParameterValue {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsJavaActionParameterMapping: JavaActionParameterMapping;

        microflow: IMicroflow;
        readonly microflowQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowJavaActionParameterValue instance in the SDK and on the server.
         * The new MicroflowJavaActionParameterValue will be automatically stored in the 'value' property
         * of the parent JavaActionParameterMapping element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createIn(container: JavaActionParameterMapping): MicroflowJavaActionParameterValue;
        /**
         * Creates and returns a new MicroflowJavaActionParameterValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowJavaActionParameterValue;

    }
    /**
     * TODO: artificial object
     */
    interface IMicroflowObjectCollection extends internal.IElement {
        model: IModel;
        containerAsLoopedActivity: ILoopedActivity;
        containerAsMicroflowBase: IMicroflowBase;
        load(): MicroflowObjectCollection;
        load(callback: (element: MicroflowObjectCollection) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO: artificial object
     */
    class MicroflowObjectCollection extends internal.Element implements IMicroflowObjectCollection {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsLoopedActivity: LoopedActivity;
        readonly containerAsMicroflowBase: MicroflowBase;

        objects: internal.IList<MicroflowObject>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
         * The new MicroflowObjectCollection will be automatically stored in the 'objectCollection' property
         * of the parent LoopedActivity element passed as argument.
         */
        static createInLoopedActivityUnderObjectCollection(container: LoopedActivity): MicroflowObjectCollection;
        /**
         * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
         * The new MicroflowObjectCollection will be automatically stored in the 'objectCollection' property
         * of the parent MicroflowBase element passed as argument.
         */
        static createInMicroflowBaseUnderObjectCollection(container: MicroflowBase): MicroflowObjectCollection;
        /**
         * Creates and returns a new MicroflowObjectCollection instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowObjectCollection;

    }
    interface IMicroflowParameterBase extends internal.IElement {
        model: IModel;
        containerAsMicroflow: IMicroflow;
        containerAsRule: IRule;
        name: string;
        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        type: string;
        load(): MicroflowParameterBase;
        load(callback: (element: MicroflowParameterBase) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class MicroflowParameterBase extends internal.Element implements IMicroflowParameterBase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflow: Microflow;
        readonly containerAsRule: Rule;

        name: string;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        type: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
     */
    interface IMicroflowParameter extends IMicroflowParameterBase {
        model: IModel;
        containerAsMicroflow: IMicroflow;
        load(): MicroflowParameter;
        load(callback: (element: MicroflowParameter) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
     */
    class MicroflowParameter extends MicroflowParameterBase implements IMicroflowParameter {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflow: Microflow;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);


    }
    interface IMicroflowParameterObject extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): MicroflowParameterObject;
        load(callback: (element: MicroflowParameterObject) => void, forceRefresh?: boolean): any;
    }
    class MicroflowParameterObject extends MicroflowObject implements IMicroflowParameterObject {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;

        name: string;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         */
        type: string;

        documentation: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new MicroflowParameterObject instance in the SDK and on the server.
         * The new MicroflowParameterObject will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): MicroflowParameterObject;
        /**
         * Creates and returns a new MicroflowParameterObject instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): MicroflowParameterObject;

    }
    /**
     * TODO
     */
    interface INoCase extends ICaseValue {
        model: IModel;
        containerAsSequenceFlow: ISequenceFlow;
        load(): NoCase;
        load(callback: (element: NoCase) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class NoCase extends CaseValue implements INoCase {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSequenceFlow: SequenceFlow;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new NoCase instance in the SDK and on the server.
         * The new NoCase will be automatically stored in the 'caseValue' property
         * of the parent SequenceFlow element passed as argument.
         */
        static createIn(container: SequenceFlow): NoCase;
        /**
         * Creates and returns a new NoCase instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): NoCase;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/call-rest-action relevant section in reference guide}
     *
     * In version 6.6.0: introduced
     */
    interface IRestCallAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): RestCallAction;
        load(callback: (element: RestCallAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/call-rest-action relevant section in reference guide}
     *
     * In version 6.6.0: introduced
     */
    class RestCallAction extends MicroflowAction implements IRestCallAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        httpConfiguration: HttpConfiguration;

        requestHandling: RequestHandling;

        /**
         * In version 6.9.0: introduced
         */
        requestHandlingType: RequestHandlingType;

        resultHandling: ResultHandling;

        /**
         * In version 6.9.0: introduced
         */
        resultHandlingType: ResultHandlingType;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RestCallAction instance in the SDK and on the server.
         * The new RestCallAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createIn(container: ActionActivity): RestCallAction;
        /**
         * Creates and returns a new RestCallAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RestCallAction;

    }
    /**
     * TODO
     */
    interface IResultHandling extends internal.IElement {
        model: IModel;
        containerAsImportXmlAction: IImportXmlAction;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): ResultHandling;
        load(callback: (element: ResultHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class ResultHandling extends internal.Element implements IResultHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsImportXmlAction: ImportXmlAction;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        importMappingCall: ImportMappingCall;

        storeInVariable: boolean;

        outputVariableName: string;

        /**
         * The value of this property is conceptually of type dataTypes.DataType.
         *
         * In version 6.10.0: introduced
         */
        variableDataType: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ResultHandling instance in the SDK and on the server.
         * The new ResultHandling will be automatically stored in the 'resultHandling' property
         * of the parent ImportXmlAction element passed as argument.
         */
        static createInImportXmlActionUnderResultHandling(container: ImportXmlAction): ResultHandling;
        /**
         * Creates and returns a new ResultHandling instance in the SDK and on the server.
         * The new ResultHandling will be automatically stored in the 'resultHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderResultHandling(container: RestCallAction): ResultHandling;
        /**
         * Creates and returns a new ResultHandling instance in the SDK and on the server.
         * The new ResultHandling will be automatically stored in the 'resultHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderResultHandling(container: WebServiceCallAction): ResultHandling;
        /**
         * Creates and returns a new ResultHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ResultHandling;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/retrieve relevant section in reference guide}
     */
    interface IRetrieveAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): RetrieveAction;
        load(callback: (element: RetrieveAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/retrieve relevant section in reference guide}
     */
    class RetrieveAction extends MicroflowAction implements IRetrieveAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        retrieveSource: RetrieveSource;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RetrieveAction instance in the SDK and on the server.
         * The new RetrieveAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): RetrieveAction;
        /**
         * Creates and returns a new RetrieveAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RetrieveAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/rollback-object relevant section in reference guide}
     */
    interface IRollbackAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): RollbackAction;
        load(callback: (element: RollbackAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/rollback-object relevant section in reference guide}
     */
    class RollbackAction extends MicroflowAction implements IRollbackAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        rollbackVariableName: string;

        refreshInClient: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RollbackAction instance in the SDK and on the server.
         * The new RollbackAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): RollbackAction;
        /**
         * Creates and returns a new RollbackAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RollbackAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/rules relevant section in reference guide}
     */
    interface IRule extends IMicroflowBase {
        model: IModel;
        containerAsFolderBase: projects.IFolderBase;
        load(): Rule;
        load(callback: (element: Rule) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/rules relevant section in reference guide}
     */
    class Rule extends MicroflowBase implements IRule {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsFolderBase: projects.FolderBase;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, container: projects.IFolderBase);
        /**
         * Creates a new Rule unit in the SDK and on the server.
         * Expects one argument, the projects.IFolderBase in which this unit is contained.
         */
        static createIn(container: projects.IFolderBase): Rule;


    }
    /**
     * TODO
     */
    interface IRuleCall extends internal.IElement {
        model: IModel;
        containerAsRuleSplitCondition: IRuleSplitCondition;
        load(): RuleCall;
        load(callback: (element: RuleCall) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class RuleCall extends internal.Element implements IRuleCall {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRuleSplitCondition: RuleSplitCondition;

        rule: IRule;
        readonly ruleQualifiedName: string;

        parameterMappings: internal.IList<RuleCallParameterMapping>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RuleCall instance in the SDK and on the server.
         * The new RuleCall will be automatically stored in the 'ruleCall' property
         * of the parent RuleSplitCondition element passed as argument.
         */
        static createIn(container: RuleSplitCondition): RuleCall;
        /**
         * Creates and returns a new RuleCall instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RuleCall;

    }
    /**
     * TODO
     */
    interface IRuleCallParameterMapping extends internal.IElement {
        model: IModel;
        containerAsRuleCall: IRuleCall;
        load(): RuleCallParameterMapping;
        load(callback: (element: RuleCallParameterMapping) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class RuleCallParameterMapping extends internal.Element implements IRuleCallParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRuleCall: RuleCall;

        parameter: IRuleParameter;
        readonly parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RuleCallParameterMapping instance in the SDK and on the server.
         * The new RuleCallParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent RuleCall element passed as argument.
         */
        static createIn(container: RuleCall): RuleCallParameterMapping;
        /**
         * Creates and returns a new RuleCallParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RuleCallParameterMapping;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
     */
    interface IRuleParameter extends IMicroflowParameterBase {
        model: IModel;
        containerAsRule: IRule;
        load(): RuleParameter;
        load(callback: (element: RuleParameter) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/parameter relevant section in reference guide}
     */
    class RuleParameter extends MicroflowParameterBase implements IRuleParameter {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRule: Rule;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);


    }
    interface IRuleSplitCondition extends ISplitCondition {
        model: IModel;
        containerAsExclusiveSplit: IExclusiveSplit;
        load(): RuleSplitCondition;
        load(callback: (element: RuleSplitCondition) => void, forceRefresh?: boolean): any;
    }
    class RuleSplitCondition extends SplitCondition implements IRuleSplitCondition {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExclusiveSplit: ExclusiveSplit;

        ruleCall: RuleCall;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new RuleSplitCondition instance in the SDK and on the server.
         * The new RuleSplitCondition will be automatically stored in the 'splitCondition' property
         * of the parent ExclusiveSplit element passed as argument.
         */
        static createIn(container: ExclusiveSplit): RuleSplitCondition;
        /**
         * Creates and returns a new RuleSplitCondition instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): RuleSplitCondition;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/sequence-flow relevant section in reference guide}
     */
    interface ISequenceFlow extends IFlow {
        model: IModel;
        containerAsMicroflowBase: IMicroflowBase;
        load(): SequenceFlow;
        load(callback: (element: SequenceFlow) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/sequence-flow relevant section in reference guide}
     */
    class SequenceFlow extends Flow implements ISequenceFlow {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowBase: MicroflowBase;

        caseValue: CaseValue;

        isErrorHandler: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new SequenceFlow instance in the SDK and on the server.
         * The new SequenceFlow will be automatically stored in the 'flows' property
         * of the parent MicroflowBase element passed as argument.
         */
        static createIn(container: MicroflowBase): SequenceFlow;
        /**
         * Creates and returns a new SequenceFlow instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): SequenceFlow;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-home-page TODO: Page does not exist, should be created.}
     */
    interface IShowHomePageAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ShowHomePageAction;
        load(callback: (element: ShowHomePageAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-home-page TODO: Page does not exist, should be created.}
     */
    class ShowHomePageAction extends MicroflowAction implements IShowHomePageAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ShowHomePageAction instance in the SDK and on the server.
         * The new ShowHomePageAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ShowHomePageAction;
        /**
         * Creates and returns a new ShowHomePageAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ShowHomePageAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-message relevant section in reference guide}
     */
    interface IShowMessageAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ShowMessageAction;
        load(callback: (element: ShowMessageAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-message relevant section in reference guide}
     */
    class ShowMessageAction extends MicroflowAction implements IShowMessageAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        template: TextTemplate;

        type: ShowMessageType;

        blocking: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ShowMessageAction instance in the SDK and on the server.
         * The new ShowMessageAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ShowMessageAction;
        /**
         * Creates and returns a new ShowMessageAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ShowMessageAction;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-page relevant section in reference guide}
     */
    interface IShowPageAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ShowPageAction;
        load(callback: (element: ShowPageAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/show-page relevant section in reference guide}
     */
    class ShowPageAction extends MicroflowAction implements IShowPageAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        pageSettings: pages.PageSettings;

        passedObjectVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ShowPageAction instance in the SDK and on the server.
         * The new ShowPageAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ShowPageAction;
        /**
         * Creates and returns a new ShowPageAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ShowPageAction;

    }
    /**
     * TODO
     */
    interface ISimpleRequestHandling extends IRequestHandling {
        model: IModel;
        containerAsRestCallAction: IRestCallAction;
        containerAsWebServiceCallAction: IWebServiceCallAction;
        load(): SimpleRequestHandling;
        load(callback: (element: SimpleRequestHandling) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class SimpleRequestHandling extends RequestHandling implements ISimpleRequestHandling {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsRestCallAction: RestCallAction;
        readonly containerAsWebServiceCallAction: WebServiceCallAction;

        parameterMappings: internal.IList<WebServiceOperationSimpleParameterMapping>;

        /**
         * In version 6.7.0: introduced
         */
        nullValueOption: NullValueOption;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
         * The new SimpleRequestHandling will be automatically stored in the 'requestHandling' property
         * of the parent RestCallAction element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInRestCallActionUnderRequestHandling(container: RestCallAction): SimpleRequestHandling;
        /**
         * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
         * The new SimpleRequestHandling will be automatically stored in the 'requestBodyHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestBodyHandling(container: WebServiceCallAction): SimpleRequestHandling;
        /**
         * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
         * The new SimpleRequestHandling will be automatically stored in the 'requestHeaderHandling' property
         * of the parent WebServiceCallAction element passed as argument.
         */
        static createInWebServiceCallActionUnderRequestHeaderHandling(container: WebServiceCallAction): SimpleRequestHandling;
        /**
         * Creates and returns a new SimpleRequestHandling instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): SimpleRequestHandling;

    }
    interface ISort extends IListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Sort;
        load(callback: (element: Sort) => void, forceRefresh?: boolean): any;
    }
    class Sort extends ListOperation implements ISort {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;

        sortItemList: SortItemList;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Sort instance in the SDK and on the server.
         * The new Sort will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Sort;
        /**
         * Creates and returns a new Sort instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Sort;

    }
    /**
     * TODO
     */
    interface ISortItem extends internal.IElement {
        model: IModel;
        containerAsSortItemList: ISortItemList;
        load(): SortItem;
        load(callback: (element: SortItem) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class SortItem extends internal.Element implements ISortItem {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSortItemList: SortItemList;

        /**
         * The value of this property is conceptually of type paths.AttributePath.
         */
        attributePath: string;

        sortOrder: SortOrderEnum;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new SortItem instance in the SDK and on the server.
         * The new SortItem will be automatically stored in the 'items' property
         * of the parent SortItemList element passed as argument.
         */
        static createIn(container: SortItemList): SortItem;
        /**
         * Creates and returns a new SortItem instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): SortItem;

    }
    /**
     * TODO
     */
    interface ISortItemList extends internal.IElement {
        model: IModel;
        containerAsDatabaseRetrieveSource: IDatabaseRetrieveSource;
        containerAsSort: ISort;
        load(): SortItemList;
        load(callback: (element: SortItemList) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class SortItemList extends internal.Element implements ISortItemList {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsDatabaseRetrieveSource: DatabaseRetrieveSource;
        readonly containerAsSort: Sort;

        items: internal.IList<SortItem>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new SortItemList instance in the SDK and on the server.
         * The new SortItemList will be automatically stored in the 'sortItemList' property
         * of the parent DatabaseRetrieveSource element passed as argument.
         */
        static createInDatabaseRetrieveSourceUnderSortItemList(container: DatabaseRetrieveSource): SortItemList;
        /**
         * Creates and returns a new SortItemList instance in the SDK and on the server.
         * The new SortItemList will be automatically stored in the 'sortItemList' property
         * of the parent Sort element passed as argument.
         */
        static createInSortUnderSortItemList(container: Sort): SortItemList;
        /**
         * Creates and returns a new SortItemList instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): SortItemList;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/start-event relevant section in reference guide}
     */
    interface IStartEvent extends IMicroflowObject {
        model: IModel;
        containerAsMicroflowObjectCollection: IMicroflowObjectCollection;
        load(): StartEvent;
        load(callback: (element: StartEvent) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/start-event relevant section in reference guide}
     */
    class StartEvent extends MicroflowObject implements IStartEvent {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsMicroflowObjectCollection: MicroflowObjectCollection;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new StartEvent instance in the SDK and on the server.
         * The new StartEvent will be automatically stored in the 'objects' property
         * of the parent MicroflowObjectCollection element passed as argument.
         */
        static createIn(container: MicroflowObjectCollection): StartEvent;
        /**
         * Creates and returns a new StartEvent instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): StartEvent;

    }
    interface ITemplate extends internal.IElement {
        model: IModel;
        containerAsCustomRequestHandling: ICustomRequestHandling;
        containerAsHttpConfiguration: IHttpConfiguration;
        containerAsLogMessageAction: ILogMessageAction;
        containerAsShowMessageAction: IShowMessageAction;
        containerAsValidationFeedbackAction: IValidationFeedbackAction;
        load(): Template;
        load(callback: (element: Template) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    abstract class Template extends internal.Element implements ITemplate {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsCustomRequestHandling: CustomRequestHandling;
        readonly containerAsHttpConfiguration: HttpConfiguration;
        readonly containerAsLogMessageAction: LogMessageAction;
        readonly containerAsShowMessageAction: ShowMessageAction;
        readonly containerAsValidationFeedbackAction: ValidationFeedbackAction;

        arguments: internal.IList<TemplateArgument>;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO
     */
    interface IStringTemplate extends ITemplate {
        model: IModel;
        containerAsCustomRequestHandling: ICustomRequestHandling;
        containerAsHttpConfiguration: IHttpConfiguration;
        containerAsLogMessageAction: ILogMessageAction;
        load(): StringTemplate;
        load(callback: (element: StringTemplate) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class StringTemplate extends Template implements IStringTemplate {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsCustomRequestHandling: CustomRequestHandling;
        readonly containerAsHttpConfiguration: HttpConfiguration;
        readonly containerAsLogMessageAction: LogMessageAction;

        text: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new StringTemplate instance in the SDK and on the server.
         * The new StringTemplate will be automatically stored in the 'template' property
         * of the parent CustomRequestHandling element passed as argument.
         */
        static createInCustomRequestHandlingUnderTemplate(container: CustomRequestHandling): StringTemplate;
        /**
         * Creates and returns a new StringTemplate instance in the SDK and on the server.
         * The new StringTemplate will be automatically stored in the 'customLocationTemplate' property
         * of the parent HttpConfiguration element passed as argument.
         *
         * Warning! Can only be used on models with the following Mendix meta model versions:
         *  6.6.0, 6.7.0, 6.8.0, 6.9.0, 6.10.0, 7.0.0, 7.0.1
         */
        static createInHttpConfigurationUnderCustomLocationTemplate(container: HttpConfiguration): StringTemplate;
        /**
         * Creates and returns a new StringTemplate instance in the SDK and on the server.
         * The new StringTemplate will be automatically stored in the 'messageTemplate' property
         * of the parent LogMessageAction element passed as argument.
         */
        static createInLogMessageActionUnderMessageTemplate(container: LogMessageAction): StringTemplate;
        /**
         * Creates and returns a new StringTemplate instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): StringTemplate;

    }
    interface ISubtract extends IBinaryListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Subtract;
        load(callback: (element: Subtract) => void, forceRefresh?: boolean): any;
    }
    class Subtract extends BinaryListOperation implements ISubtract {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Subtract instance in the SDK and on the server.
         * The new Subtract will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Subtract;
        /**
         * Creates and returns a new Subtract instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Subtract;

    }
    interface ITail extends IListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Tail;
        load(callback: (element: Tail) => void, forceRefresh?: boolean): any;
    }
    class Tail extends ListOperation implements ITail {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Tail instance in the SDK and on the server.
         * The new Tail will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Tail;
        /**
         * Creates and returns a new Tail instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Tail;

    }
    /**
     * TODO
     */
    interface ITemplateArgument extends internal.IElement {
        model: IModel;
        containerAsTemplate: ITemplate;
        load(): TemplateArgument;
        load(callback: (element: TemplateArgument) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class TemplateArgument extends internal.Element implements ITemplateArgument {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsTemplate: Template;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        expression: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new TemplateArgument instance in the SDK and on the server.
         * The new TemplateArgument will be automatically stored in the 'arguments' property
         * of the parent Template element passed as argument.
         */
        static createIn(container: Template): TemplateArgument;
        /**
         * Creates and returns a new TemplateArgument instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): TemplateArgument;

    }
    /**
     * TODO
     */
    interface ITextTemplate extends ITemplate {
        model: IModel;
        containerAsShowMessageAction: IShowMessageAction;
        containerAsValidationFeedbackAction: IValidationFeedbackAction;
        load(): TextTemplate;
        load(callback: (element: TextTemplate) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class TextTemplate extends Template implements ITextTemplate {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsShowMessageAction: ShowMessageAction;
        readonly containerAsValidationFeedbackAction: ValidationFeedbackAction;

        text: texts.Text;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new TextTemplate instance in the SDK and on the server.
         * The new TextTemplate will be automatically stored in the 'template' property
         * of the parent ShowMessageAction element passed as argument.
         */
        static createInShowMessageActionUnderTemplate(container: ShowMessageAction): TextTemplate;
        /**
         * Creates and returns a new TextTemplate instance in the SDK and on the server.
         * The new TextTemplate will be automatically stored in the 'feedbackTemplate' property
         * of the parent ValidationFeedbackAction element passed as argument.
         */
        static createInValidationFeedbackActionUnderFeedbackTemplate(container: ValidationFeedbackAction): TextTemplate;
        /**
         * Creates and returns a new TextTemplate instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): TextTemplate;

    }
    interface IUnion extends IBinaryListOperation {
        model: IModel;
        containerAsListOperationAction: IListOperationAction;
        load(): Union;
        load(callback: (element: Union) => void, forceRefresh?: boolean): any;
    }
    class Union extends BinaryListOperation implements IUnion {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsListOperationAction: ListOperationAction;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new Union instance in the SDK and on the server.
         * The new Union will be automatically stored in the 'operation' property
         * of the parent ListOperationAction element passed as argument.
         */
        static createIn(container: ListOperationAction): Union;
        /**
         * Creates and returns a new Union instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): Union;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/validation-feedback relevant section in reference guide}
     */
    interface IValidationFeedbackAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): ValidationFeedbackAction;
        load(callback: (element: ValidationFeedbackAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/validation-feedback relevant section in reference guide}
     */
    class ValidationFeedbackAction extends MicroflowAction implements IValidationFeedbackAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        feedbackTemplate: TextTemplate;

        objectVariableName: string;

        /**
         * See: {@link https://docs.mendix.com/refguide7/validation-feedback See 'Member' section in reference guide}
         */
        attribute: domainmodels.IAttribute;
        readonly attributeQualifiedName: string;

        /**
         * See: {@link https://docs.mendix.com/refguide7/validation-feedback See 'Member' section in reference guide}
         */
        association: domainmodels.IAssociationBase;
        readonly associationQualifiedName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new ValidationFeedbackAction instance in the SDK and on the server.
         * The new ValidationFeedbackAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): ValidationFeedbackAction;
        /**
         * Creates and returns a new ValidationFeedbackAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): ValidationFeedbackAction;

    }
    /**
     * TODO
     */
    interface IVariableExport extends IOutputMethod {
        model: IModel;
        containerAsExportXmlAction: IExportXmlAction;
        load(): VariableExport;
        load(callback: (element: VariableExport) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class VariableExport extends OutputMethod implements IVariableExport {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsExportXmlAction: ExportXmlAction;

        outputVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new VariableExport instance in the SDK and on the server.
         * The new VariableExport will be automatically stored in the 'outputMethod' property
         * of the parent ExportXmlAction element passed as argument.
         */
        static createIn(container: ExportXmlAction): VariableExport;
        /**
         * Creates and returns a new VariableExport instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): VariableExport;

    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/call-web-service-action relevant section in reference guide}
     */
    interface IWebServiceCallAction extends IMicroflowAction {
        model: IModel;
        containerAsActionActivity: IActionActivity;
        load(): WebServiceCallAction;
        load(callback: (element: WebServiceCallAction) => void, forceRefresh?: boolean): any;
    }
    /**
     * See: {@link https://docs.mendix.com/refguide7/call-web-service-action relevant section in reference guide}
     */
    class WebServiceCallAction extends MicroflowAction implements IWebServiceCallAction {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsActionActivity: ActionActivity;

        importedWebService: webservices.IImportedWebService;
        readonly importedWebServiceQualifiedName: string;

        serviceName: string;

        operationName: string;

        useRequestTimeOut: boolean;

        timeOut: number;

        /**
         * In version 6.7.0: deleted
         */
        sendNullValueChoice: NullValueOption;

        requestHeaderHandling: RequestHandling;

        requestBodyHandling: RequestHandling;

        resultHandling: ResultHandling;

        httpConfiguration: HttpConfiguration;

        isValidationRequired: boolean;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new WebServiceCallAction instance in the SDK and on the server.
         * The new WebServiceCallAction will be automatically stored in the 'action' property
         * of the parent ActionActivity element passed as argument.
         */
        static createIn(container: ActionActivity): WebServiceCallAction;
        /**
         * Creates and returns a new WebServiceCallAction instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): WebServiceCallAction;

    }
    /**
     * In version 6.3.0: introduced
     */
    interface IWebServiceOperationParameterMapping extends internal.IElement {
        model: IModel;
        containerAsAdvancedRequestHandling: IAdvancedRequestHandling;
        containerAsSimpleRequestHandling: ISimpleRequestHandling;
        load(): WebServiceOperationParameterMapping;
        load(callback: (element: WebServiceOperationParameterMapping) => void, forceRefresh?: boolean): any;
    }
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

     *
     * In version 6.3.0: introduced
     */
    abstract class WebServiceOperationParameterMapping extends internal.Element implements IWebServiceOperationParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAdvancedRequestHandling: AdvancedRequestHandling;
        readonly containerAsSimpleRequestHandling: SimpleRequestHandling;

        isChecked: boolean;

        parameterName: string;

        /**
         * The value of this property is conceptually of type microflowExpressions.MicroflowExpression.
         */
        argument: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);

    }
    /**
     * TODO
     */
    interface IWebServiceOperationAdvancedParameterMapping extends IWebServiceOperationParameterMapping {
        model: IModel;
        containerAsAdvancedRequestHandling: IAdvancedRequestHandling;
        load(): WebServiceOperationAdvancedParameterMapping;
        load(callback: (element: WebServiceOperationAdvancedParameterMapping) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class WebServiceOperationAdvancedParameterMapping extends WebServiceOperationParameterMapping implements IWebServiceOperationAdvancedParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsAdvancedRequestHandling: AdvancedRequestHandling;

        mapping: exportmappings.IExportMapping;
        readonly mappingQualifiedName: string;

        mappingArgumentVariableName: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new WebServiceOperationAdvancedParameterMapping instance in the SDK and on the server.
         * The new WebServiceOperationAdvancedParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent AdvancedRequestHandling element passed as argument.
         */
        static createIn(container: AdvancedRequestHandling): WebServiceOperationAdvancedParameterMapping;
        /**
         * Creates and returns a new WebServiceOperationAdvancedParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): WebServiceOperationAdvancedParameterMapping;

    }
    /**
     * TODO
     */
    interface IWebServiceOperationSimpleParameterMapping extends IWebServiceOperationParameterMapping {
        model: IModel;
        containerAsSimpleRequestHandling: ISimpleRequestHandling;
        load(): WebServiceOperationSimpleParameterMapping;
        load(callback: (element: WebServiceOperationSimpleParameterMapping) => void, forceRefresh?: boolean): any;
    }
    /**
     * TODO
     */
    class WebServiceOperationSimpleParameterMapping extends WebServiceOperationParameterMapping implements IWebServiceOperationSimpleParameterMapping {
        static typeName: string;
        static versionInfo: StructureVersionInfo;
        model: IModel;
        readonly containerAsSimpleRequestHandling: SimpleRequestHandling;

        /**
         * The value of this property is conceptually of type mappings.ElementPath.
         */
        parameterPath: string;
        constructor(model: internal.AbstractModel, typeName: string, id: string, isPartial: boolean, unit: internal.ModelUnit, container: internal.AbstractElement);
        /**
         * Creates and returns a new WebServiceOperationSimpleParameterMapping instance in the SDK and on the server.
         * The new WebServiceOperationSimpleParameterMapping will be automatically stored in the 'parameterMappings' property
         * of the parent SimpleRequestHandling element passed as argument.
         */
        static createIn(container: SimpleRequestHandling): WebServiceOperationSimpleParameterMapping;
        /**
         * Creates and returns a new WebServiceOperationSimpleParameterMapping instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        static create(model: IModel): WebServiceOperationSimpleParameterMapping;

    }
}
import { appservices } from "./appservices";
import { documenttemplates } from "./documenttemplates";
import { domainmodels } from "./domainmodels";
import { exportmappings } from "./exportmappings";
import { importmappings } from "./importmappings";
import { javaactions } from "./javaactions";
import { pages } from "./pages";
import { security } from "./security";
import { texts } from "./texts";
import { webservices } from "./webservices";
import { IModel } from "./base-model";
