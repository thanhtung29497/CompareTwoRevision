/* tslint:disable */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var internal = require("../sdk/internal");
exports.StructureVersionInfo = internal.StructureVersionInfo;
var utils_1 = require("../sdk/utils");
var projects_1 = require("./projects");
var domainmodels;
(function (domainmodels) {
    var ActionMoment = (function (_super) {
        __extends(ActionMoment, _super);
        function ActionMoment() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.ActionMoment";
            return _this;
        }
        return ActionMoment;
    }(internal.IEnum));
    ActionMoment.Before = new ActionMoment("Before", {});
    ActionMoment.After = new ActionMoment("After", {});
    domainmodels.ActionMoment = ActionMoment;
    var AssociationOwner = (function (_super) {
        __extends(AssociationOwner, _super);
        function AssociationOwner() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.AssociationOwner";
            return _this;
        }
        return AssociationOwner;
    }(internal.IEnum));
    AssociationOwner.Default = new AssociationOwner("Default", {});
    AssociationOwner.Both = new AssociationOwner("Both", {});
    domainmodels.AssociationOwner = AssociationOwner;
    var AssociationType = (function (_super) {
        __extends(AssociationType, _super);
        function AssociationType() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.AssociationType";
            return _this;
        }
        return AssociationType;
    }(internal.IEnum));
    AssociationType.Reference = new AssociationType("Reference", {});
    AssociationType.ReferenceSet = new AssociationType("ReferenceSet", {});
    domainmodels.AssociationType = AssociationType;
    var DeletingBehavior = (function (_super) {
        __extends(DeletingBehavior, _super);
        function DeletingBehavior() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.DeletingBehavior";
            return _this;
        }
        return DeletingBehavior;
    }(internal.IEnum));
    DeletingBehavior.DeleteMeAndReferences = new DeletingBehavior("DeleteMeAndReferences", {});
    DeletingBehavior.DeleteMeButKeepReferences = new DeletingBehavior("DeleteMeButKeepReferences", {});
    DeletingBehavior.DeleteMeIfNoReferences = new DeletingBehavior("DeleteMeIfNoReferences", {});
    domainmodels.DeletingBehavior = DeletingBehavior;
    var EventType = (function (_super) {
        __extends(EventType, _super);
        function EventType() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.EventType";
            return _this;
        }
        return EventType;
    }(internal.IEnum));
    EventType.Create = new EventType("Create", {});
    EventType.Commit = new EventType("Commit", {});
    EventType.Delete = new EventType("Delete", {});
    EventType.RollBack = new EventType("RollBack", {});
    domainmodels.EventType = EventType;
    var IndexedAttributeType = (function (_super) {
        __extends(IndexedAttributeType, _super);
        function IndexedAttributeType() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.IndexedAttributeType";
            return _this;
        }
        return IndexedAttributeType;
    }(internal.IEnum));
    IndexedAttributeType.Normal = new IndexedAttributeType("Normal", {});
    IndexedAttributeType.CreatedDate = new IndexedAttributeType("CreatedDate", {});
    IndexedAttributeType.ChangedDate = new IndexedAttributeType("ChangedDate", {});
    domainmodels.IndexedAttributeType = IndexedAttributeType;
    var MemberAccessRights = (function (_super) {
        __extends(MemberAccessRights, _super);
        function MemberAccessRights() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.MemberAccessRights";
            return _this;
        }
        return MemberAccessRights;
    }(internal.IEnum));
    MemberAccessRights.None = new MemberAccessRights("None", {});
    MemberAccessRights.ReadOnly = new MemberAccessRights("ReadOnly", {});
    MemberAccessRights.ReadWrite = new MemberAccessRights("ReadWrite", {});
    domainmodels.MemberAccessRights = MemberAccessRights;
    var RangeType = (function (_super) {
        __extends(RangeType, _super);
        function RangeType() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.qualifiedTsTypeName = "domainmodels.RangeType";
            return _this;
        }
        return RangeType;
    }(internal.IEnum));
    RangeType.GreaterThanOrEqualTo = new RangeType("GreaterThanOrEqualTo", {});
    RangeType.SmallerThanOrEqualTo = new RangeType("SmallerThanOrEqualTo", {});
    RangeType.Between = new RangeType("Between", {});
    domainmodels.RangeType = RangeType;
    /**
     * See: {@link https://docs.mendix.com/refguide7/access-rules relevant section in reference guide}
     */
    var AccessRule = (function (_super) {
        __extends(AccessRule, _super);
        function AccessRule(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__memberAccesses = new internal.PartListProperty(AccessRule, _this, "memberAccesses", []);
            _this.__moduleRoles = new internal.ByNameReferenceListProperty(AccessRule, _this, "moduleRoles", [], "Security$ModuleRole");
            _this.__documentation = new internal.PrimitiveProperty(AccessRule, _this, "documentation", "", internal.PrimitiveTypeEnum.String);
            _this.__allowCreate = new internal.PrimitiveProperty(AccessRule, _this, "allowCreate", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__allowDelete = new internal.PrimitiveProperty(AccessRule, _this, "allowDelete", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__defaultMemberAccessRights = new internal.EnumProperty(AccessRule, _this, "defaultMemberAccessRights", MemberAccessRights.None, MemberAccessRights);
            _this.__xPathConstraint = new internal.PrimitiveProperty(AccessRule, _this, "xPathConstraint", "", internal.PrimitiveTypeEnum.String);
            if (arguments.length < 4) {
                throw new Error("new AccessRule() cannot be invoked directly, please use 'model.domainmodels.createAccessRule()'");
            }
            return _this;
        }
        Object.defineProperty(AccessRule.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "containerAsAccessRuleContainerBase", {
            get: function () { return _super.prototype.getContainerAs.call(this, security_1.security.AccessRuleContainerBase); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "memberAccesses", {
            get: function () { return this.__memberAccesses.get(); },
            set: function (newValue) { this.__memberAccesses.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "moduleRoles", {
            get: function () { return this.__moduleRoles.get(); },
            set: function (newValue) { this.__moduleRoles.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "moduleRolesQualifiedNames", {
            get: function () { return this.__moduleRoles.qualifiedNames(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "documentation", {
            get: function () { return this.__documentation.get(); },
            set: function (newValue) { this.__documentation.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "allowCreate", {
            get: function () { return this.__allowCreate.get(); },
            set: function (newValue) { this.__allowCreate.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "allowDelete", {
            get: function () { return this.__allowDelete.get(); },
            set: function (newValue) { this.__allowDelete.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "defaultMemberAccessRights", {
            get: function () { return this.__defaultMemberAccessRights.get(); },
            set: function (newValue) { this.__defaultMemberAccessRights.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AccessRule.prototype, "xPathConstraint", {
            /**
             * The value of this property is conceptually of type xPathConstraints.XPathConstraint.
             */
            get: function () { return this.__xPathConstraint.get(); },
            set: function (newValue) { this.__xPathConstraint.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * The new AccessRule will be automatically stored in the 'accessRules' property
         * of the parent Entity element passed as argument.
         */
        AccessRule.createInEntityUnderAccessRules = function (container) {
            return internal.instancehelpers.createElement(container, AccessRule, "accessRules", true);
        };
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * The new AccessRule will be automatically stored in the 'accessRules' property
         * of the parent security.AccessRuleContainerBase element passed as argument.
         */
        AccessRule.createInAccessRuleContainerBaseUnderAccessRules = function (container) {
            return internal.instancehelpers.createElement(container, AccessRule, "accessRules", true);
        };
        /**
         * Creates and returns a new AccessRule instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        AccessRule.create = function (model) {
            return internal.instancehelpers.createElement(model, AccessRule);
        };
        AccessRule.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.defaultMemberAccessRights = MemberAccessRights.None;
        };
        return AccessRule;
    }(internal.Element));
    AccessRule.typeName = "DomainModels$AccessRule";
    AccessRule.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.AccessRule = AccessRule;
    /**
     * See: {@link https://docs.mendix.com/refguide7/annotations relevant section in reference guide}
     */
    var Annotation = (function (_super) {
        __extends(Annotation, _super);
        function Annotation(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__caption = new internal.PrimitiveProperty(Annotation, _this, "caption", "", internal.PrimitiveTypeEnum.String);
            _this.__location = new internal.PrimitiveProperty(Annotation, _this, "location", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
            _this.__width = new internal.PrimitiveProperty(Annotation, _this, "width", 0, internal.PrimitiveTypeEnum.Integer);
            if (arguments.length < 4) {
                throw new Error("new Annotation() cannot be invoked directly, please use 'model.domainmodels.createAnnotation()'");
            }
            return _this;
        }
        Object.defineProperty(Annotation.prototype, "containerAsDomainModel", {
            get: function () { return _super.prototype.getContainerAs.call(this, DomainModel); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Annotation.prototype, "caption", {
            get: function () { return this.__caption.get(); },
            set: function (newValue) { this.__caption.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Annotation.prototype, "location", {
            get: function () { return this.__location.get(); },
            set: function (newValue) { this.__location.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Annotation.prototype, "width", {
            get: function () { return this.__width.get(); },
            set: function (newValue) { this.__width.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * The new Annotation will be automatically stored in the 'annotations' property
         * of the parent DomainModel element passed as argument.
         */
        Annotation.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Annotation, "annotations", true);
        };
        /**
         * Creates and returns a new Annotation instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Annotation.create = function (model) {
            return internal.instancehelpers.createElement(model, Annotation);
        };
        Annotation.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.width = 250;
        };
        return Annotation;
    }(internal.Element));
    Annotation.typeName = "DomainModels$Annotation";
    Annotation.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.Annotation = Annotation;
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations TODO: This is whre it belongs, but the word AssociationBase is never used}
     *
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var AssociationBase = (function (_super) {
        __extends(AssociationBase, _super);
        function AssociationBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__name = new internal.PrimitiveProperty(AssociationBase, _this, "name", "", internal.PrimitiveTypeEnum.String);
            _this.__dataStorageGuid = new internal.PrimitiveProperty(AssociationBase, _this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
            _this.__type = new internal.EnumProperty(AssociationBase, _this, "type", AssociationType.Reference, AssociationType);
            _this.__owner = new internal.EnumProperty(AssociationBase, _this, "owner", AssociationOwner.Default, AssociationOwner);
            _this.__deleteBehavior = new internal.PartProperty(AssociationBase, _this, "deleteBehavior", null, true);
            _this.__parent = new internal.ByIdReferenceProperty(AssociationBase, _this, "parent", null);
            _this.__documentation = new internal.PrimitiveProperty(AssociationBase, _this, "documentation", "", internal.PrimitiveTypeEnum.String);
            if (arguments.length < 4) {
                throw new Error("new AssociationBase() cannot be invoked directly, please use 'model.domainmodels.createAssociationBase()'");
            }
            return _this;
        }
        Object.defineProperty(AssociationBase.prototype, "containerAsDomainModel", {
            get: function () { return _super.prototype.getContainerAs.call(this, DomainModel); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "name", {
            get: function () { return this.__name.get(); },
            set: function (newValue) { this.__name.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "dataStorageGuid", {
            get: function () { return this.__dataStorageGuid.get(); },
            set: function (newValue) { this.__dataStorageGuid.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "type", {
            get: function () { return this.__type.get(); },
            set: function (newValue) { this.__type.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "owner", {
            get: function () { return this.__owner.get(); },
            set: function (newValue) { this.__owner.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "deleteBehavior", {
            get: function () { return this.__deleteBehavior.get(); },
            set: function (newValue) { this.__deleteBehavior.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "parent", {
            get: function () { return this.__parent.get(); },
            set: function (newValue) { this.__parent.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationBase.prototype, "documentation", {
            get: function () { return this.__documentation.get(); },
            set: function (newValue) { this.__documentation.set(newValue); },
            enumerable: true,
            configurable: true
        });
        AssociationBase.prototype._isByNameReferrable = function () { return true; };
        AssociationBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.dataStorageGuid = utils_1.utils.randomUuid();
            this.deleteBehavior = AssociationDeleteBehavior.create(this.model);
            this.owner = AssociationOwner.Default;
            this.type = AssociationType.Reference;
        };
        return AssociationBase;
    }(internal.Element));
    AssociationBase.typeName = "DomainModels$AssociationBase";
    AssociationBase.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "name": {
                "public": {
                    "currentValue": true
                }
            },
            "type": {
                "public": {
                    "currentValue": true
                }
            },
            "owner": {
                "public": {
                    "currentValue": true
                }
            },
            "deleteBehavior": {
                "required": {
                    "currentValue": true
                }
            },
            "parent": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.AssociationBase = AssociationBase;
    /**
     * See: {@link https://docs.mendix.com/refguide7/associations relevant section in reference guide}
     */
    var Association = (function (_super) {
        __extends(Association, _super);
        function Association(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__child = new internal.ByIdReferenceProperty(Association, _this, "child", null);
            _this.__parentConnection = new internal.PrimitiveProperty(Association, _this, "parentConnection", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
            _this.__childConnection = new internal.PrimitiveProperty(Association, _this, "childConnection", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
            if (arguments.length < 4) {
                throw new Error("new Association() cannot be invoked directly, please use 'model.domainmodels.createAssociation()'");
            }
            return _this;
        }
        Object.defineProperty(Association.prototype, "containerAsDomainModel", {
            get: function () { return _super.prototype.getContainerAs.call(this, DomainModel); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Association.prototype, "child", {
            get: function () { return this.__child.get(); },
            set: function (newValue) { this.__child.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Association.prototype, "parentConnection", {
            get: function () { return this.__parentConnection.get(); },
            set: function (newValue) { this.__parentConnection.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Association.prototype, "childConnection", {
            get: function () { return this.__childConnection.get(); },
            set: function (newValue) { this.__childConnection.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Association instance in the SDK and on the server.
         * The new Association will be automatically stored in the 'associations' property
         * of the parent DomainModel element passed as argument.
         */
        Association.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Association, "associations", true);
        };
        /**
         * Creates and returns a new Association instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Association.create = function (model) {
            return internal.instancehelpers.createElement(model, Association);
        };
        Association.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return Association;
    }(AssociationBase));
    Association.typeName = "DomainModels$Association";
    Association.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "child": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.Association = Association;
    var AssociationDeleteBehavior = (function (_super) {
        __extends(AssociationDeleteBehavior, _super);
        function AssociationDeleteBehavior(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__parentDeleteBehavior = new internal.EnumProperty(AssociationDeleteBehavior, _this, "parentDeleteBehavior", DeletingBehavior.DeleteMeButKeepReferences, DeletingBehavior);
            _this.__childDeleteBehavior = new internal.EnumProperty(AssociationDeleteBehavior, _this, "childDeleteBehavior", DeletingBehavior.DeleteMeButKeepReferences, DeletingBehavior);
            _this.__parentErrorMessage = new internal.PartProperty(AssociationDeleteBehavior, _this, "parentErrorMessage", null, false);
            _this.__childErrorMessage = new internal.PartProperty(AssociationDeleteBehavior, _this, "childErrorMessage", null, false);
            if (arguments.length < 4) {
                throw new Error("new AssociationDeleteBehavior() cannot be invoked directly, please use 'model.domainmodels.createAssociationDeleteBehavior()'");
            }
            return _this;
        }
        Object.defineProperty(AssociationDeleteBehavior.prototype, "containerAsAssociationBase", {
            get: function () { return _super.prototype.getContainerAs.call(this, AssociationBase); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationDeleteBehavior.prototype, "parentDeleteBehavior", {
            get: function () { return this.__parentDeleteBehavior.get(); },
            set: function (newValue) { this.__parentDeleteBehavior.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationDeleteBehavior.prototype, "childDeleteBehavior", {
            get: function () { return this.__childDeleteBehavior.get(); },
            set: function (newValue) { this.__childDeleteBehavior.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationDeleteBehavior.prototype, "parentErrorMessage", {
            get: function () { return this.__parentErrorMessage.get(); },
            set: function (newValue) { this.__parentErrorMessage.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AssociationDeleteBehavior.prototype, "childErrorMessage", {
            get: function () { return this.__childErrorMessage.get(); },
            set: function (newValue) { this.__childErrorMessage.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
         * The new AssociationDeleteBehavior will be automatically stored in the 'deleteBehavior' property
         * of the parent AssociationBase element passed as argument.
         */
        AssociationDeleteBehavior.createIn = function (container) {
            return internal.instancehelpers.createElement(container, AssociationDeleteBehavior, "deleteBehavior", false);
        };
        /**
         * Creates and returns a new AssociationDeleteBehavior instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        AssociationDeleteBehavior.create = function (model) {
            return internal.instancehelpers.createElement(model, AssociationDeleteBehavior);
        };
        AssociationDeleteBehavior.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.childDeleteBehavior = DeletingBehavior.DeleteMeButKeepReferences;
            this.parentDeleteBehavior = DeletingBehavior.DeleteMeButKeepReferences;
        };
        return AssociationDeleteBehavior;
    }(internal.Element));
    AssociationDeleteBehavior.typeName = "DomainModels$AssociationDeleteBehavior";
    AssociationDeleteBehavior.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.AssociationDeleteBehavior = AssociationDeleteBehavior;
    /**
     * See: {@link https://docs.mendix.com/refguide7/attributes relevant section in reference guide}
     */
    var Attribute = (function (_super) {
        __extends(Attribute, _super);
        function Attribute(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__name = new internal.PrimitiveProperty(Attribute, _this, "name", "", internal.PrimitiveTypeEnum.String);
            _this.__dataStorageGuid = new internal.PrimitiveProperty(Attribute, _this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
            _this.__type = new internal.PartProperty(Attribute, _this, "type", null, true);
            _this.__documentation = new internal.PrimitiveProperty(Attribute, _this, "documentation", "", internal.PrimitiveTypeEnum.String);
            _this.__value = new internal.PartProperty(Attribute, _this, "value", null, true);
            if (arguments.length < 4) {
                throw new Error("new Attribute() cannot be invoked directly, please use 'model.domainmodels.createAttribute()'");
            }
            return _this;
        }
        Object.defineProperty(Attribute.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attribute.prototype, "name", {
            get: function () { return this.__name.get(); },
            set: function (newValue) { this.__name.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attribute.prototype, "dataStorageGuid", {
            get: function () { return this.__dataStorageGuid.get(); },
            set: function (newValue) { this.__dataStorageGuid.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attribute.prototype, "type", {
            get: function () { return this.__type.get(); },
            set: function (newValue) { this.__type.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attribute.prototype, "documentation", {
            get: function () { return this.__documentation.get(); },
            set: function (newValue) { this.__documentation.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attribute.prototype, "value", {
            /**
             * In version 6.6.0: added public
             */
            get: function () { return this.__value.get(); },
            set: function (newValue) { this.__value.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * The new Attribute will be automatically stored in the 'attributes' property
         * of the parent Entity element passed as argument.
         */
        Attribute.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Attribute, "attributes", true);
        };
        /**
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Attribute.create = function (model) {
            return internal.instancehelpers.createElement(model, Attribute);
        };
        Attribute.prototype._isByNameReferrable = function () { return true; };
        Attribute.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.dataStorageGuid = utils_1.utils.randomUuid();
            this.type = StringAttributeType.create(this.model);
            this.value = StoredValue.create(this.model);
        };
        return Attribute;
    }(internal.Element));
    Attribute.typeName = "DomainModels$Attribute";
    Attribute.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "name": {
                "public": {
                    "currentValue": true
                }
            },
            "type": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            },
            "value": {
                "public": {
                    "currentValue": true,
                    "changedIn": [
                        "6.6.0"
                    ]
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.Attribute = Attribute;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var AttributeType = (function (_super) {
        __extends(AttributeType, _super);
        function AttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new AttributeType() cannot be invoked directly, please use 'model.domainmodels.createAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(AttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        AttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return AttributeType;
    }(internal.Element));
    AttributeType.typeName = "DomainModels$AttributeType";
    AttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.AttributeType = AttributeType;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var NumericAttributeTypeBase = (function (_super) {
        __extends(NumericAttributeTypeBase, _super);
        function NumericAttributeTypeBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new NumericAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createNumericAttributeTypeBase()'");
            }
            return _this;
        }
        Object.defineProperty(NumericAttributeTypeBase.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        NumericAttributeTypeBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return NumericAttributeTypeBase;
    }(AttributeType));
    NumericAttributeTypeBase.typeName = "DomainModels$NumericAttributeTypeBase";
    NumericAttributeTypeBase.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.NumericAttributeTypeBase = NumericAttributeTypeBase;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var IntegerAttributeTypeBase = (function (_super) {
        __extends(IntegerAttributeTypeBase, _super);
        function IntegerAttributeTypeBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new IntegerAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createIntegerAttributeTypeBase()'");
            }
            return _this;
        }
        Object.defineProperty(IntegerAttributeTypeBase.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        IntegerAttributeTypeBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return IntegerAttributeTypeBase;
    }(NumericAttributeTypeBase));
    IntegerAttributeTypeBase.typeName = "DomainModels$IntegerAttributeTypeBase";
    IntegerAttributeTypeBase.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.IntegerAttributeTypeBase = IntegerAttributeTypeBase;
    var AutoNumberAttributeType = (function (_super) {
        __extends(AutoNumberAttributeType, _super);
        function AutoNumberAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new AutoNumberAttributeType() cannot be invoked directly, please use 'model.domainmodels.createAutoNumberAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(AutoNumberAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * The new AutoNumberAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        AutoNumberAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, AutoNumberAttributeType, "type", false);
        };
        /**
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        AutoNumberAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, AutoNumberAttributeType);
        };
        AutoNumberAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return AutoNumberAttributeType;
    }(IntegerAttributeTypeBase));
    AutoNumberAttributeType.typeName = "DomainModels$AutoNumberAttributeType";
    AutoNumberAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.AutoNumberAttributeType = AutoNumberAttributeType;
    var BinaryAttributeType = (function (_super) {
        __extends(BinaryAttributeType, _super);
        function BinaryAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new BinaryAttributeType() cannot be invoked directly, please use 'model.domainmodels.createBinaryAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(BinaryAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * The new BinaryAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        BinaryAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, BinaryAttributeType, "type", false);
        };
        /**
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        BinaryAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, BinaryAttributeType);
        };
        BinaryAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return BinaryAttributeType;
    }(AttributeType));
    BinaryAttributeType.typeName = "DomainModels$BinaryAttributeType";
    BinaryAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.BinaryAttributeType = BinaryAttributeType;
    var BooleanAttributeType = (function (_super) {
        __extends(BooleanAttributeType, _super);
        function BooleanAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new BooleanAttributeType() cannot be invoked directly, please use 'model.domainmodels.createBooleanAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(BooleanAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * The new BooleanAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        BooleanAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, BooleanAttributeType, "type", false);
        };
        /**
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        BooleanAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, BooleanAttributeType);
        };
        BooleanAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return BooleanAttributeType;
    }(AttributeType));
    BooleanAttributeType.typeName = "DomainModels$BooleanAttributeType";
    BooleanAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.BooleanAttributeType = BooleanAttributeType;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.

     *
     * In version 6.6.0: added public
     */
    var ValueType = (function (_super) {
        __extends(ValueType, _super);
        function ValueType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new ValueType() cannot be invoked directly, please use 'model.domainmodels.createValueType()'");
            }
            return _this;
        }
        Object.defineProperty(ValueType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        ValueType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return ValueType;
    }(internal.Element));
    ValueType.typeName = "DomainModels$ValueType";
    ValueType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true,
            "changedIn": [
                "6.6.0"
            ]
        }
    }, internal.StructureType.Element);
    domainmodels.ValueType = ValueType;
    /**
     * In version 6.6.0: added public
     */
    var CalculatedValue = (function (_super) {
        __extends(CalculatedValue, _super);
        function CalculatedValue(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__microflow = new internal.ByNameReferenceProperty(CalculatedValue, _this, "microflow", null, "Microflows$Microflow");
            _this.__passEntity = new internal.PrimitiveProperty(CalculatedValue, _this, "passEntity", false, internal.PrimitiveTypeEnum.Boolean);
            if (arguments.length < 4) {
                throw new Error("new CalculatedValue() cannot be invoked directly, please use 'model.domainmodels.createCalculatedValue()'");
            }
            return _this;
        }
        Object.defineProperty(CalculatedValue.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CalculatedValue.prototype, "microflow", {
            get: function () { return this.__microflow.get(); },
            set: function (newValue) { this.__microflow.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CalculatedValue.prototype, "microflowQualifiedName", {
            get: function () { return this.__microflow.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CalculatedValue.prototype, "passEntity", {
            get: function () { return this.__passEntity.get(); },
            set: function (newValue) { this.__passEntity.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new CalculatedValue instance in the SDK and on the server.
         * The new CalculatedValue will be automatically stored in the 'value' property
         * of the parent Attribute element passed as argument.
         */
        CalculatedValue.createIn = function (container) {
            return internal.instancehelpers.createElement(container, CalculatedValue, "value", false);
        };
        /**
         * Creates and returns a new CalculatedValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        CalculatedValue.create = function (model) {
            return internal.instancehelpers.createElement(model, CalculatedValue);
        };
        CalculatedValue.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.passEntity = true;
        };
        return CalculatedValue;
    }(ValueType));
    CalculatedValue.typeName = "DomainModels$CalculatedValue";
    CalculatedValue.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true,
            "changedIn": [
                "6.6.0"
            ]
        }
    }, internal.StructureType.Element);
    domainmodels.CalculatedValue = CalculatedValue;
    var CrossAssociation = (function (_super) {
        __extends(CrossAssociation, _super);
        function CrossAssociation(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__child = new internal.ByNameReferenceProperty(CrossAssociation, _this, "child", null, "DomainModels$Entity");
            if (arguments.length < 4) {
                throw new Error("new CrossAssociation() cannot be invoked directly, please use 'model.domainmodels.createCrossAssociation()'");
            }
            return _this;
        }
        Object.defineProperty(CrossAssociation.prototype, "containerAsDomainModel", {
            get: function () { return _super.prototype.getContainerAs.call(this, DomainModel); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CrossAssociation.prototype, "child", {
            get: function () { return this.__child.get(); },
            set: function (newValue) { this.__child.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CrossAssociation.prototype, "childQualifiedName", {
            get: function () { return this.__child.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new CrossAssociation instance in the SDK and on the server.
         * The new CrossAssociation will be automatically stored in the 'crossAssociations' property
         * of the parent DomainModel element passed as argument.
         */
        CrossAssociation.createIn = function (container) {
            return internal.instancehelpers.createElement(container, CrossAssociation, "crossAssociations", true);
        };
        /**
         * Creates and returns a new CrossAssociation instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        CrossAssociation.create = function (model) {
            return internal.instancehelpers.createElement(model, CrossAssociation);
        };
        CrossAssociation.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return CrossAssociation;
    }(AssociationBase));
    CrossAssociation.typeName = "DomainModels$CrossAssociation";
    CrossAssociation.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "child": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.CrossAssociation = CrossAssociation;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var DecimalAttributeTypeBase = (function (_super) {
        __extends(DecimalAttributeTypeBase, _super);
        function DecimalAttributeTypeBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new DecimalAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createDecimalAttributeTypeBase()'");
            }
            return _this;
        }
        Object.defineProperty(DecimalAttributeTypeBase.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        DecimalAttributeTypeBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return DecimalAttributeTypeBase;
    }(NumericAttributeTypeBase));
    DecimalAttributeTypeBase.typeName = "DomainModels$DecimalAttributeTypeBase";
    DecimalAttributeTypeBase.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.DecimalAttributeTypeBase = DecimalAttributeTypeBase;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var FloatAttributeTypeBase = (function (_super) {
        __extends(FloatAttributeTypeBase, _super);
        function FloatAttributeTypeBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new FloatAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels.createFloatAttributeTypeBase()'");
            }
            return _this;
        }
        Object.defineProperty(FloatAttributeTypeBase.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        FloatAttributeTypeBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return FloatAttributeTypeBase;
    }(DecimalAttributeTypeBase));
    FloatAttributeTypeBase.typeName = "DomainModels$FloatAttributeTypeBase";
    FloatAttributeTypeBase.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.FloatAttributeTypeBase = FloatAttributeTypeBase;
    /**
     * In version 6.0.0: deprecated
     */
    var CurrencyAttributeType = (function (_super) {
        __extends(CurrencyAttributeType, _super);
        function CurrencyAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new CurrencyAttributeType() cannot be invoked directly, please use 'model.domainmodels.createCurrencyAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(CurrencyAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * The new CurrencyAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        CurrencyAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, CurrencyAttributeType, "type", false);
        };
        /**
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        CurrencyAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, CurrencyAttributeType);
        };
        CurrencyAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return CurrencyAttributeType;
    }(FloatAttributeTypeBase));
    CurrencyAttributeType.typeName = "DomainModels$CurrencyAttributeType";
    CurrencyAttributeType.versionInfo = new exports.StructureVersionInfo({
        "deprecated": "6.0.0",
        "deprecationMessage": "CurrencyAttributeType has been deprecated. Please use DecimalAttributeType instead.",
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.CurrencyAttributeType = CurrencyAttributeType;
    var DateTimeAttributeType = (function (_super) {
        __extends(DateTimeAttributeType, _super);
        function DateTimeAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__localizeDate = new internal.PrimitiveProperty(DateTimeAttributeType, _this, "localizeDate", false, internal.PrimitiveTypeEnum.Boolean);
            if (arguments.length < 4) {
                throw new Error("new DateTimeAttributeType() cannot be invoked directly, please use 'model.domainmodels.createDateTimeAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(DateTimeAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimeAttributeType.prototype, "localizeDate", {
            get: function () { return this.__localizeDate.get(); },
            set: function (newValue) { this.__localizeDate.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * The new DateTimeAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        DateTimeAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, DateTimeAttributeType, "type", false);
        };
        /**
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        DateTimeAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, DateTimeAttributeType);
        };
        DateTimeAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.localizeDate = true;
        };
        return DateTimeAttributeType;
    }(AttributeType));
    DateTimeAttributeType.typeName = "DomainModels$DateTimeAttributeType";
    DateTimeAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.DateTimeAttributeType = DateTimeAttributeType;
    var DecimalAttributeType = (function (_super) {
        __extends(DecimalAttributeType, _super);
        function DecimalAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new DecimalAttributeType() cannot be invoked directly, please use 'model.domainmodels.createDecimalAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(DecimalAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * The new DecimalAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        DecimalAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, DecimalAttributeType, "type", false);
        };
        /**
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        DecimalAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, DecimalAttributeType);
        };
        DecimalAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return DecimalAttributeType;
    }(DecimalAttributeTypeBase));
    DecimalAttributeType.typeName = "DomainModels$DecimalAttributeType";
    DecimalAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.DecimalAttributeType = DecimalAttributeType;
    /**
     * See: {@link https://docs.mendix.com/refguide7/domain-model relevant section in reference guide}
     */
    var DomainModel = (function (_super) {
        __extends(DomainModel, _super);
        function DomainModel(model, typeName, id, isPartial, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, container) || this;
            _this.__documentation = new internal.PrimitiveProperty(DomainModel, _this, "documentation", "", internal.PrimitiveTypeEnum.String);
            _this.__entities = new internal.PartListProperty(DomainModel, _this, "entities", []);
            _this.__annotations = new internal.PartListProperty(DomainModel, _this, "annotations", []);
            _this.__associations = new internal.PartListProperty(DomainModel, _this, "associations", []);
            _this.__crossAssociations = new internal.PartListProperty(DomainModel, _this, "crossAssociations", []);
            _this._containmentName = "domainModel";
            return _this;
        }
        Object.defineProperty(DomainModel.prototype, "containerAsModule", {
            get: function () { return _super.prototype.getContainerAs.call(this, projects_1.projects.Module); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DomainModel.prototype, "documentation", {
            get: function () { return this.__documentation.get(); },
            set: function (newValue) { this.__documentation.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DomainModel.prototype, "entities", {
            get: function () { return this.__entities.get(); },
            set: function (newValue) { this.__entities.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DomainModel.prototype, "annotations", {
            get: function () { return this.__annotations.get(); },
            set: function (newValue) { this.__annotations.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DomainModel.prototype, "associations", {
            get: function () { return this.__associations.get(); },
            set: function (newValue) { this.__associations.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DomainModel.prototype, "crossAssociations", {
            get: function () { return this.__crossAssociations.get(); },
            set: function (newValue) { this.__crossAssociations.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a new DomainModel unit in the SDK and on the server.
         * Expects one argument, the projects.IModule in which this unit is contained.
         */
        DomainModel.createIn = function (container) {
            return internal.instancehelpers.createUnit(container, DomainModel);
        };
        DomainModel.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return DomainModel;
    }(projects_1.projects.ModuleDocument));
    DomainModel.typeName = "DomainModels$DomainModel";
    DomainModel.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "entities": {
                "public": {
                    "currentValue": true
                }
            },
            "associations": {
                "public": {
                    "currentValue": true
                }
            },
            "crossAssociations": {
                "public": {
                    "currentValue": true
                }
            }
        }
    }, internal.StructureType.ModelUnit);
    domainmodels.DomainModel = DomainModel;
    /**
     * See: {@link https://docs.mendix.com/refguide7/entities relevant section in reference guide}
     */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        function Entity(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__name = new internal.PrimitiveProperty(Entity, _this, "name", "", internal.PrimitiveTypeEnum.String);
            _this.__dataStorageGuid = new internal.PrimitiveProperty(Entity, _this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
            _this.__location = new internal.PrimitiveProperty(Entity, _this, "location", { x: 0, y: 0 }, internal.PrimitiveTypeEnum.Point);
            _this.__documentation = new internal.PrimitiveProperty(Entity, _this, "documentation", "", internal.PrimitiveTypeEnum.String);
            _this.__generalization = new internal.PartProperty(Entity, _this, "generalization", null, true);
            _this.__attributes = new internal.PartListProperty(Entity, _this, "attributes", []);
            _this.__validationRules = new internal.PartListProperty(Entity, _this, "validationRules", []);
            _this.__eventHandlers = new internal.PartListProperty(Entity, _this, "eventHandlers", []);
            _this.__indexes = new internal.PartListProperty(Entity, _this, "indexes", []);
            _this.__accessRules = new internal.PartListProperty(Entity, _this, "accessRules", []);
            _this.__image = new internal.ByNameReferenceProperty(Entity, _this, "image", null, "Images$Image");
            if (arguments.length < 4) {
                throw new Error("new Entity() cannot be invoked directly, please use 'model.domainmodels.createEntity()'");
            }
            _this._declaredAsNamespace = true;
            return _this;
        }
        Object.defineProperty(Entity.prototype, "containerAsDomainModel", {
            get: function () { return _super.prototype.getContainerAs.call(this, DomainModel); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "name", {
            get: function () { return this.__name.get(); },
            set: function (newValue) { this.__name.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "dataStorageGuid", {
            get: function () { return this.__dataStorageGuid.get(); },
            set: function (newValue) { this.__dataStorageGuid.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "location", {
            get: function () { return this.__location.get(); },
            set: function (newValue) { this.__location.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "documentation", {
            get: function () { return this.__documentation.get(); },
            set: function (newValue) { this.__documentation.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "generalization", {
            get: function () { return this.__generalization.get(); },
            set: function (newValue) { this.__generalization.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "attributes", {
            get: function () { return this.__attributes.get(); },
            set: function (newValue) { this.__attributes.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "validationRules", {
            get: function () { return this.__validationRules.get(); },
            set: function (newValue) { this.__validationRules.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "eventHandlers", {
            get: function () { return this.__eventHandlers.get(); },
            set: function (newValue) { this.__eventHandlers.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "indexes", {
            get: function () { return this.__indexes.get(); },
            set: function (newValue) { this.__indexes.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "accessRules", {
            get: function () { return this.__accessRules.get(); },
            set: function (newValue) { this.__accessRules.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "image", {
            get: function () { return this.__image.get(); },
            set: function (newValue) { this.__image.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "imageQualifiedName", {
            get: function () { return this.__image.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Entity instance in the SDK and on the server.
         * The new Entity will be automatically stored in the 'entities' property
         * of the parent DomainModel element passed as argument.
         */
        Entity.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Entity, "entities", true);
        };
        /**
         * Creates and returns a new Entity instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Entity.create = function (model) {
            return internal.instancehelpers.createElement(model, Entity);
        };
        Entity.prototype._isByNameReferrable = function () { return true; };
        Entity.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.dataStorageGuid = utils_1.utils.randomUuid();
            this.generalization = NoGeneralization.create(this.model);
        };
        return Entity;
    }(internal.Element));
    Entity.typeName = "DomainModels$Entity";
    Entity.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "name": {
                "public": {
                    "currentValue": true
                }
            },
            "generalization": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            },
            "attributes": {
                "public": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.Entity = Entity;
    var EnumerationAttributeType = (function (_super) {
        __extends(EnumerationAttributeType, _super);
        function EnumerationAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__enumeration = new internal.ByNameReferenceProperty(EnumerationAttributeType, _this, "enumeration", null, "Enumerations$Enumeration");
            if (arguments.length < 4) {
                throw new Error("new EnumerationAttributeType() cannot be invoked directly, please use 'model.domainmodels.createEnumerationAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(EnumerationAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnumerationAttributeType.prototype, "enumeration", {
            get: function () { return this.__enumeration.get(); },
            set: function (newValue) { this.__enumeration.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnumerationAttributeType.prototype, "enumerationQualifiedName", {
            get: function () { return this.__enumeration.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
         * The new EnumerationAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        EnumerationAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, EnumerationAttributeType, "type", false);
        };
        /**
         * Creates and returns a new EnumerationAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        EnumerationAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, EnumerationAttributeType);
        };
        EnumerationAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return EnumerationAttributeType;
    }(AttributeType));
    EnumerationAttributeType.typeName = "DomainModels$EnumerationAttributeType";
    EnumerationAttributeType.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "enumeration": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.EnumerationAttributeType = EnumerationAttributeType;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var RuleInfo = (function (_super) {
        __extends(RuleInfo, _super);
        function RuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new RuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(RuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        RuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return RuleInfo;
    }(internal.Element));
    RuleInfo.typeName = "DomainModels$RuleInfo";
    RuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.RuleInfo = RuleInfo;
    var EqualsToRuleInfo = (function (_super) {
        __extends(EqualsToRuleInfo, _super);
        function EqualsToRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__useValue = new internal.PrimitiveProperty(EqualsToRuleInfo, _this, "useValue", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__equalsToValue = new internal.PrimitiveProperty(EqualsToRuleInfo, _this, "equalsToValue", "", internal.PrimitiveTypeEnum.String);
            _this.__equalsToAttribute = new internal.ByNameReferenceProperty(EqualsToRuleInfo, _this, "equalsToAttribute", null, "DomainModels$Attribute");
            if (arguments.length < 4) {
                throw new Error("new EqualsToRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createEqualsToRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(EqualsToRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EqualsToRuleInfo.prototype, "useValue", {
            get: function () { return this.__useValue.get(); },
            set: function (newValue) { this.__useValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EqualsToRuleInfo.prototype, "equalsToValue", {
            get: function () { return this.__equalsToValue.get(); },
            set: function (newValue) { this.__equalsToValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EqualsToRuleInfo.prototype, "equalsToAttribute", {
            get: function () { return this.__equalsToAttribute.get(); },
            set: function (newValue) { this.__equalsToAttribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EqualsToRuleInfo.prototype, "equalsToAttributeQualifiedName", {
            get: function () { return this.__equalsToAttribute.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
         * The new EqualsToRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        EqualsToRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, EqualsToRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new EqualsToRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        EqualsToRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, EqualsToRuleInfo);
        };
        EqualsToRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.useValue = true;
        };
        return EqualsToRuleInfo;
    }(RuleInfo));
    EqualsToRuleInfo.typeName = "DomainModels$EqualsToRuleInfo";
    EqualsToRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.EqualsToRuleInfo = EqualsToRuleInfo;
    /**
     * See: {@link https://docs.mendix.com/refguide7/event-handlers relevant section in reference guide}
     */
    var EventHandler = (function (_super) {
        __extends(EventHandler, _super);
        function EventHandler(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__moment = new internal.EnumProperty(EventHandler, _this, "moment", ActionMoment.After, ActionMoment);
            _this.__event = new internal.EnumProperty(EventHandler, _this, "event", EventType.Commit, EventType);
            _this.__microflow = new internal.ByNameReferenceProperty(EventHandler, _this, "microflow", null, "Microflows$Microflow");
            _this.__raiseErrorOnFalse = new internal.PrimitiveProperty(EventHandler, _this, "raiseErrorOnFalse", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__passEventObject = new internal.PrimitiveProperty(EventHandler, _this, "passEventObject", false, internal.PrimitiveTypeEnum.Boolean);
            if (arguments.length < 4) {
                throw new Error("new EventHandler() cannot be invoked directly, please use 'model.domainmodels.createEventHandler()'");
            }
            return _this;
        }
        Object.defineProperty(EventHandler.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "moment", {
            get: function () { return this.__moment.get(); },
            set: function (newValue) { this.__moment.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "event", {
            get: function () { return this.__event.get(); },
            set: function (newValue) { this.__event.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "microflow", {
            get: function () { return this.__microflow.get(); },
            set: function (newValue) { this.__microflow.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "microflowQualifiedName", {
            get: function () { return this.__microflow.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "raiseErrorOnFalse", {
            get: function () { return this.__raiseErrorOnFalse.get(); },
            set: function (newValue) { this.__raiseErrorOnFalse.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EventHandler.prototype, "passEventObject", {
            get: function () { return this.__passEventObject.get(); },
            set: function (newValue) { this.__passEventObject.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new EventHandler instance in the SDK and on the server.
         * The new EventHandler will be automatically stored in the 'eventHandlers' property
         * of the parent Entity element passed as argument.
         */
        EventHandler.createIn = function (container) {
            return internal.instancehelpers.createElement(container, EventHandler, "eventHandlers", true);
        };
        /**
         * Creates and returns a new EventHandler instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        EventHandler.create = function (model) {
            return internal.instancehelpers.createElement(model, EventHandler);
        };
        EventHandler.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.event = EventType.Commit;
            this.moment = ActionMoment.After;
            this.passEventObject = true;
            this.raiseErrorOnFalse = true;
        };
        return EventHandler;
    }(internal.Element));
    EventHandler.typeName = "DomainModels$EventHandler";
    EventHandler.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.EventHandler = EventHandler;
    /**
     * In version 6.0.0: deprecated
     */
    var FloatAttributeType = (function (_super) {
        __extends(FloatAttributeType, _super);
        function FloatAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new FloatAttributeType() cannot be invoked directly, please use 'model.domainmodels.createFloatAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(FloatAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * The new FloatAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        FloatAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, FloatAttributeType, "type", false);
        };
        /**
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        FloatAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, FloatAttributeType);
        };
        FloatAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return FloatAttributeType;
    }(FloatAttributeTypeBase));
    FloatAttributeType.typeName = "DomainModels$FloatAttributeType";
    FloatAttributeType.versionInfo = new exports.StructureVersionInfo({
        "deprecated": "6.0.0",
        "deprecationMessage": "FloatAttributeType has been deprecated. Please use DecimalAttributeType instead.",
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.FloatAttributeType = FloatAttributeType;
    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    var GeneralizationBase = (function (_super) {
        __extends(GeneralizationBase, _super);
        function GeneralizationBase(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new GeneralizationBase() cannot be invoked directly, please use 'model.domainmodels.createGeneralizationBase()'");
            }
            return _this;
        }
        Object.defineProperty(GeneralizationBase.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        GeneralizationBase.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return GeneralizationBase;
    }(internal.Element));
    GeneralizationBase.typeName = "DomainModels$GeneralizationBase";
    GeneralizationBase.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.GeneralizationBase = GeneralizationBase;
    var Generalization = (function (_super) {
        __extends(Generalization, _super);
        function Generalization(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__generalization = new internal.ByNameReferenceProperty(Generalization, _this, "generalization", null, "DomainModels$Entity");
            if (arguments.length < 4) {
                throw new Error("new Generalization() cannot be invoked directly, please use 'model.domainmodels.createGeneralization()'");
            }
            return _this;
        }
        Object.defineProperty(Generalization.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Generalization.prototype, "generalization", {
            get: function () { return this.__generalization.get(); },
            set: function (newValue) { this.__generalization.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Generalization.prototype, "generalizationQualifiedName", {
            get: function () { return this.__generalization.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Generalization instance in the SDK and on the server.
         * The new Generalization will be automatically stored in the 'generalization' property
         * of the parent Entity element passed as argument.
         */
        Generalization.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Generalization, "generalization", false);
        };
        /**
         * Creates and returns a new Generalization instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Generalization.create = function (model) {
            return internal.instancehelpers.createElement(model, Generalization);
        };
        Generalization.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return Generalization;
    }(GeneralizationBase));
    Generalization.typeName = "DomainModels$Generalization";
    Generalization.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "generalization": {
                "public": {
                    "currentValue": true
                },
                "required": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.Generalization = Generalization;
    var HashedStringAttributeType = (function (_super) {
        __extends(HashedStringAttributeType, _super);
        function HashedStringAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new HashedStringAttributeType() cannot be invoked directly, please use 'model.domainmodels.createHashedStringAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(HashedStringAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * The new HashedStringAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        HashedStringAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, HashedStringAttributeType, "type", false);
        };
        /**
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        HashedStringAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, HashedStringAttributeType);
        };
        HashedStringAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return HashedStringAttributeType;
    }(AttributeType));
    HashedStringAttributeType.typeName = "DomainModels$HashedStringAttributeType";
    HashedStringAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.HashedStringAttributeType = HashedStringAttributeType;
    /**
     * See: {@link https://docs.mendix.com/refguide7/indexes relevant section in reference guide}
     */
    var Index = (function (_super) {
        __extends(Index, _super);
        function Index(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__dataStorageGuid = new internal.PrimitiveProperty(Index, _this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
            _this.__attributes = new internal.PartListProperty(Index, _this, "attributes", []);
            if (arguments.length < 4) {
                throw new Error("new Index() cannot be invoked directly, please use 'model.domainmodels.createIndex()'");
            }
            return _this;
        }
        Object.defineProperty(Index.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Index.prototype, "dataStorageGuid", {
            get: function () { return this.__dataStorageGuid.get(); },
            set: function (newValue) { this.__dataStorageGuid.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Index.prototype, "attributes", {
            get: function () { return this.__attributes.get(); },
            set: function (newValue) { this.__attributes.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new Index instance in the SDK and on the server.
         * The new Index will be automatically stored in the 'indexes' property
         * of the parent Entity element passed as argument.
         */
        Index.createIn = function (container) {
            return internal.instancehelpers.createElement(container, Index, "indexes", true);
        };
        /**
         * Creates and returns a new Index instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        Index.create = function (model) {
            return internal.instancehelpers.createElement(model, Index);
        };
        Index.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.dataStorageGuid = utils_1.utils.randomUuid();
        };
        return Index;
    }(internal.Element));
    Index.typeName = "DomainModels$Index";
    Index.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.Index = Index;
    var IndexedAttribute = (function (_super) {
        __extends(IndexedAttribute, _super);
        function IndexedAttribute(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__type = new internal.EnumProperty(IndexedAttribute, _this, "type", IndexedAttributeType.Normal, IndexedAttributeType);
            _this.__attribute = new internal.ByIdReferenceProperty(IndexedAttribute, _this, "attribute", null);
            if (arguments.length < 4) {
                throw new Error("new IndexedAttribute() cannot be invoked directly, please use 'model.domainmodels.createIndexedAttribute()'");
            }
            return _this;
        }
        Object.defineProperty(IndexedAttribute.prototype, "containerAsIndex", {
            get: function () { return _super.prototype.getContainerAs.call(this, Index); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IndexedAttribute.prototype, "type", {
            get: function () { return this.__type.get(); },
            set: function (newValue) { this.__type.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IndexedAttribute.prototype, "attribute", {
            get: function () { return this.__attribute.get(); },
            set: function (newValue) { this.__attribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
         * The new IndexedAttribute will be automatically stored in the 'attributes' property
         * of the parent Index element passed as argument.
         */
        IndexedAttribute.createIn = function (container) {
            return internal.instancehelpers.createElement(container, IndexedAttribute, "attributes", true);
        };
        /**
         * Creates and returns a new IndexedAttribute instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        IndexedAttribute.create = function (model) {
            return internal.instancehelpers.createElement(model, IndexedAttribute);
        };
        IndexedAttribute.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.type = IndexedAttributeType.Normal;
        };
        return IndexedAttribute;
    }(internal.Element));
    IndexedAttribute.typeName = "DomainModels$IndexedAttribute";
    IndexedAttribute.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.IndexedAttribute = IndexedAttribute;
    var IntegerAttributeType = (function (_super) {
        __extends(IntegerAttributeType, _super);
        function IntegerAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new IntegerAttributeType() cannot be invoked directly, please use 'model.domainmodels.createIntegerAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(IntegerAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * The new IntegerAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        IntegerAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, IntegerAttributeType, "type", false);
        };
        /**
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        IntegerAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, IntegerAttributeType);
        };
        IntegerAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return IntegerAttributeType;
    }(IntegerAttributeTypeBase));
    IntegerAttributeType.typeName = "DomainModels$IntegerAttributeType";
    IntegerAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.IntegerAttributeType = IntegerAttributeType;
    var LongAttributeType = (function (_super) {
        __extends(LongAttributeType, _super);
        function LongAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new LongAttributeType() cannot be invoked directly, please use 'model.domainmodels.createLongAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(LongAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * The new LongAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        LongAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, LongAttributeType, "type", false);
        };
        /**
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        LongAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, LongAttributeType);
        };
        LongAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return LongAttributeType;
    }(IntegerAttributeTypeBase));
    LongAttributeType.typeName = "DomainModels$LongAttributeType";
    LongAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.LongAttributeType = LongAttributeType;
    var MaxLengthRuleInfo = (function (_super) {
        __extends(MaxLengthRuleInfo, _super);
        function MaxLengthRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__maxLength = new internal.PrimitiveProperty(MaxLengthRuleInfo, _this, "maxLength", 0, internal.PrimitiveTypeEnum.Integer);
            if (arguments.length < 4) {
                throw new Error("new MaxLengthRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createMaxLengthRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(MaxLengthRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaxLengthRuleInfo.prototype, "maxLength", {
            get: function () { return this.__maxLength.get(); },
            set: function (newValue) { this.__maxLength.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
         * The new MaxLengthRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        MaxLengthRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, MaxLengthRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new MaxLengthRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        MaxLengthRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, MaxLengthRuleInfo);
        };
        MaxLengthRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return MaxLengthRuleInfo;
    }(RuleInfo));
    MaxLengthRuleInfo.typeName = "DomainModels$MaxLengthRuleInfo";
    MaxLengthRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.MaxLengthRuleInfo = MaxLengthRuleInfo;
    var MemberAccess = (function (_super) {
        __extends(MemberAccess, _super);
        function MemberAccess(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__attribute = new internal.ByNameReferenceProperty(MemberAccess, _this, "attribute", null, "DomainModels$Attribute");
            _this.__association = new internal.ByNameReferenceProperty(MemberAccess, _this, "association", null, "DomainModels$AssociationBase");
            _this.__accessRights = new internal.EnumProperty(MemberAccess, _this, "accessRights", MemberAccessRights.None, MemberAccessRights);
            if (arguments.length < 4) {
                throw new Error("new MemberAccess() cannot be invoked directly, please use 'model.domainmodels.createMemberAccess()'");
            }
            return _this;
        }
        Object.defineProperty(MemberAccess.prototype, "containerAsAccessRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, AccessRule); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemberAccess.prototype, "attribute", {
            get: function () { return this.__attribute.get(); },
            set: function (newValue) { this.__attribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemberAccess.prototype, "attributeQualifiedName", {
            get: function () { return this.__attribute.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemberAccess.prototype, "association", {
            get: function () { return this.__association.get(); },
            set: function (newValue) { this.__association.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemberAccess.prototype, "associationQualifiedName", {
            get: function () { return this.__association.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MemberAccess.prototype, "accessRights", {
            get: function () { return this.__accessRights.get(); },
            set: function (newValue) { this.__accessRights.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new MemberAccess instance in the SDK and on the server.
         * The new MemberAccess will be automatically stored in the 'memberAccesses' property
         * of the parent AccessRule element passed as argument.
         */
        MemberAccess.createIn = function (container) {
            return internal.instancehelpers.createElement(container, MemberAccess, "memberAccesses", true);
        };
        /**
         * Creates and returns a new MemberAccess instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        MemberAccess.create = function (model) {
            return internal.instancehelpers.createElement(model, MemberAccess);
        };
        MemberAccess.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.accessRights = MemberAccessRights.None;
        };
        return MemberAccess;
    }(internal.Element));
    MemberAccess.typeName = "DomainModels$MemberAccess";
    MemberAccess.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.MemberAccess = MemberAccess;
    var NoGeneralization = (function (_super) {
        __extends(NoGeneralization, _super);
        function NoGeneralization(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__hasChangedDate = new internal.PrimitiveProperty(NoGeneralization, _this, "hasChangedDate", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__hasCreatedDate = new internal.PrimitiveProperty(NoGeneralization, _this, "hasCreatedDate", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__hasOwner = new internal.PrimitiveProperty(NoGeneralization, _this, "hasOwner", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__hasChangedBy = new internal.PrimitiveProperty(NoGeneralization, _this, "hasChangedBy", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__persistable = new internal.PrimitiveProperty(NoGeneralization, _this, "persistable", false, internal.PrimitiveTypeEnum.Boolean);
            if (arguments.length < 4) {
                throw new Error("new NoGeneralization() cannot be invoked directly, please use 'model.domainmodels.createNoGeneralization()'");
            }
            return _this;
        }
        Object.defineProperty(NoGeneralization.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NoGeneralization.prototype, "hasChangedDate", {
            get: function () { return this.__hasChangedDate.get(); },
            set: function (newValue) { this.__hasChangedDate.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NoGeneralization.prototype, "hasCreatedDate", {
            get: function () { return this.__hasCreatedDate.get(); },
            set: function (newValue) { this.__hasCreatedDate.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NoGeneralization.prototype, "hasOwner", {
            get: function () { return this.__hasOwner.get(); },
            set: function (newValue) { this.__hasOwner.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NoGeneralization.prototype, "hasChangedBy", {
            get: function () { return this.__hasChangedBy.get(); },
            set: function (newValue) { this.__hasChangedBy.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NoGeneralization.prototype, "persistable", {
            get: function () { return this.__persistable.get(); },
            set: function (newValue) { this.__persistable.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new NoGeneralization instance in the SDK and on the server.
         * The new NoGeneralization will be automatically stored in the 'generalization' property
         * of the parent Entity element passed as argument.
         */
        NoGeneralization.createIn = function (container) {
            return internal.instancehelpers.createElement(container, NoGeneralization, "generalization", false);
        };
        /**
         * Creates and returns a new NoGeneralization instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        NoGeneralization.create = function (model) {
            return internal.instancehelpers.createElement(model, NoGeneralization);
        };
        NoGeneralization.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.persistable = true;
        };
        return NoGeneralization;
    }(GeneralizationBase));
    NoGeneralization.typeName = "DomainModels$NoGeneralization";
    NoGeneralization.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "persistable": {
                "public": {
                    "currentValue": true
                }
            }
        },
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.NoGeneralization = NoGeneralization;
    var RangeRuleInfo = (function (_super) {
        __extends(RangeRuleInfo, _super);
        function RangeRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__typeOfRange = new internal.EnumProperty(RangeRuleInfo, _this, "typeOfRange", RangeType.Between, RangeType);
            _this.__useMinValue = new internal.PrimitiveProperty(RangeRuleInfo, _this, "useMinValue", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__useMaxValue = new internal.PrimitiveProperty(RangeRuleInfo, _this, "useMaxValue", false, internal.PrimitiveTypeEnum.Boolean);
            _this.__minValue = new internal.PrimitiveProperty(RangeRuleInfo, _this, "minValue", "", internal.PrimitiveTypeEnum.String);
            _this.__maxValue = new internal.PrimitiveProperty(RangeRuleInfo, _this, "maxValue", "", internal.PrimitiveTypeEnum.String);
            _this.__minAttribute = new internal.ByNameReferenceProperty(RangeRuleInfo, _this, "minAttribute", null, "DomainModels$Attribute");
            _this.__maxAttribute = new internal.ByNameReferenceProperty(RangeRuleInfo, _this, "maxAttribute", null, "DomainModels$Attribute");
            if (arguments.length < 4) {
                throw new Error("new RangeRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRangeRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(RangeRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "typeOfRange", {
            get: function () { return this.__typeOfRange.get(); },
            set: function (newValue) { this.__typeOfRange.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "useMinValue", {
            get: function () { return this.__useMinValue.get(); },
            set: function (newValue) { this.__useMinValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "useMaxValue", {
            get: function () { return this.__useMaxValue.get(); },
            set: function (newValue) { this.__useMaxValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "minValue", {
            get: function () { return this.__minValue.get(); },
            set: function (newValue) { this.__minValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "maxValue", {
            get: function () { return this.__maxValue.get(); },
            set: function (newValue) { this.__maxValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "minAttribute", {
            get: function () { return this.__minAttribute.get(); },
            set: function (newValue) { this.__minAttribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "minAttributeQualifiedName", {
            get: function () { return this.__minAttribute.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "maxAttribute", {
            get: function () { return this.__maxAttribute.get(); },
            set: function (newValue) { this.__maxAttribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeRuleInfo.prototype, "maxAttributeQualifiedName", {
            get: function () { return this.__maxAttribute.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
         * The new RangeRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        RangeRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, RangeRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new RangeRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        RangeRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, RangeRuleInfo);
        };
        RangeRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.typeOfRange = RangeType.Between;
            this.useMaxValue = true;
            this.useMinValue = true;
        };
        return RangeRuleInfo;
    }(RuleInfo));
    RangeRuleInfo.typeName = "DomainModels$RangeRuleInfo";
    RangeRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.RangeRuleInfo = RangeRuleInfo;
    var RegExRuleInfo = (function (_super) {
        __extends(RegExRuleInfo, _super);
        function RegExRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__regularExpression = new internal.ByNameReferenceProperty(RegExRuleInfo, _this, "regularExpression", null, "RegularExpressions$RegularExpression");
            if (arguments.length < 4) {
                throw new Error("new RegExRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRegExRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(RegExRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegExRuleInfo.prototype, "regularExpression", {
            get: function () { return this.__regularExpression.get(); },
            set: function (newValue) { this.__regularExpression.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RegExRuleInfo.prototype, "regularExpressionQualifiedName", {
            get: function () { return this.__regularExpression.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
         * The new RegExRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        RegExRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, RegExRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new RegExRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        RegExRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, RegExRuleInfo);
        };
        RegExRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return RegExRuleInfo;
    }(RuleInfo));
    RegExRuleInfo.typeName = "DomainModels$RegExRuleInfo";
    RegExRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.RegExRuleInfo = RegExRuleInfo;
    var RequiredRuleInfo = (function (_super) {
        __extends(RequiredRuleInfo, _super);
        function RequiredRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new RequiredRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createRequiredRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(RequiredRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
         * The new RequiredRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        RequiredRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, RequiredRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new RequiredRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        RequiredRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, RequiredRuleInfo);
        };
        RequiredRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return RequiredRuleInfo;
    }(RuleInfo));
    RequiredRuleInfo.typeName = "DomainModels$RequiredRuleInfo";
    RequiredRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.RequiredRuleInfo = RequiredRuleInfo;
    /**
     * In version 6.6.0: added public
     */
    var StoredValue = (function (_super) {
        __extends(StoredValue, _super);
        function StoredValue(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__defaultValue = new internal.PrimitiveProperty(StoredValue, _this, "defaultValue", "", internal.PrimitiveTypeEnum.String);
            if (arguments.length < 4) {
                throw new Error("new StoredValue() cannot be invoked directly, please use 'model.domainmodels.createStoredValue()'");
            }
            return _this;
        }
        Object.defineProperty(StoredValue.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StoredValue.prototype, "defaultValue", {
            get: function () { return this.__defaultValue.get(); },
            set: function (newValue) { this.__defaultValue.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new StoredValue instance in the SDK and on the server.
         * The new StoredValue will be automatically stored in the 'value' property
         * of the parent Attribute element passed as argument.
         */
        StoredValue.createIn = function (container) {
            return internal.instancehelpers.createElement(container, StoredValue, "value", false);
        };
        /**
         * Creates and returns a new StoredValue instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        StoredValue.create = function (model) {
            return internal.instancehelpers.createElement(model, StoredValue);
        };
        StoredValue.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return StoredValue;
    }(ValueType));
    StoredValue.typeName = "DomainModels$StoredValue";
    StoredValue.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true,
            "changedIn": [
                "6.6.0"
            ]
        }
    }, internal.StructureType.Element);
    domainmodels.StoredValue = StoredValue;
    var StringAttributeType = (function (_super) {
        __extends(StringAttributeType, _super);
        function StringAttributeType(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__length = new internal.PrimitiveProperty(StringAttributeType, _this, "length", 0, internal.PrimitiveTypeEnum.Integer);
            if (arguments.length < 4) {
                throw new Error("new StringAttributeType() cannot be invoked directly, please use 'model.domainmodels.createStringAttributeType()'");
            }
            return _this;
        }
        Object.defineProperty(StringAttributeType.prototype, "containerAsAttribute", {
            get: function () { return _super.prototype.getContainerAs.call(this, Attribute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StringAttributeType.prototype, "length", {
            get: function () { return this.__length.get(); },
            set: function (newValue) { this.__length.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * The new StringAttributeType will be automatically stored in the 'type' property
         * of the parent Attribute element passed as argument.
         */
        StringAttributeType.createIn = function (container) {
            return internal.instancehelpers.createElement(container, StringAttributeType, "type", false);
        };
        /**
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        StringAttributeType.create = function (model) {
            return internal.instancehelpers.createElement(model, StringAttributeType);
        };
        StringAttributeType.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.length = 200;
        };
        return StringAttributeType;
    }(AttributeType));
    StringAttributeType.typeName = "DomainModels$StringAttributeType";
    StringAttributeType.versionInfo = new exports.StructureVersionInfo({
        "public": {
            "currentValue": true
        }
    }, internal.StructureType.Element);
    domainmodels.StringAttributeType = StringAttributeType;
    var UniqueRuleInfo = (function (_super) {
        __extends(UniqueRuleInfo, _super);
        function UniqueRuleInfo(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            if (arguments.length < 4) {
                throw new Error("new UniqueRuleInfo() cannot be invoked directly, please use 'model.domainmodels.createUniqueRuleInfo()'");
            }
            return _this;
        }
        Object.defineProperty(UniqueRuleInfo.prototype, "containerAsValidationRule", {
            get: function () { return _super.prototype.getContainerAs.call(this, ValidationRule); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
         * The new UniqueRuleInfo will be automatically stored in the 'ruleInfo' property
         * of the parent ValidationRule element passed as argument.
         */
        UniqueRuleInfo.createIn = function (container) {
            return internal.instancehelpers.createElement(container, UniqueRuleInfo, "ruleInfo", false);
        };
        /**
         * Creates and returns a new UniqueRuleInfo instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        UniqueRuleInfo.create = function (model) {
            return internal.instancehelpers.createElement(model, UniqueRuleInfo);
        };
        UniqueRuleInfo.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
        };
        return UniqueRuleInfo;
    }(RuleInfo));
    UniqueRuleInfo.typeName = "DomainModels$UniqueRuleInfo";
    UniqueRuleInfo.versionInfo = new exports.StructureVersionInfo({}, internal.StructureType.Element);
    domainmodels.UniqueRuleInfo = UniqueRuleInfo;
    /**
     * See: {@link https://docs.mendix.com/refguide7/validation-rules relevant section in reference guide}
     */
    var ValidationRule = (function (_super) {
        __extends(ValidationRule, _super);
        function ValidationRule(model, typeName, id, isPartial, unit, container) {
            var _this = _super.call(this, model, typeName, id, isPartial, unit, container) || this;
            _this.__attribute = new internal.ByNameReferenceProperty(ValidationRule, _this, "attribute", null, "DomainModels$Attribute");
            _this.__errorMessage = new internal.PartProperty(ValidationRule, _this, "errorMessage", null, true);
            _this.__ruleInfo = new internal.PartProperty(ValidationRule, _this, "ruleInfo", null, true);
            if (arguments.length < 4) {
                throw new Error("new ValidationRule() cannot be invoked directly, please use 'model.domainmodels.createValidationRule()'");
            }
            return _this;
        }
        Object.defineProperty(ValidationRule.prototype, "containerAsEntity", {
            get: function () { return _super.prototype.getContainerAs.call(this, Entity); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValidationRule.prototype, "attribute", {
            get: function () { return this.__attribute.get(); },
            set: function (newValue) { this.__attribute.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValidationRule.prototype, "attributeQualifiedName", {
            get: function () { return this.__attribute.qualifiedName(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValidationRule.prototype, "errorMessage", {
            get: function () { return this.__errorMessage.get(); },
            set: function (newValue) { this.__errorMessage.set(newValue); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValidationRule.prototype, "ruleInfo", {
            get: function () { return this.__ruleInfo.get(); },
            set: function (newValue) { this.__ruleInfo.set(newValue); },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates and returns a new ValidationRule instance in the SDK and on the server.
         * The new ValidationRule will be automatically stored in the 'validationRules' property
         * of the parent Entity element passed as argument.
         */
        ValidationRule.createIn = function (container) {
            return internal.instancehelpers.createElement(container, ValidationRule, "validationRules", true);
        };
        /**
         * Creates and returns a new ValidationRule instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        ValidationRule.create = function (model) {
            return internal.instancehelpers.createElement(model, ValidationRule);
        };
        ValidationRule.prototype._initializeDefaultProperties = function () {
            _super.prototype._initializeDefaultProperties.call(this);
            this.errorMessage = texts_1.texts.Text.create(this.model);
            this.ruleInfo = RequiredRuleInfo.create(this.model);
        };
        return ValidationRule;
    }(internal.Element));
    ValidationRule.typeName = "DomainModels$ValidationRule";
    ValidationRule.versionInfo = new exports.StructureVersionInfo({
        "properties": {
            "attribute": {
                "required": {
                    "currentValue": true
                }
            },
            "errorMessage": {
                "required": {
                    "currentValue": true
                }
            },
            "ruleInfo": {
                "required": {
                    "currentValue": true
                }
            }
        }
    }, internal.StructureType.Element);
    domainmodels.ValidationRule = ValidationRule;
})(domainmodels = exports.domainmodels || (exports.domainmodels = {}));
var security_1 = require("./security");
var texts_1 = require("./texts");
