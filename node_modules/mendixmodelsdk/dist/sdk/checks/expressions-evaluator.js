"use strict";
var instances_1 = require("../../sdk/internal/instances");
var structures_1 = require("../internal/structures");
var standard_library_iterators_1 = require("./standard-library-iterators");
var standard_library_methods_1 = require("./standard-library-methods");
var versioning_1 = require("./versioning");
var context_1 = require("./context");
function evaluateExpression(expr, structure, queryResolver, context) {
    // share model across all helper functions (fall-backs are purely for testing...):
    var model = structure ? structure.model : undefined;
    var modelClasses = structure ? model._allModelClasses() : {};
    return _eval(expr, structure, context || context_1.Context.createWithThis(structure));
    function _eval(evaluatable, source, context) {
        var polyMap = {
            // for every non-abstract sub type of Evaluatable, provide an interpretation -- please sort by type name:
            "MxBinaryExpression": function (expr) { return evalBinary(expr, source, context); },
            "MxBooleanLiteralExpression": function (expr) { return expr.value; },
            "MxColorLiteralExpression": function (expr) {
                return { red: expr.red, green: expr.green, blue: expr.blue };
            },
            "MxDoubleLiteralExpression": function (expr) { return expr.value; },
            "MxFeatureCallWrapper": function (expr) { return _eval(expr.featureCall, source, context); },
            "MxFollowExcluding": function (expr) { return evalFollowExcluding(expr, source, context); },
            "MxFollowIncluding": function (expr) { return evalFollowIncluding(expr, source, context); },
            "MxIntegerLiteralExpression": function (expr) { return expr.value; },
            "MxIteratorCall": function (expr) { return evalIteratorCall(expr, source, context); },
            "MxListLiteralExpression": function (expr) {
                var evalItems = expr.items.map(function (item) { return _eval(item, source, context); });
                return evalItems.some(function (evalItem) { return isNothing(evalItem); }) ? undefined : evalItems;
                // simple failure semantics: propagate undefined
            },
            "MxMethodCall": function (expr) { return evalMethodCall(expr, source, context); },
            "MxPrefixExpression": function (expr) {
                var exprEval = _eval(expr.expression, source, context);
                return isNothing(exprEval) ? exprEval : (!exprEval); // simple failure semantics: propagate undefined
            },
            "MxPreviousExpression": function (expr) {
                return context.getIterationState(expr.variable.referredVariable).previous().value();
            },
            "MxPropertyCall": function (expr) { return isNothing(source) ? undefined : source[expr.referredProperty]; },
            "MxQualifiedEnumLiteralExpression": function (expr) { return evalQualifiedEnumLiteral(expr); },
            "MxSizeLiteralExpression": function (expr) { return { height: expr.height, width: expr.width }; },
            "MxStringLiteralExpression": function (expr) { return expr.value; },
            "MxStructureLiteralExpression": function (expr) { return evalStructureLiteral(expr, source, context); },
            "MxSwitch": function (expr) { return evalSwitch(expr, source, context); },
            "MxThisExpression": function (expr) { return context.getThis(); },
            "MxTypeStructureLiteralExpression": function (expr) {
                return new standard_library_methods_1.StructureTypeLiteral(instances_1.instancehelpers.lookupClass(expr.referredStructure, modelClasses));
            },
            "MxUndefinedExpression": function (expr) { return undefined; },
            "MxVariableRefExpression": function (expr) { return context.getValue(expr.referredVariable); }
        };
        var evalFn = polyMap[evaluatable.$type];
        if (!evalFn) {
            throw new Error("unhandled expression type: " + evaluatable.$type);
        }
        var baseEval = evalFn(evaluatable);
        // for some debugging convenience: call logBaseEval(evaluatable, source, baseEval) using expressions-debug-util
        return evalApplicable(evaluatable, baseEval, context);
    }
    function evalApplicable(expr, baseEval, context) {
        return !expr.appliedFeature // no check for nothingness: e.g. '.isUndefined()' can turn nothing into something
            ? baseEval // simple failure semantics: propagate undefined
            : _eval(expr.appliedFeature, baseEval, context);
    }
    function evalBinary(expr, source, context) {
        if (expr.operator === "NONE") {
            throw new Error("sentinel value of MxOperator not allowed in runtime");
        }
        var evalLeft = _eval(expr.left, source, context);
        var evalRight = _eval(expr.right, source, context); // (no shortcutting)
        if (isNothing(evalLeft) || isNothing(evalRight)) {
            switch (expr.operator) {
                case "UNEQUALS": return true;
                case "AND": return undefined;
                case "OR": {
                    if (isNothing(evalLeft) && isNothing(evalRight)) {
                        return false;
                    }
                    // take the [not-un]defined one:
                    return isNothing(evalLeft) ? evalRight : evalLeft;
                }
                default: return false;
            }
        }
        switch (expr.operator) {
            case "AND": return evalLeft && evalRight;
            case "EQUALS": return evalLeft === evalRight;
            case "GREATER": return evalLeft > evalRight; // (no type coercion)
            case "GREATER_OR_EQUALS": return (evalLeft > evalRight) || (evalLeft === evalRight); // (some type coercion)
            case "LESS": return evalLeft < evalRight; // (no type coercion)
            case "LESS_OR_EQUALS": return (evalLeft < evalRight) || (evalLeft === evalRight); // (some type coercion)
            case "OR": return evalLeft || evalRight;
            case "UNEQUALS": return evalLeft !== evalRight;
            default: return undefined;
        }
    }
    function evalFollowExcluding(expr, source, context) {
        var evalIncluding = evalFollowIncluding(expr, source, context);
        return isNothing(evalIncluding) || !Array.isArray(evalIncluding) ? evalIncluding : evalIncluding.slice(1);
    }
    // Note: takes expr of type MxAbstractFollow!
    function evalFollowIncluding(expr, source, context) {
        if (isNothing(source)) {
            return undefined;
        }
        var visited = [];
        var currentElement = source;
        while (!isNothing(currentElement)) {
            if (visited.indexOf(currentElement) > -1) {
                visited.push(currentElement); // cycle!
                break;
            }
            visited.push(currentElement);
            currentElement = _eval(expr.path, currentElement, context.withValue(expr.variable.name, currentElement));
        }
        return visited;
    }
    function evalIteratorCall(expr, source, context) {
        var iterator = standard_library_iterators_1.standardIterators[expr.type];
        if (!iterator) {
            throw new Error("Iterator not implemented: '" + expr.type + "'");
        }
        return iterator(source, function (value, index, array) { return _eval(expr.body, undefined /* could be "source" but nothing seems to be more correct */, context.withIterationState(expr.variable.name, new standard_library_iterators_1.IterationState(index, array))); });
    }
    function evalMethodCall(expr, source, context) {
        var method = standard_library_methods_1.standardLibraryMethods[expr.referredMethod];
        if (method) {
            var argValues = (expr.arguments || []).map(function (argExpr) { return _eval(argExpr, source, context); }).slice();
            // for some debugging convenience:
            // 		call logMethodCall(expr, source, argValues, result) using expressions-debug-util,
            // 		with result = method(source, argValues)
            return method(source, argValues);
        }
        if (isNothing(source)) {
            return undefined;
        }
        if (!(source instanceof structures_1.Structure)) {
            throw new Error("Cannot call query '" + expr.referredMethod + "' on non-Structure");
        }
        var query = queryResolver(expr.referredMethod, source.typeName);
        if (query) {
            var queryBody = versioning_1.lookupByVersion(query.queryVersions, model.metaModelVersion);
            var queryContext_1 = context.withThis(source);
            if (query.parameters) {
                var argValues_1 = (expr.arguments || []).map(function (argExpr) { return _eval(argExpr, source, context); }).slice();
                query.parameters.forEach(function (item, index) {
                    queryContext_1 = queryContext_1.withValue(query.parameters[index].name, argValues_1[index]);
                });
            }
            if (queryBody.variables) {
                for (var _i = 0, _a = queryBody.variables; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    queryContext_1 = queryContext_1.withValue(variable.name, _eval(variable.value, source, queryContext_1));
                }
            }
            return _eval(queryBody.value, source, queryContext_1);
        }
        throw new Error("Method not implemented by either standard lib or as query on instance of " + source.typeName + ": " + expr.referredMethod);
    }
    function evalQualifiedEnumLiteral(expr) {
        var enumClazz = instances_1.instancehelpers.lookupClass(expr.enumeration, modelClasses);
        if (!enumClazz) {
            return undefined;
        }
        var literal = enumClazz[expr.literal];
        if (!literal) {
            return undefined;
        }
        return literal;
    }
    function evalStructureLiteral(expr, source, context) {
        var assignments = {};
        for (var _i = 0, _a = expr.assignments; _i < _a.length; _i++) {
            var assignment = _a[_i];
            var evalAssignment = _eval(assignment.value, source, context);
            if (isNothing(evalAssignment)) {
                return undefined;
            }
            assignments[assignment.property] = evalAssignment;
        }
        var clazz = instances_1.instancehelpers.lookupClass(expr.structure, modelClasses);
        if (!clazz) {
            return undefined;
        }
        var newStructure = clazz.create(model);
        if (!newStructure) {
            return undefined;
        }
        for (var propertyName in assignments) {
            newStructure["__" + propertyName].set(assignments[propertyName]);
        }
        return newStructure;
    }
    function evalSwitch(expr, source, context) {
        var switchContext = context.withValue(expr.variable.name, source);
        for (var _i = 0, _a = expr.cases; _i < _a.length; _i++) {
            var switchCase = _a[_i];
            if (evalSwitchCase(switchCase, source, switchContext)) {
                return _eval(switchCase.value, undefined, switchContext);
            }
        }
        return undefined;
    }
    function evalSwitchCase(switchCase, source, context) {
        var typeMatches = (function () {
            if (!switchCase.expectedType) {
                return true;
            }
            var typeLiteral = _eval(switchCase.expectedType, undefined, context);
            return isNothing(typeLiteral) ? false : source instanceof typeLiteral.clazz;
        })();
        return typeMatches && (!switchCase.condition || !!_eval(switchCase.condition, undefined, context));
    }
}
exports.evaluateExpression = evaluateExpression;
/**
 * Checks whether the argument is "nothing", i.e. either undefined or null.
 */
function isNothing(arg) {
    return (arg === undefined || arg === null);
}
exports.isNothing = isNothing;
