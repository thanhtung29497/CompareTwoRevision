"use strict";
var lodash_1 = require("lodash");
var expressions_evaluator_1 = require("./expressions-evaluator");
exports.standardIterators = {
    // (in alphabetic order, for easy lookup:)
    EVERY: every,
    FILTER: filter,
    FIND_FIRST: findFirst,
    MAP: map,
    SOME: some
};
/**
 * Produces an iterator lambda on Booleans that maps undefined values to false.
 */
function normalize(lambda) {
    return lodash_1.flowRight(function (b) { return !!b; }, lambda);
}
/**
 * A class to capture the state of an iteration which consists of the array of which is iterated,
 * the current index and the current value - which equals array[index] if index is valid and undefined otherwise.
 * It helps in implementing the previous operator (and even more generic offset operators)
 * by updating the iteration state in the current context to it.previous().
 * This is a cleaner way than to keep track of the previous value and passing that to expressions
 * bound in the iterator.
 */
var IterationState = (function () {
    function IterationState(index, array) {
        this.index = index;
        this.array = array;
    }
    IterationState.prototype.value = function () {
        return this.index !== undefined && ((0 <= this.index) && this.index < this.array.length)
            ? this.array[this.index]
            : undefined;
    };
    IterationState.prototype.previous = function () {
        return this.index > 0
            ? new IterationState(this.index - 1, this.array)
            : new IterationState(undefined, this.array);
    };
    return IterationState;
}());
exports.IterationState = IterationState;
;
function every(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return false;
    }
    var fItems = items.map(boundExpr);
    if (fItems.some(function (fItem) { return expressions_evaluator_1.isNothing(fItem); })) {
        return false;
    }
    return fItems.every(function (fItem) { return !!fItem; });
}
function findFirst(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return lodash_1.find(items, normalize(boundExpr));
}
function filter(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return items.filter(normalize(boundExpr));
}
function map(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return undefined;
    }
    return items.map(boundExpr).filter(function (item) { return item !== undefined; });
}
function some(items, boundExpr) {
    if (expressions_evaluator_1.isNothing(items)) {
        return false;
    }
    if (items.length === 0) {
        return false;
    }
    var fItems = items.map(boundExpr);
    if (fItems.some(function (fItem) { return !!fItem; })) {
        return true;
    }
    if (fItems.every(function (fItem) { return expressions_evaluator_1.isNothing(fItem); })) {
        return undefined;
    }
    return false;
}
