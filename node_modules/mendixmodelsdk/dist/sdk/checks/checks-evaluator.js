"use strict";
var expressions_evaluator_1 = require("./expressions-evaluator");
var versioning_1 = require("./versioning");
var context_1 = require("./context");
// only used for testing:
function evaluateCheck(check, structure, queryResolver) {
    var checkBody = versioning_1.lookupByVersion(check.versionCheckBodies, structure.model.metaModelVersion);
    return evaluateCheckBody(check.name, checkBody, structure, queryResolver);
}
exports.evaluateCheck = evaluateCheck;
function evaluateCheckBody(checkName, checkBody, structure, queryResolver) {
    function evaluateExpressionProtected(expr, context, // may be nothing
        description, fallBackOnError, warnOnNothing) {
        if (warnOnNothing === void 0) { warnOnNothing = false; }
        try {
            var exprEval = expressions_evaluator_1.evaluateExpression(expr, structure, queryResolver, context);
            if (warnOnNothing && expressions_evaluator_1.isNothing(exprEval)) {
                console.warn(description + " on instance of '" + structure.typeName + "' -> nothing");
            }
            return exprEval;
        }
        catch (e) {
            console.error("could not evaluate " + description + " on instance of '" + structure.typeName + "' due to: " + e);
            return fallBackOnError();
        }
    }
    var context = context_1.Context.createWithThis(structure);
    if (checkBody.variables) {
        checkBody.variables.forEach(function (variable) {
            context = context.withValue(variable.name, evaluateExpressionProtected(variable.value, null, "value expression for variable '" + variable.name + "'", function () { return undefined; }));
        });
    }
    /*
     * Protect evaluation of check condition against throws and provide some debugging info in that case.
     * It is not regular that the check condition evaluates to nothing, so that's reported as well.
     */
    var conditionEval = evaluateExpressionProtected(checkBody.checkCondition.rule, context, "check condition of check '" + checkName + "'", function () { return (checkBody.checkCondition.$type === "MxCheckConditionForList") ? [] : undefined; }, true // warn on nothing
    );
    var isListy = (function () {
        switch (checkBody.checkCondition.$type) {
            case "MxCheckConditionForBoolean": return false;
            case "MxCheckConditionForList": return true;
            default:
                throw new Error("unhandled type for MxCheck.checkCondition: " + checkBody.checkCondition.$type);
        }
    })();
    var faultyStructures = isListy
        ? conditionEval
        : (!!conditionEval ? [structure] : []); // undefined -> false
    return faultyStructures.map(function (forStructure) {
        return {
            structure: forStructure,
            message: calculateMessage(structure, // structure check was run on, which is 'this' in message arguments
            checkBody.message, queryResolver, isListy ? context.withValue(checkBody.checkCondition.errorVar.name, forStructure) : context),
            severity: checkBody.severity,
            incorrectProperty: checkBody.incorrectProperty,
            checkName: checkName
        };
    });
}
exports.evaluateCheckBody = evaluateCheckBody;
/* (exported for testing) */
function calculateMessage(structure, message, queryResolver, context) {
    var evaluatedArgs = message.arguments ? message.arguments.map(function (arg) { return expressions_evaluator_1.evaluateExpression(arg, structure, queryResolver, context); }) : [];
    return message.text.replace(/\{(\d+?)\}/g, function (match, key) { return evaluatedArgs[key]; });
}
exports.calculateMessage = calculateMessage;
