"use strict";
var checks_evaluator_1 = require("./checks-evaluator");
var metadata_loaders_1 = require("./metadata-loaders");
var versioning_1 = require("./versioning");
var utils_1 = require("../utils");
function makeChecksResolver(checks) {
    if (checks === void 0) { checks = metadata_loaders_1.loadChecks(); }
    var map = {};
    checks.forEach(function (check) {
        check.allCompatibleTypes.forEach(function (qualifiedStructureName) {
            var checksList = map[qualifiedStructureName];
            if (!checksList) {
                checksList = map[qualifiedStructureName] = [];
            }
            checksList.push(check);
        });
    });
    return function (qualifiedStructureName) { return map[qualifiedStructureName]; };
}
exports.makeChecksResolver = makeChecksResolver;
function reportUnresolvedByNameReferences(unit) {
    return unit.model._unresolvedReferencesFor(unit).map(function (ref) {
        var typeName = ref.targetType.split("$")[1];
        return {
            structure: ref.owner,
            message: "Failed to resolve reference. There is no [" + typeName + "] with this [" + ref.qualifiedName() + "]. "
                + ("Please select an existing [" + typeName + "]"),
            severity: "error",
            incorrectProperty: ref.propertyName,
            checkName: "UnresolvedByNameReference (generic)"
        };
    });
}
function runChecksOn(unit, checksResolver, queryResolver) {
    if (!unit.isLoaded) {
        throw new Error("can only run checks on loaded unit");
    }
    var checkTasksPerLevelPerGroup = tasks(unit, checksResolver);
    var allIssues = [];
    allIssues.push(reportUnresolvedByNameReferences(unit));
    for (var group in checkTasksPerLevelPerGroup) {
        var stopAfterThisLevel = false;
        var checkTasksPerLevel = checkTasksPerLevelPerGroup[group];
        for (var level in checkTasksPerLevel) {
            if (stopAfterThisLevel) {
                break;
            }
            if (!checkTasksPerLevel[level]) {
                continue;
            }
            for (var _i = 0, _a = checkTasksPerLevel[level]; _i < _a.length; _i++) {
                var task = _a[_i];
                var issues = checks_evaluator_1.evaluateCheckBody(task.checkName, task.checkBody, task.structure, queryResolver);
                if (issues.length > 0) {
                    allIssues.push(issues);
                    // always run all checks of level 0 (no level group) and 1 (1st level group):
                    if (level !== "0") {
                        stopAfterThisLevel = true;
                    }
                }
            }
        }
    }
    return utils_1.utils.flatten(allIssues);
}
exports.runChecksOn = runChecksOn;
var alwaysRunSpec = { group: 0, level: 0 };
/**
 * Gathers checks to be run against structures and groups them by check group and then by level.
 */
function tasks(unit, checksResolver) {
    var mmVersion = unit.model.metaModelVersion;
    var checkTasksPerLevelPerGroup = [];
    function lazilyCreatingGet(buckets, index) {
        var bucket = buckets[index];
        if (!bucket) {
            bucket = [];
            buckets[index] = bucket;
        }
        return bucket;
    }
    unit.traverse(function (structure) {
        var checks = checksResolver(structure.typeName);
        if (checks) {
            checks.forEach(function (check) {
                var checkBody = versioning_1.lookupByVersion(check.versionCheckBodies, mmVersion);
                var runSpec = checkBody.runSpec || alwaysRunSpec;
                var checkTasksPerLevel = lazilyCreatingGet(checkTasksPerLevelPerGroup, runSpec.group);
                var checkTasks = lazilyCreatingGet(checkTasksPerLevel, runSpec.level);
                checkTasks.push({
                    structure: structure,
                    checkBody: checkBody,
                    checkName: check.name
                });
            });
        }
    });
    return checkTasksPerLevelPerGroup;
}
