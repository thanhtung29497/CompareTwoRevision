"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var mobx_1 = require("mobx");
/**
 * Abstract base class for both {@link ReferenceByName by-name} and {@link ReferenceById by-id} references
 * to elements of type `T`, which are observed.
 */
var AbstractReference = (function () {
    /**
     * Constructs and returns a new reference instance, that is owned (by a property of) an abstract element.
     */
    function AbstractReference(owner) {
        this.owner = owner;
        this.isResolved = true;
        this.target = mobx_1.observable(mobx_1.asReference(null));
        this.isResolving = false; // suppress on change events
        this.referenceId = null;
    }
    /**
     * Registers an observer in the form of a callback with this references and fires that callback
     * immediately if the reference is already resolved.
     * Used by properties to observe this reference, so that storage and logical updates can be applied.
     */
    AbstractReference.prototype.observe = function (callback, fireImmediately) {
        var _this = this;
        return mobx_1.observe(this.target, function (newValue, oldValue) {
            // Do not notify properties that a value is changed when resolving, because no delta should be created.
            // UI will still be updated, since this.target is an observable.
            if (!_this.isResolving) {
                callback(newValue, oldValue);
            }
        }, fireImmediately);
    };
    /**
     * Returns the value of the wrapped reference.
     */
    AbstractReference.prototype.get = function () {
        return this.target.get();
    };
    /**
     * Sets the value of the wrapped reference, taking care of resolution and life cycle.
     */
    AbstractReference.prototype.set = function (newValue) {
        if (newValue) {
            newValue.versionInfo.checkSameModelVersion(newValue.model, this.owner.model);
            newValue.versionInfo.checkStructureVersion(newValue, true);
        }
        if (this.isResolved) {
            this.unregisterRef();
        }
        this.target.set(newValue);
        this.registerRef();
    };
    /**
     * Sets only the raw target id, without trying to resolve that.
     */
    AbstractReference.prototype.updateWithRawValue = function (value) {
        if (value !== this.referenceId) {
            this.unregisterRef();
            this.target.set(null);
            this.referenceId = value;
            this.isResolved = false;
        }
    };
    AbstractReference.prototype.registerRef = function () {
        if (this.target.get()) {
            this.target.get()._addBackReference(this);
        }
    };
    AbstractReference.prototype.unregisterRef = function () {
        if (this.target.get()) {
            this.target.get()._removeBackReference(this);
        }
    };
    AbstractReference.prototype.resolve = function () {
        throw "Should be implemented by sub class";
    };
    AbstractReference.prototype.dispose = function () {
        this.unregisterRef();
    };
    return AbstractReference;
}());
exports.AbstractReference = AbstractReference;
var ByIdReference = (function (_super) {
    __extends(ByIdReference, _super);
    function ByIdReference() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ByIdReference.prototype.set = function (newValue) {
        if (newValue) {
            /* This guarantees that no unresolvable references by id can end up in our storage.
            We could loosen this constraint when we have transactions with server side consistency checks,
            but otherwise this would be a subtle bug people could run into easily. */
            if (!newValue.unit) {
                throw new Error("Cannot update property of '" + this.owner.typeName + "', the given object is not yet part of a unit. " +
                    "Please add the object to an unit first.");
            }
        }
        _super.prototype.set.call(this, newValue);
        this.assertValueHasSameUnit();
    };
    ByIdReference.prototype.assertValueHasSameUnit = function () {
        var currentValue = _super.prototype.get.call(this);
        if (currentValue && currentValue.unit && this.owner.unit && currentValue.unit !== this.owner.unit) {
            throw new Error("In element of type " + this.owner.typeName + ": " +
                ("The assigned value should be part of the same unit, expected '" + this.owner.unit.id + "' but found '" + currentValue.unit.id + "'."));
        }
    };
    ByIdReference.prototype.get = function () {
        if (!this.isResolved) {
            throw new Error("Illegal state: by-id reference is broken"); // by-id reference should never be broken
        }
        return _super.prototype.get.call(this);
    };
    ByIdReference.prototype.resolve = function () {
        if (!this.isResolved) {
            this.isResolving = true;
            if (!this.referenceId) {
                this.target.set(null);
            }
            else if (this.referenceId === "00000000-0000-0000-0000-000000000000") {
                throw new Error("encountered null ID: unitID=" + this.owner.unit.id + "; " +
                    ("ID of element containing by-id reference property: ID=" + this.owner.id));
            }
            else {
                var elem = (this.owner.unit._elementsCache[this.referenceId]);
                if (!elem) {
                    throw new Error("Broken reference; ID: " + this.referenceId);
                }
                this.target.set(elem);
                this.assertValueHasSameUnit();
                this.registerRef();
            }
            this.isResolving = false;
            this.isResolved = true;
        }
        return true;
    };
    return ByIdReference;
}(AbstractReference));
exports.ByIdReference = ByIdReference;
var ByNameReference = (function (_super) {
    __extends(ByNameReference, _super);
    function ByNameReference(owner, targetType, propertyName) {
        var _this = _super.call(this, owner) || this;
        _this.targetType = targetType;
        _this.propertyName = propertyName;
        return _this;
    }
    // TODO  it would be better to have the property as the 1st constructor argument (so owner === property.parent)
    ByNameReference.prototype.set = function (newValue) {
        _super.prototype.set.call(this, newValue);
        if (newValue) {
            this.referenceId = newValue.qualifiedName;
        }
    };
    ByNameReference.prototype.resolve = function () {
        if (!this.isResolved) {
            this.isResolving = true;
            if (!this.referenceId) {
                this.target.set(null);
                this.isResolved = true;
            }
            else {
                var elem = this.owner.unit._model._resolveName(this.targetType, this.referenceId);
                this.isResolved = !!elem;
                this.target.set(elem);
                this.registerRef();
                if (!this.isResolved) {
                    this.owner.unit._model._registerUnresolvedReference(this);
                }
            }
            this.isResolving = false;
        }
        return this.isResolved;
    };
    /**
     * The target does no longer exist, but the stored reference should stay the same.
     */
    ByNameReference.prototype.unresolve = function () {
        // make sure the value of the latest referenceId is kept!
        this.isResolving = true;
        var current = this.get();
        if (current) {
            this.referenceId = current.qualifiedName;
        }
        this.owner.unit._model._registerUnresolvedReference(this);
        _super.prototype.set.call(this, null);
        this.isResolved = false;
    };
    ByNameReference.prototype.dispose = function () {
        if (!this.isResolved) {
            this.owner.unit._model._unregisterUnresolvedReference(this);
        }
        _super.prototype.dispose.call(this);
    };
    ByNameReference.prototype.qualifiedName = function () {
        if (!this.isResolved) {
            return this.referenceId;
        }
        var current = this.get();
        return current ? current.qualifiedName : "";
    };
    return ByNameReference;
}(AbstractReference));
exports.ByNameReference = ByNameReference;
