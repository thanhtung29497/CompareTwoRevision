"use strict";
// Defining constants inside a class results in better typedocs.
var DeltaTypes = (function () {
    function DeltaTypes() {
    }
    return DeltaTypes;
}());
DeltaTypes.CREATE_ELEMENT = "CREATE_ELEMENT";
DeltaTypes.UPDATE_PROPERTY_VALUE = "UPDATE_PROPERTY_VALUE";
DeltaTypes.MOVE_ELEMENT = "MOVE_ELEMENT";
DeltaTypes.DELETE_ELEMENT = "DELETE_ELEMENT";
DeltaTypes.CREATE_UNIT = "CREATE_UNIT";
DeltaTypes.DELETE_UNIT = "DELETE_UNIT";
exports.DeltaTypes = DeltaTypes;
;
var MutatorTypes = (function () {
    function MutatorTypes() {
    }
    return MutatorTypes;
}());
MutatorTypes.CHANGE = "CHANGE";
MutatorTypes.ADD = "ADD";
MutatorTypes.REMOVE = "REMOVE";
MutatorTypes.MOVE = "MOVE";
exports.MutatorTypes = MutatorTypes;
;
/**
 * A POTSO that wraps a delta and success/failure callbacks.
 */
var DeltaRequest = (function () {
    function DeltaRequest(delta, onSuccess, onFailure) {
        this.delta = delta;
        this.onSuccess = onSuccess;
        this.onFailure = onFailure;
    }
    return DeltaRequest;
}());
exports.DeltaRequest = DeltaRequest;
/**
 * A simple queue implementation for deltas.
 */
var DeltaQueue = (function () {
    function DeltaQueue(model, logToConsole) {
        this.model = model;
        this.logToConsole = logToConsole;
        this.isClosing = false;
        this.delay = 200; // ms
        this.maxDeltasPerBatch = 1000;
        this.queue = [];
        this.pending = false;
        this.hasError = false;
    }
    /**
     * Closes the "connection" with the Model API Server in the sense that
     * pending delta requests are processed, and that afterwards the given
     * `callback` will be called.
     * This function can only be called once.
     */
    DeltaQueue.prototype.closeConnection = function (callback, errorCallback /* Not used yet */) {
        if (this.isClosing) {
            throw new Error("closeConnection already called");
        }
        this.isClosing = true;
        if (this.pending) {
            this.closeCallback = callback;
        }
        else {
            return void callback();
        }
    };
    /**
        * Pushes the given `delta` on the queue for scheduling/processing.
        */
    DeltaQueue.prototype.push = function (delta) {
        if (this.isClosing) {
            throw new Error("Delta rejected, delta queue connection has closed.");
        }
        if (this.hasError) {
            throw new Error("Delta rejected because it has errors");
        }
        this.queue.push(delta);
        if (this.logToConsole) {
            console.log("Scheduled delta " + JSON.stringify(delta));
        }
        this.schedule();
    };
    /**
        * Schedules the next delta for processing using JS's event queue/loop.
        */
    DeltaQueue.prototype.schedule = function () {
        var _this = this;
        if (this.pending) {
            return;
        }
        this.pending = true;
        setTimeout(function () { return _this.processNext(); }, this.delay);
    };
    DeltaQueue.prototype.processNext = function () {
        var _this = this;
        if (this.queue.length === 0 || this.hasError) {
            this.pending = false;
            if (this.isClosing && this.closeCallback) {
                this.closeCallback();
            }
            return;
        }
        var deltaRequests = this.queue.slice(0, Math.min(this.queue.length, this.maxDeltasPerBatch));
        var deltas = deltaRequests.map(function (deltaRequest) { return deltaRequest.delta; });
        this.model._client.sendDeltas(this.model.metadata.id, deltas, function (results) {
            var nSuccess = results.successResults.length;
            _this.queue.splice(0, nSuccess);
            deltaRequests.slice(0, nSuccess).forEach(function (deltaRequest) {
                if (deltaRequest.onSuccess) {
                    deltaRequest.onSuccess();
                }
            });
            if (results.firstError) {
                _this.hasError = true;
                var failingDelta = deltaRequests[nSuccess];
                if (failingDelta.onFailure) {
                    failingDelta.onFailure(results.firstError);
                }
                else {
                    _this.model._errorHandler(results.firstError);
                }
            }
            _this.processNext();
        }, function (err) {
            _this.hasError = true;
            deltaRequests.forEach(function (deltaRequest) {
                if (deltaRequest.onFailure) {
                    deltaRequest.onFailure(err);
                }
            });
            _this.model._errorHandler(err);
            _this.processNext(); // handles pending closed callback
        });
    };
    return DeltaQueue;
}());
exports.DeltaQueue = DeltaQueue;
