"use strict";
var fs = require("fs");
var path = require("path");
/**
 * Default implementation of {@link IModelApiClient}.
 */
var apiEndPoint = "/api/v1/";
var ModelApiClientImpl = (function () {
    function ModelApiClientImpl(transportation) {
        this.transportation = transportation;
        this.pendingRequests = [];
        this.MAX_PARALLEL_REQUESTS = 100;
        this.runningRequests = 0;
    }
    ModelApiClientImpl.prototype.createWorkingCopy = function (workingCopyInfo, callback, errorCallback) {
        var data = {
            name: workingCopyInfo.name,
            description: workingCopyInfo.description || "",
            avatarUrl: workingCopyInfo.avatarUrl || "",
            projectId: workingCopyInfo.projectId || "",
            longLived: workingCopyInfo.longLived === true,
            publicReadOnly: workingCopyInfo.publicReadOnly === true,
            teamServerBaseRevision: workingCopyInfo.teamServerBaseRevision || -1,
            teamServerBaseBranch: workingCopyInfo.teamServerBaseBranch || "",
            setAsDefault: workingCopyInfo.setAsDefault === true
        };
        this.transportation.requestMultipartBinaryFileUpload("post", apiEndPoint + "wc/", data, "template", workingCopyInfo.template, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.loadWorkingCopyMetaData = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "wc/" + workingCopyId, null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.loadUnitInterfaces = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "wc/" + workingCopyId + "/units/", null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.deleteWorkingCopy = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("delete", apiEndPoint + "wc/" + workingCopyId, null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.grantAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request("put", apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId), null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.revokeAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request("delete", apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId), null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.checkAccess = function (workingCopyId, memberOpenId, callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "wc/" + workingCopyId + "/members/" + encodeURIComponent(memberOpenId), null, function (response) {
            return void callback(response.hasAccess);
        }, errorCallback);
    };
    ModelApiClientImpl.prototype.grantAccessByProject = function (projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request("put", apiEndPoint + "project/" + projectId + "/members/" + encodeURIComponent(memberOpenId), null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.revokeAccessByProject = function (projectId, memberOpenId, callback, errorCallback) {
        this.transportation.request("delete", apiEndPoint + "project/" + projectId + "/members/" + encodeURIComponent(memberOpenId), null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.exportMpk = function (workingCopyId, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload("get", apiEndPoint + "wc/" + workingCopyId + "/mpk", this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    };
    ModelApiClientImpl.prototype.startAppUpdate = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        this.transportation.request("post", apiEndPoint + "wc/" + workingCopyId + "/updateapp", null, function (status) {
            _this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    };
    ModelApiClientImpl.prototype.getAppUpdateStatus = function (workingCopyId, jobId, callback, errorCallback) {
        var _this = this;
        this.transportation.request("get", apiEndPoint + "wc/" + workingCopyId + "/updateapp-status?jobid=" + jobId, null, function (status) {
            _this.parseAppUpdateStatus(status);
            callback(status);
        }, errorCallback);
    };
    ModelApiClientImpl.prototype.parseAppUpdateStatus = function (status) {
        status.consistencyErrors = this.parseBuildStatus(status.buildstatus);
    };
    ModelApiClientImpl.prototype.loadUnitById = function (workingCopyId, unitId, callback, errorCallback) {
        this.loadUnitByIdBatched({ workingCopyId: workingCopyId, unitId: unitId, callback: callback, errorCallback: errorCallback });
    };
    ModelApiClientImpl.prototype.sendDeltas = function (workingCopyId, deltas, callback, errorCallback) {
        this.transportation.request("post", apiEndPoint + "wc/" + workingCopyId + "/deltas", { deltas: deltas }, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.getFiles = function (workingCopyId, options, callback, errorCallback) {
        if (!options.format) {
            options.format = "json";
        }
        var filterPostfix = options.filter ? "&filter=" + options.filter : "";
        var downloadUrl = apiEndPoint + "wc/" + workingCopyId + "/files/?format=" + options.format + filterPostfix;
        if (options.format === "json") {
            this.transportation.request("get", downloadUrl, null, callback, errorCallback);
        }
        else if (options.format === "zip") {
            this.transportation.requestFileDownload("get", downloadUrl, this.createDownloadHandler(options.path, callback, errorCallback), errorCallback);
        }
        else {
            throw new Error("Unsupported format" + options.format);
        }
    };
    ModelApiClientImpl.prototype.getFile = function (workingCopyId, filePath, outFilePath, callback, errorCallback) {
        this.transportation.requestFileDownload("get", apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath), this.createDownloadHandler(outFilePath, callback, errorCallback), errorCallback);
    };
    ModelApiClientImpl.prototype.putFile = function (workingCopyId, inFilePath, filePath, callback, errorCallback) {
        this.transportation.requestMultipartBinaryFileUpload("put", apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath), {}, "file", inFilePath, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.deleteFile = function (workingCopyId, filePath, callback, errorCallback) {
        this.transportation.request("delete", apiEndPoint + "wc/" + workingCopyId + "/files/" + encodeURIComponent(filePath), null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.getAppEnvironmentStatus = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "wc/" + workingCopyId + "/app-environment-status", null, this.handleRawDeploymentResult.bind(this, callback, errorCallback), errorCallback, true);
    };
    ModelApiClientImpl.prototype.getEditorData = function (callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "editordata", null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.getMyWorkingCopies = function (callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "wc/", null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.getWorkingCopyByProject = function (projectId, callback, errorCallback) {
        this.transportation.request("get", apiEndPoint + "project/" + projectId, null, function (response) {
            return void callback(response.workingCopyId);
        }, errorCallback);
    };
    ModelApiClientImpl.prototype.createWorkingCopyByProject = function (projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request("post", apiEndPoint + "project/" + projectId, {
            projectId: projectId,
            workingCopyId: workingCopyId
        }, callback, errorCallback);
    };
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    ModelApiClientImpl.prototype.updateWorkingCopyByProject = function (projectId, workingCopyId, callback, errorCallback) {
        this.transportation.request("put", apiEndPoint + "project/" + projectId, {
            projectId: projectId,
            workingCopyId: workingCopyId
        }, callback, errorCallback);
    };
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    ModelApiClientImpl.prototype.deleteWorkingCopyByProject = function (projectId, callback, errorCallback) {
        this.transportation.request("delete", apiEndPoint + "project/" + projectId, null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.lockWorkingCopy = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("post", apiEndPoint + "wc/" + workingCopyId + "/lock", null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.unlockWorkingCopy = function (workingCopyId, callback, errorCallback) {
        this.transportation.request("post", apiEndPoint + "wc/" + workingCopyId + "/unlock", null, callback, errorCallback);
    };
    ModelApiClientImpl.prototype.sendGetUnitRequest = function (info) {
        var _this = this;
        this.runningRequests += 1;
        this.transportation.request("get", apiEndPoint + "wc/" + info.workingCopyId + "/units/" + info.unitId, null, function (data) {
            _this.completeGetUnitRequest();
            return void info.callback(data);
        }, function (error) {
            _this.completeGetUnitRequest();
            return void info.errorCallback(error);
        });
    };
    ModelApiClientImpl.prototype.createDownloadHandler = function (exportPath, callback, errorCallback) {
        var _this = this;
        if (exportPath && !fs) {
            throw new Error("cannot download asset to disk without file system");
        }
        return function (response) {
            if (exportPath) {
                _this.storeResponseAsFile(response, exportPath, function () { return void callback(null); }, errorCallback);
            }
            else {
                return void callback(response);
            }
        };
    };
    ModelApiClientImpl.prototype.handleRawDeploymentResult = function (callback, errorCallback, deploymentResult) {
        deploymentResult.consistencyErrors = this.parseBuildStatus(deploymentResult.buildstatus);
        return void callback(deploymentResult);
    };
    ModelApiClientImpl.prototype.parseBuildStatus = function (buildstatus) {
        // EPO: JSON to object conversion done here, and not earlier in the chain (like in platform-services or in the model-api)
        // because we will skip platform-services and model-api in a later story.
        try {
            if (!buildstatus) {
                return [];
            }
            return JSON.parse(buildstatus).problems;
        }
        catch (e) {
            console.error("Failed to parse deployment result: " + buildstatus);
            return [{
                    name: "BUILD_FAILED",
                    severity: "Error",
                    message: "Failed to build: " + buildstatus,
                    locations: []
                }];
        }
    };
    ModelApiClientImpl.prototype.storeResponseAsFile = function (response, outFilePath, callback, errorCallback) {
        var dirPath = path.dirname(outFilePath);
        fs.lstat(dirPath, function (err, stats) {
            if (err || !stats.isDirectory()) {
                var cwd = eval("process.cwd()"); // kludge to work around Node.js typings not being available for Model SDK
                return void errorCallback(new Error("target directory " + dirPath + " does not exist relative to " + cwd));
            }
            fs.open(outFilePath, "w", function (err, fd) {
                if (err) {
                    return void errorCallback(new Error("Could not create file with path \"" + outFilePath + "\"; due to: " + err));
                }
                fs.writeFile(outFilePath, response, "binary", function (err) {
                    if (err) {
                        return void errorCallback(new Error("Could not write to file with path \"" + outFilePath + "\"; due to: " + err));
                    }
                    return void callback(); // make sure we don't expose any arguments to the end-user
                });
            });
        });
    };
    ModelApiClientImpl.prototype.loadUnitByIdBatched = function (info) {
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS) {
            this.sendGetUnitRequest(info);
        }
        else {
            this.pendingRequests.push(info);
        }
    };
    ModelApiClientImpl.prototype.completeGetUnitRequest = function () {
        this.runningRequests -= 1;
        if (this.runningRequests < this.MAX_PARALLEL_REQUESTS && this.pendingRequests.length > 0) {
            this.sendGetUnitRequest(this.pendingRequests.shift());
        }
    };
    return ModelApiClientImpl;
}());
exports.ModelApiClientImpl = ModelApiClientImpl;
