"use strict";
var Structure = (function () {
    function Structure(_model, typeName, id, _isPartial, container) {
        if (_isPartial === void 0) { _isPartial = true; }
        if (container === void 0) { container = null; }
        this._model = _model;
        this.typeName = typeName;
        this.id = id;
        this._isPartial = _isPartial;
        this.container = container;
        this._declaredAsNamespace = false;
        // Indicates that the internal data of this element is being updated, as a result of data received from the server, so no
        // storage events should be send
        this._isUpdating = true;
        // This element was just constructed and not yet known server side
        this._isNew = false;
        // used by qualified names cache to determine old name after a rename
        this._registeredQualifiedName = undefined;
        /**
         * These deltas where created before the create delta of this element was submitted to the server.
         * As soon as this happens, the queue is processed and should stay empty.
         * Each element is either an delta, or a new child that was added under a specific property.
         */
        this._pendingDeltasAfterCreate = [];
        this._properties = []; // cache, it is used very often, and doesn't change over time
        if (!_model) {
            throw new Error("Missing model argument");
        }
        if (!id) {
            throw new Error("Missing id");
        }
        if (!typeName) {
            throw new Error("Missing id");
        }
        this._isNew = false;
        this._isUpdating = true;
    }
    Structure.prototype._initializeNewInstance = function () {
        this._isNew = true;
        this._isPartial = false;
        this._isUpdating = false;
        this._initializeDefaultProperties();
        this._markCurrentValuesAsDefaults();
    };
    Structure.prototype._initializeDefaultProperties = function () {
        // Empty stub, for new istances of this class, properties are initialized as described in the meta model
    };
    Object.defineProperty(Structure.prototype, "model", {
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "versionInfo", {
        get: function () {
            // assumption: versionInfo is *not* inherited.
            return this.constructor["versionInfo"];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "unit", {
        get: function () {
            throw new Error("Abstract!");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "isLoaded", {
        get: function () {
            throw new Error("Abstract!");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Asserts that the complete element is available, and not just its public part.
     */
    Structure.prototype._assertLoaded = function (propertyForMessage) {
        if (!this.isLoaded) {
            throw new Error(propertyForMessage
                ? ("This operation is not allowed on the property '" + propertyForMessage.name + "' because its "
                    + ("parent object '" + this.typeName + "' with ID '" + this.id + "' was not fully loaded. ")
                    + "Load the property's parent object with the '.load(callback)' command.")
                : ("This operation is not allowed on the object '" + this.typeName + "' with ID '" + this.id + "' because "
                    + "it was not fully loaded. Load the object with the '.load(callback)' command."));
        }
    };
    Structure.prototype._registerProperty = function (prop) {
        this._properties.push(prop);
    };
    /**
     * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
     */
    Structure.prototype._resolveReferences = function () {
        this.allProperties().forEach(function (prop) { return prop.resolveReferences(); });
    };
    /**
     * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
     */
    Structure.prototype._processNameChange = function () {
        if (this.unit) {
            this.unit._model._processNameChange(this);
        }
        // else: not owned yet => cannot have incoming by-name references that need to be changed => no action required
    };
    /**
     * Finds the given child among the properties of this structure,
     * returning a handle to detach it later when appropriate based on in which property is was found.
     */
    Structure.prototype._childHandle = function (child) {
        var props = this.allProperties();
        var _loop_1 = function (i) {
            var prop = props[i];
            if (prop instanceof properties.PartListProperty) {
                var partListProp_1 = prop;
                if (partListProp_1.observableValue.indexOf(child) > -1) {
                    return { value: {
                            containingProperty: prop,
                            detach: function () { return partListProp_1.removeChild(child); }
                        } };
                }
            }
            else if (prop instanceof properties.PartProperty && prop.get() === child) {
                return { value: {
                        containingProperty: prop,
                        detach: function () { return prop.set(null); }
                    } };
            }
        };
        for (var i = 0; i < props.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return undefined;
    };
    /**
     * Detaches the given child from any (part) property that contained it.
     */
    Structure.prototype._detachChild = function (child) {
        var handle = this._childHandle(child);
        if (handle) {
            handle.detach();
        }
    };
    /**
     * This model element is no longer part of the model, and can be cleaned up.
     */
    Structure.prototype._dispose = function () {
        // NB: version-wise 'unavailable' props are included!
        this._properties.forEach(function (prop) { return prop.dispose(); });
        // TODO: clean from element cache if element, clean from global cache if unit, delete this.unit.elementsCache[this.id];
    };
    /**
     * Update an existing (probably partial) interface with real contents received from the server.
     */
    Structure.prototype._updateWithJson = function (json) {
        // Only allow to go from partial to full documents once, of course, later on, a full merge would be required
        this._isPartial = false;
        this._isUpdating = true;
        this._updateWithJsonImpl(json);
        this._isUpdating = false;
    };
    Structure.prototype._updateWithJsonImpl = function (json) {
        for (var key in json) {
            if (key !== "$ID" && key !== "$Type" && this["__" + key] instanceof abstract_property_1.AbstractProperty) {
                this["__" + key].updateWithRawValue(json[key]);
            }
        }
    };
    Structure.prototype._sendCreateDelta = function (owner, parentPropertyName) {
        throw new Error("Abstract!");
    };
    Structure.prototype._scheduleDeltaAfterCreate = function (delta) {
        // if the create was not send yet to the server, delay this delta until that is done:
        if (this._isNew) {
            this._pendingDeltasAfterCreate.push(delta);
        }
        else {
            delta.unitId = this.unit.id;
            this.unit._model._sendDelta(delta);
        }
    };
    /**
     * Sends the change delta in case a simple property has changed.
     */
    Structure.prototype._sendChangeDelta = function (propertyName, newValue, changeType, index) {
        if (changeType === void 0) { changeType = deltas.MutatorTypes.CHANGE; }
        if (index === void 0) { index = -1; }
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var mutator = (function () {
            switch (changeType) {
                case deltas.MutatorTypes.CHANGE: {
                    var changeMutator = {
                        value: newValue,
                        mutatorType: changeType
                    };
                    if (index >= 0) {
                        changeMutator.updateIndex = index;
                    }
                    return changeMutator;
                }
                case deltas.MutatorTypes.ADD: return {
                    value: newValue,
                    mutatorType: changeType,
                    insertionIndex: index
                };
                case deltas.MutatorTypes.REMOVE: return {
                    removalIndex: index,
                    mutatorType: changeType
                };
                case deltas.MutatorTypes.MOVE: return {
                    fromIndex: 0,
                    toIndex: index,
                    mutatorType: changeType
                };
                default: {
                    throw new Error("changeType '" + changeType + "' unknown (in deltas.MutatorTypes)");
                }
            }
        })();
        this._scheduleDeltaAfterCreate({
            unitId: undefined,
            elementId: this.id,
            deltaType: deltas.DeltaTypes.UPDATE_PROPERTY_VALUE,
            propertyName: propertyName,
            mutator: mutator
        });
    };
    /**
     * Sends the delete in case that we were removed from the model.
     */
    Structure.prototype._sendDeleteDelta = function () {
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var deleteDelta = {
            unitId: this.unit && this.unit.id,
            elementId: this.id,
            deltaType: deltas.DeltaTypes.DELETE_ELEMENT
        };
        if (this._isNew) {
            this._pendingDeltasAfterCreate.push(deleteDelta);
        }
        else {
            this.unit._model._sendDelta(deleteDelta);
        }
    };
    Structure.prototype._markCurrentValuesAsDefaults = function () {
        this.allProperties().forEach(function (property) {
            if (property instanceof properties.PrimitiveProperty) {
                property.markCurrentValueAsDefault();
            }
        });
    };
    /**
     * Deletes a model from the model.
     * This will automatically remove the item from its model parent,
     * and update incoming references and send server changes.
     */
    Structure.prototype.delete = function () {
        // TODO: to be overriden for structural units
        this._dispose();
    };
    Structure.prototype.toJSON = function () {
        var json = {
            $id: this.id,
            $type: this.typeName
        };
        this.allProperties().forEach(function (property) {
            var propertyJson = property._toJSON();
            if (typeof propertyJson !== "undefined") {
                json[property["name"]] = propertyJson;
            }
        });
        return json;
    };
    Structure.prototype.allProperties = function () {
        return this._properties.filter(function (prop) { return prop.isAvailable; });
    };
    Structure.prototype.traverse = function (visit) {
        this._assertLoaded();
        visit(this);
        this.allProperties().forEach(function (property) {
            if (property instanceof properties.PartProperty) {
                var value = property.get();
                if (value) {
                    value.traverse(visit);
                }
            }
            else if (property instanceof properties.PartListProperty) {
                property.get().map(function (value) {
                    if (value) {
                        value.traverse(visit);
                    }
                });
            }
        });
    };
    Structure.prototype.traversePublicParts = function (visit) {
        visit(this);
        this.allProperties().forEach(function (property) {
            if (!property.isPublic) {
                return;
            }
            if (property instanceof properties.PartProperty) {
                var value = property.get();
                if (value) {
                    value.traversePublicParts(visit);
                }
            }
            else if (property instanceof properties.PartListProperty) {
                property.get().map(function (value) {
                    if (value) {
                        value.traversePublicParts(visit);
                    }
                });
            }
        });
    };
    Structure.prototype.getContainerAs = function (containerType) {
        if (!(this.container instanceof containerType)) {
            throw new Error("instance of " + this.typeName + " is not contained by a " + (typeof containerType));
        }
        return this.container;
    };
    /*
     * Typing containerType and this method's return type as follows does not work:
     *
     *  protected getContainerAs<T extends aliases.Container><containerType:new(...args:any[])=>T { ...; return <T>this.container; }
     *
     * TypeScript does not allow T to be an abstract type, since then it's constructor (i.e., containerType) is non-callable.
     * This arises e.g. for AppServices$ConsumedAppService which is contained by Projects$FolderBase.
     */
    Structure.prototype.deepCopyInto = function (newParent, targetPropertyName) {
        // MWE: in future, should be wrapped in undo context / transaction
        // Maps old ids to new structures
        var idMap = {};
        // Futures that should fix not yet resolved by-id refs
        var unresolvedIdentifierFixers = [];
        var clone = this._deepCopyStructureInto(newParent, targetPropertyName, idMap, unresolvedIdentifierFixers);
        unresolvedIdentifierFixers.forEach(function (fixer) { return fixer(idMap); });
        return clone;
    };
    Structure.prototype._deepCopyStructureInto = function (newParent, targetPropertyName, idMap, unresolvedIdentifierFixers) {
        if (!newParent) {
            throw new Error("Cannot deep copy, no new parent provided");
        }
        else if (!newParent.isLoaded) {
            throw new Error("Cannot deep copy, cannot copy into a target that is not loaded");
        }
        var clone;
        if (this instanceof units.AbstractUnit || this instanceof units.ModelUnit) {
            // For constucting, ModelUnits follow semantics of AbstractUnits although they inherit from AbstractElement
            clone = instances_1.instancehelpers.createUnit(newParent, this.constructor);
            if (this instanceof units.ModelUnit) {
                // ModelUnits can be referred to by Id by children
                idMap[this.id] = clone;
            }
        }
        else if (this instanceof elements.Element) {
            var targetProp = newParent["__" + targetPropertyName];
            if (!targetProp) {
                throw new Error("Cannot deep copy, new parent property does not exist: " + targetPropertyName);
            }
            var parentPropertyIsList = targetProp instanceof properties.PartListProperty;
            clone = instances_1.instancehelpers.createElement(newParent, this.constructor, targetPropertyName, parentPropertyIsList);
            idMap[this.id] = clone;
        }
        else if (this instanceof units.StructuralUnit) {
            // See comments in StructuralChildProperties. Could be enabled techically, but probably not desirable
            throw new Error("DeepCopy of structural units like Folders and Modules is not support");
        }
        else {
            throw new Error("Illegal error in DeepCopy, type not supported: " + this.typeName);
        }
        this.allProperties()
            .filter(function (property) { return property.isAvailable; })
            .forEach(function (property) { return property.deepCopyInto(clone, idMap, unresolvedIdentifierFixers); });
        return clone;
    };
    return Structure;
}());
exports.Structure = Structure;
/**
 * Late dependencies on others, structures should be defined first for proper inheritance!
 */
var instances_1 = require("./instances");
var deltas = require("./deltas");
var elements = require("./elements");
var abstract_property_1 = require("./properties/abstract-property");
var properties = require("./properties");
var units = require("./units");
