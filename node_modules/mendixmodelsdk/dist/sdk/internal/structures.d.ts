/**
 * "Something" that contains properties.
 * Concrete sub types: MxElement, MxStructuralUnit, MxModelUnit.
 * Abstract sub types: MxAbstractElement, MxAbstractUnit.
 *
 * Each unit in the model is guaranteed to exist only once in memory.
 */
export interface IStructure {
    id: string;
    typeName: string;

    container: aliases.IContainer;
    isLoaded: boolean;
    versionInfo: StructureVersionInfo;
    /**
     * Unit that owns/contains this thing.
     */
    unit: units.IAbstractUnit;
    model: IAbstractModel;


    /**
     * Renders the structure as plain JSON (without observables magic).
     * This is intended for debugging and development convenience.
     * Note that the resulting object is not of the interface type corresponding to this structure.
     */
    toJSON(): Object;
    allProperties(): AbstractProperty<any, any>[];
    /**
     * Traverses this structure by calling the provided visitor function
     * on itself and all the structures contained (as part) by it,
     * in depth-first order, and it returns synchronously after that.
     * Traverse will visit all descendants of the structure, so make sure it is loaded first.
     */
    traverse(visit: (structure: IStructure) => void): void;
    /**
     * Traverses this structure by calling the provided visitor function
     * on itself and all the structures contained (as part) by it,
     * in depth-first order, and it returns synchronously after that.
     * This visitor will only access the parts of the structure that are publicly visible,
     * in other words, which are part of the interface of the structure.
     */
    traversePublicParts(visit: (structure: IStructure) => void): void;
}
export declare type AbstractPartProperty = properties.PartProperty<any> | properties.PartListProperty<any>;
export interface IChildHandle {
    containingProperty: AbstractPartProperty;
    /** Detaches the child from `containingProperty` - can lead to deletion of the child. */
    detach(): void;
}
export declare abstract class Structure implements IStructure {

    typeName: string;
    id: string;

    container: aliases.IContainer;




    /**
     * These deltas where created before the create delta of this element was submitted to the server.
     * As soon as this happens, the queue is processed and should stay empty.
     * Each element is either an delta, or a new child that was added under a specific property.
     */


    constructor(_model: AbstractModel, typeName: string, id: string, _isPartial?: boolean, container?: aliases.IContainer);


    readonly model: IAbstractModel;
    readonly versionInfo: StructureVersionInfo;
    readonly unit: units.IAbstractUnit;
    readonly isLoaded: boolean;
    /**
     * Asserts that the complete element is available, and not just its public part.
     */


    /**
     * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
     */

    /**
     * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
     */

    /**
     * Finds the given child among the properties of this structure,
     * returning a handle to detach it later when appropriate based on in which property is was found.
     */

    /**
     * Detaches the given child from any (part) property that contained it.
     */

    /**
     * This model element is no longer part of the model, and can be cleaned up.
     */

    /**
     * Update an existing (probably partial) interface with real contents received from the server.
     */




    /**
     * Sends the change delta in case a simple property has changed.
     */

    /**
     * Sends the delete in case that we were removed from the model.
     */


    /**
     * Deletes a model from the model.
     * This will automatically remove the item from its model parent,
     * and update incoming references and send server changes.
     */
    delete(): void;
    toJSON(): Object;
    allProperties(): AbstractProperty<any, any>[];
    traverse(visit: (structure: IStructure) => void): void;
    traversePublicParts(visit: (structure: IStructure) => void): void;
    protected getContainerAs<T extends aliases.IContainer>(containerType: any): T;
    deepCopyInto(newParent: elements.AbstractElement | units.IStructuralUnit, targetPropertyName?: string): Structure;

}
import * as elements from "./elements";
import { AbstractProperty } from "./properties/abstract-property";
import * as properties from "./properties";
import * as units from "./units";
import { AbstractModel, IAbstractModel } from "./abstract-model";
import * as transport from "./transport-interfaces";
import { StructureVersionInfo } from "./version-checks";
export declare namespace aliases {
    type IContainer = units.IStructuralUnit | elements.IAbstractElement;
    type Container = units.StructuralUnit | elements.AbstractElement;
}
