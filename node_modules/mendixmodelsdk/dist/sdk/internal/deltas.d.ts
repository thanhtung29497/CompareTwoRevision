import * as transport from "./transport-interfaces";
import { common } from "../../common";
import { AbstractModel } from "./abstract-model";
export declare class DeltaTypes {
    static CREATE_ELEMENT: string;
    static UPDATE_PROPERTY_VALUE: string;
    static MOVE_ELEMENT: string;
    static DELETE_ELEMENT: string;
    static CREATE_UNIT: string;
    static DELETE_UNIT: string;
}
export declare class MutatorTypes {
    static CHANGE: string;
    static ADD: string;
    static REMOVE: string;
    static MOVE: string;
}
/**
 * A POTSO that wraps a delta and success/failure callbacks.
 */
export declare class DeltaRequest {
    delta: transport.IDelta;
    onSuccess: common.IVoidCallback;
    onFailure: common.IErrorCallback;
    constructor(delta: transport.IDelta, onSuccess?: common.IVoidCallback, onFailure?: common.IErrorCallback);
}
/**
 * A simple queue implementation for deltas.
 */
export declare class DeltaQueue {
    private model;
    private logToConsole;
    isClosing: boolean;
    private delay;
    private maxDeltasPerBatch;
    private queue;
    private pending;
    private hasError;
    private closeCallback;
    constructor(model: AbstractModel, logToConsole?: boolean);
    /**
     * Closes the "connection" with the Model API Server in the sense that
     * pending delta requests are processed, and that afterwards the given
     * `callback` will be called.
     * This function can only be called once.
     */
    closeConnection(callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
        * Pushes the given `delta` on the queue for scheduling/processing.
        */
    push(delta: DeltaRequest): void;
    /**
        * Schedules the next delta for processing using JS's event queue/loop.
        */
    private schedule();
    private processNext();
}
