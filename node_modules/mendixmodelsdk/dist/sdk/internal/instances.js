"use strict";
var abstract_model_1 = require("./abstract-model");
var versions = require("./version-checks");
var units = require("./units");
var elements = require("./elements");
var utils_1 = require("../utils");
/**
 * Base class for enumerations in the meta model.
 * Literals of an enumeration are generated as public static constants of the generated sub class
 * which are instances of the generated sub class.
 */
var IEnum = (function () {
    function IEnum(_name, lifeCycleInfo) {
        this._name = _name;
        this.versionInfo = new versions.LifeCycle(lifeCycleInfo);
    }
    Object.defineProperty(IEnum.prototype, "name", {
        get: function () { return this._name; },
        enumerable: true,
        configurable: true
    });
    ;
    IEnum.prototype.toString = function () {
        return this._name;
    };
    IEnum.prototype.qualifiedTsLiteralName = function () {
        return this.qualifiedTsTypeName + "." + this._name;
    };
    IEnum.prototype.checkEnumVersion = function (metaModelVersion, includeWarnings) {
        this.versionInfo.reportVersionIssues(metaModelVersion, "Enumeration value '" + this.qualifiedTsLiteralName + "'", includeWarnings);
    };
    return IEnum;
}());
exports.IEnum = IEnum;
// namespace is a workaround for typedoc
var instancehelpers;
(function (instancehelpers) {
    /**
     * Given some a (normalized) JSON representation of a unit,
     * creates an instance of the corresponding `unit.AbstractUnit` sub class (structural/model)
     * and populates that from the JSON.
     * Should only be called if this unit was not already in memory.
     */
    function abstractUnitJsonToInstance(model, json, isPartial) {
        if (!json) {
            return null;
        }
        var unit = createStructure(lookupClass(json.$Type, model._allModelClasses()), model._unitsCache, function (initializer) { return new initializer(model, json.$Type, json.$ID, isPartial, null); }, json);
        if (unit) {
            model._cache(unit);
        }
        return unit;
    }
    instancehelpers.abstractUnitJsonToInstance = abstractUnitJsonToInstance;
    /**
     * Given some a (normalized) JSON representation of a model element,
     * creates an instance of the corresponding `elements.Element`
     * and populates that from the JSON.
     * Will update existing elements if this element was created before.
     */
    function modelElementJsonToInstance(model, unit, container, json, isPartial) {
        if (!json) {
            return null;
        }
        return createStructure(lookupClass(json.$Type, model._allModelClasses()), unit._elementsCache, function (initializer) { return new initializer(model, json.$Type, json.$ID, isPartial, unit, container); }, json);
    }
    instancehelpers.modelElementJsonToInstance = modelElementJsonToInstance;
    /**
     * Creates a new element for a SDK user.
     */
    function createElement(owner, constructor, parentPropName, parentPropIsList) {
        if (!owner) {
            throw new Error("Please provide a container or model");
        }
        var model = owner instanceof abstract_model_1.AbstractModel ? owner : owner._model;
        var instance = new constructor(model, constructor.typeName, utils_1.utils.randomUuid(), false, null, null);
        checkStructureVersion(instance, true);
        instance._initializeNewInstance();
        if (parentPropName && (!(owner instanceof abstract_model_1.AbstractModel))) {
            if (parentPropIsList) {
                owner[parentPropName].push(instance);
            }
            else {
                owner[parentPropName] = instance;
            }
        }
        return instance;
    }
    instancehelpers.createElement = createElement;
    /**
     * Creates a new unit for a SDK user.
     */
    function createUnit(container, constructor) {
        if (!(container instanceof units.StructuralUnit)) {
            throw new Error("Expected container");
        }
        var model = container._model;
        var instance = new constructor(model, constructor.typeName, utils_1.utils.randomUuid(), false, container);
        checkStructureVersion(instance, true);
        instance._initializeNewInstance();
        instance._handleCreateSelf();
        model._cache(instance);
        model._addUnitToStructuralParent(instance, container);
        return instance;
    }
    instancehelpers.createUnit = createUnit;
    /**
     * Type -> class (the constructor function, technically) lookup, e.g. "DomainModels$Entity" -> DomainModels.Entity
     */
    function lookupClass(qualifiedTypeName, classes) {
        if (!qualifiedTypeName) {
            return nullWithError("cannot look up initializer for a falsy qualified type name");
        }
        var $index = qualifiedTypeName.indexOf("$");
        if ($index < 0 || $index === qualifiedTypeName.length - 1) {
            return nullWithError("qualified type '" + qualifiedTypeName + "' is not of the form '<meta model>$<type name>");
        }
        var metaModelName = qualifiedTypeName.substring(0, $index).toLowerCase();
        var className = qualifiedTypeName.substring($index + 1);
        if (!classes[metaModelName]) {
            return nullWithError("no meta model with name '" + metaModelName + "' exists");
        }
        if (!classes[metaModelName][className]) {
            return nullWithError("no type with name '" + metaModelName + "$" + className + " exists");
        }
        return classes[metaModelName][className];
    }
    instancehelpers.lookupClass = lookupClass;
    function structureAffectsQualifiedNames(structure) {
        return structure._declaredAsNamespace || (structure instanceof elements.AbstractElement && structure._isByNameReferrable());
    }
    instancehelpers.structureAffectsQualifiedNames = structureAffectsQualifiedNames;
})(instancehelpers = exports.instancehelpers || (exports.instancehelpers = {}));
function checkStructureVersion(instance, includeWarnings) {
    instance.versionInfo.checkStructureVersion(instance, includeWarnings);
}
/**
 * Creates (deserializes) a structure based on incoming JSON.
 */
function createStructure(initializer, cache, callback, json) {
    // element already known?
    if (cache[json.$ID]) {
        var element = cache[json.$ID];
        element._updateWithJson(json);
        // TODO: what if container was changed?
        return element;
    }
    if (initializer) {
        var instance = callback(initializer);
        instance._updateWithJsonImpl(json);
        instance._isUpdating = false; // initialization is done
        checkStructureVersion(instance, false);
        return instance;
    }
    return null;
}
function nullWithError(message) {
    console.error(message);
    return null;
}
