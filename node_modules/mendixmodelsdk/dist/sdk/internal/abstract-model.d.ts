import { common } from "../../common";
import { configuration } from "../config";
import { IAbstractUnit, StructuralUnit } from "./units";
import { IWorkingCopy, IDelta, IAbstractUnitJson, IGetFilesOptions, IEnvironmentStatus, IDeployJobStatus } from "./transport-interfaces";
import { ByNameReference } from "./references";
import { DeltaQueue } from "./deltas";
import { IModelApiClient, IEditorData } from "./model-api-client";
import { Structure, IStructure } from "./structures";
import { IAbstractElement } from "./elements";
import { Version } from "./version-checks";
import QualifiedNameCache from "./qualified-name-cache";
/**
 * This interface exposes a single Mendix Model.
 * This interface contains the parts of the {@link Model} that are exposed through the SDK.
 */
export interface IAbstractModel {
    /**
     * Working copy id of the current opened model (read only)
     */
    id: string;
    /**
     * The meta data of the model.
     */
    metadata: IWorkingCopy;
    /**
     * The Mendix meta model version related to the project.
     */
    metaModelVersion: Version;
    /**
     * The Mendix product version the model was created with/in.
     * Note: this does not have to equal the meta model version.
     */
    mxVersionForModel: Version;
    /**
     * Ends the connection with the Model API client.
     * Flushes any pending deltas and invokes the callback once complete.
     * (Errors will be handled through the default modelstore error handler.)
     */
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Deletes this model from the server, and the (SDK) client.
     * If you are altering the model before deleting it, make sure to call this method in the callback of {@link closeConnection}.
     *
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Exports this model as MPK.
     * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
     * If outFilePath is empty, the raw request response will be provided in the callback
     */
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Get the deployment status of the working copy. Can be STARTED, STARTING, UPDATING, STOPPED and APP_NOT_FOUND.
     * Contains other deployment info as well.
     */
    getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback?: common.IErrorCallback): any;
    /**
     * Start async deploy flow, creates new app job and returns it.
     * This call immediately returns after successfully initiating the deployment job, and it's progress
     * can be tracked using `getAppUpdateStates.
     *
     * A start update packs the mpk and sends it to the the cloud environment to update the application,
     * a new application will be provisioned if needed.
     *
     * The update job will always converge to a stable state (one of "started" | "failed" | "consistencyerrors").
     * Use the returned job id to poll for this.
     */
    startAppUpdate(callback: common.ICallback<IDeployJobStatus>, errorCallback?: common.IErrorCallback): any;
    /**
     * Retrieves App Job by jobId. See also `startAppUpdate`.
     * In the response the most important field is status.
     *
     * Polling for job status should stop once it has reeached "started" | "failed" | "consistencyerrors".
     * Jobs will be cleaned up 10 minutes after the have reached one of this states.
     */
    getAppUpdateStatus(jobId: string, callback: common.ICallback<IDeployJobStatus>, errorCallback?: common.IErrorCallback): any;
    /**
     * Given an id, fetches a complete unit. The result might be returned from the cache.
     * Use this method if you have just a unit Id, otherwise, unit.fetch() is a simpler alternative.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, forceRefresh: boolean, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): any;
    /**
     * Returns all units in the project, including modules, folders etc.
     * To retrieve all "real" documents (pages, microflows etc.), use allDocuments().
     */
    allUnits(): IAbstractUnit[];
    /**
     * Given a qualified name, returns a module.
     * (For modules, their qualified name equals their name)
     */
    findModuleByQualifiedName(qname: string): any;
    /**
     * Returns an array of all filepaths in the working copy.
     */
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): any;
    /**
     * Returns all files or a subset of files
     * options.filter: glob pattern to limit the set of files
     * options.format: "json" or "zip"
     * options.path: useful if format is "zip". If provided the zip will be stored on disk
     */
    getFiles(callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback): any;
    getFiles(options: IGetFilesOptions, callback: (response?: string[] | any) => void, errorCallback: common.IErrorCallback): any;
    /**
     * Downloads the file specified by the supplied filepath.
     * If filePath is empty, the raw request response will be provided in the callback
     */
    getFile(filePath: string, outFilePath: string, callback: (response?: any) => void, errorCallback: common.IErrorCallback): any;
    /**
     * Uploads the supplied file to the specified filepath.
     */
    putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Deletes the file with the specified filepath.
     */
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Returns UUIDs for helper working copies for each supported Mendix version.
     *
     * These are pre-defined working copies that are accessible for read operations,
     * and contain units that might come in handy when creating pages from templates.
     */
    getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback): any;
}
export interface IUnitsCache {
    [id: string]: IAbstractUnit;
}
export interface IUnitsByTypeCache {
    [type: string]: IAbstractUnit[];
}
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
export declare abstract class AbstractModel implements IAbstractModel {



    metadata: IWorkingCopy;
    metaModelVersion: Version;
    mxVersionForModel: Version;
    /**
     * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
     */

    /**
     * Map qualifiedName -> AbstractElement[]; the same qualified name could potentially refer to different kind of objects;
     * e.g. MyFirstModule.SecondThing could both be an entity or a microflow.
     *
     * A structure has a qualified name precisely if it's public, publicly contained through namespaces and
     * has a public, 1-string-typed `name` property.
     * In other words: every structure having a qualified name is already present in the interface of the containing unit.
     * So, as soon as the `_processLoadedUnitInterfaces` has been called the cache is complete (no lazy loading).
     * (It still needs to be continuously updated obviously.)
     */

    /**
     * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
     * Please extend the type whenever applicable, for convenience of the programmer.
     */




    constructor(_client: IModelApiClient, _errorHandler: common.IErrorCallback, _connectionConfig: configuration.ISdkConfig);
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Instantiates a new Model that can communicate with the server for sending and receiving documents.
     * Loading a Model will automatically fetches all unit interfaces for this working copy and invokes the (success) callback,
     * or calls the errorHandler if this fails.
     */
    static create(client: IModelApiClient, workingCopyInfo: configuration.ICreateWorkingCopyParameters, callback: common.ICallback<IWorkingCopy>, errorCallback: common.IErrorCallback): void;
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
     * or call the errorHandler if this fails.
     */
    static read<IT extends IAbstractModel, CT extends AbstractModel>(client: IModelApiClient, workingCopyId: string, connectionConfig: configuration.ISdkConfig, instance: CT, callback: (model: IT) => void, errorCallback: common.IErrorCallback): void;
    private static readImpl(instance, workingCopyId, callback);
    readonly id: string;
    protected readonly _unitTypes: string[];
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     */

    /**
     * Returns a defensive collection of all units in this model.
     */
    allUnits(): IAbstractUnit[];

    /**
     * Registers the given `unit` in the cache(s).
     */

    /**
     * Unregisters the given `unit` from the cache(s).
     */

    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, forceRefresh: boolean, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): any;



    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     */



    /**
     * Structural units have children (e.g., folders have documents), but in storage the inverse is stored:
     * documents specify in which parent they reside.
     * However, in the SDK we want to be able to read the children of a folder, so these kind of properties are expressed
     * using StructuralChild(List)Property objects, see `properties/structural.ts`.
     * We notify structural parents that a child was added upon loading a child structure,
     * so that parent can do the appropriate bookkeeping at that time (and only once).
     * This way we avoid having to visit all unit interfaces to gather all childrenof a specific structural child (list) property.
     */


    /**
     * If a reference is broken, it should be registered here, so that it can be restored once model elements are renamed.
     */

    /**
     * If a reference is no longer broken, it should be unregistered here.
     */


    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     */


    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    getFiles(callback: common.ICallback<string[] | void>, errorCallback: common.IErrorCallback): any;
    getFiles(options: IGetFilesOptions, callback: common.ICallback<string[] | void>, errorCallback: common.IErrorCallback): any;
    getFile(filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    putFile(inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    getAppEnvironmentStatus(callback: common.ICallback<IEnvironmentStatus>, errorCallback?: common.IErrorCallback): void;
    getAppUpdateStatus(jobId: string, callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    startAppUpdate(callback: common.ICallback<IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback): void;
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.typeName, "Expenses.Expense.Price");`
     */


    findModuleByQualifiedName(qname: string): void;


}
export interface ISubResolver {
    (parent: IStructure, partName: string): IStructure;
}
