import * as structures from "./structures";
import { AbstractModel } from "./abstract-model";
/**
 * The `elements` module contains various classes and functions
 * related to elements, specifically: (abstract) elements.
 */
/**
 * Abstract elements are structures that are referable by name.
 * Sub types: (I)Element and (I)ModelUnit.
 */
export interface IAbstractElement extends structures.IStructure {
    isLoaded: boolean;
    qualifiedName: string;


    load<T extends IAbstractElement>(callback?: (elem: T) => void): any;
    load<T extends IAbstractElement>(): T;
    getBackReferences(): references.AbstractReference<AbstractElement>[];
    clearBackReferences(): void;
}
/**
 * See {@link IAbstractElement}.
 */
export declare abstract class AbstractElement extends structures.Structure implements IAbstractElement {
    container: structures.aliases.Container;

    constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, container: structures.aliases.IContainer);
    /**
     * Checks whether all properties are available at the moment
     *  - if false, a load is required to access these properties.
     */
    readonly isLoaded: boolean;
    /**
     * Calculates the fully qualified name of this element,
     * by visiting all parents that have $isNamespace set to `true`.
     */
    readonly qualifiedName: string;
    /**
     * Transforms a IElement interface into a Element class, loading the containing unit if necessary.
     * (Those are technically already the same, but this function makes sure its properties are available.)
     *
     * - If invoked without callback, it checks whether the properties are available or it will throw;
     * - If invoked with callback, it will load the data from the server if needed, and then invoke the callback.
     */
    load<T extends AbstractElement>(callback: (elem: T) => void, forceRefresh?: boolean): any;
    load<T extends AbstractElement>(): T;
    /**
     * updateElementsContainer recursively sets the unit to which this elements belong
     * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
     * an element is actually added to the tree (buy pushing / assigning it to some part property)
     */

    /**
     * Return true if this is an abstractElement that might be referred to by some other element.
     * If true, this element is maintained in the qualifiedNamesCache
     */

    /**
     * Adds a back reference, i.e. a reference pointing to us,
     * which needs to be informed of changes to this element (including deletion).
     */

    /**
     * Removes the given back reference.
     */

    getBackReferences(): references.AbstractReference<AbstractElement>[];
    clearBackReferences(): void;
    delete(): void;
}
/**
 * An element (short for: "model element") lives inside a unit
 * and contains (per being an IStructure) property values.
 */
export interface IElement extends IAbstractElement {
}
export declare type IElementConstructor = typeof Element;
export declare class Element extends AbstractElement implements IElement {
    container: AbstractElement;

    constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, unit: units.ModelUnit, container: AbstractElement);
    readonly unit: units.ModelUnit;
    /**
     * Checks whether all attributes are available ATM
     *  -  if false, a load is required to access these properties.
     */
    readonly isLoaded: boolean;

    /**
     * Sends the appropriate create delta to the server, and also sends all pending deltas,
     * after this element has been assigned to some parent.
     */

    /**
     * Sends the appropriate create delta to the server
     * after this element has been moved to a new parent.
     */

    deepCopyInto(newParent: AbstractElement, targetPropertyName: string): AbstractElement;
}
import * as references from "./references";
import * as units from "./units";
