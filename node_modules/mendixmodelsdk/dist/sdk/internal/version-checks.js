"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils_1 = require("../utils");
var Version = (function () {
    function Version(major, minor, patch) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        // (empty constructor)
    }
    /**
     * Parses and @returns the given string as a Version object.
     *
     * This function is memoised to keep memory and time consumption low,
     * given that only a handful of versions exist at any time anyway.
     */
    Version.parse = function (versionString) {
        if (!versionString) {
            return null;
        }
        var version = Version.memoisMap[versionString];
        if (!version) {
            var _a = versionString.split(".").map(function (x) { return parseInt(x, 10); }), major = _a[0], minor = _a[1], patch = _a[2];
            version = new Version(major, minor, patch);
            Version.memoisMap[versionString] = version;
        }
        return version;
    };
    /**
     * Returns true if this version is strictly larger than the provided version.
     */
    Version.prototype.isAfter = function (other) {
        return this.major > other.major
            || (this.major === other.major && this.minor > other.minor)
            || (this.major === other.major && this.minor === other.minor && this.patch > other.patch);
    };
    Version.prototype.isAfterOrEqual = function (other) {
        return this.isEqualTo(other) || this.isAfter(other);
    };
    /**
     * Returns true if this version is strictly smaller compared to the provided version.
     */
    Version.prototype.isBefore = function (other) {
        return this.major < other.major
            || (this.major === other.major && this.minor < other.minor)
            || (this.major === other.major && this.minor === other.minor && this.patch < other.patch);
    };
    Version.prototype.isBeforeOrEqual = function (other) {
        return this.isEqualTo(other) || this.isBefore(other);
    };
    Version.prototype.isEqualTo = function (other) {
        return this.major === other.major && this.minor === other.minor && this.patch === other.patch;
    };
    Version.prototype.toString = function () {
        return this.major + "." + this.minor + "." + this.patch;
    };
    return Version;
}());
Version.memoisMap = {};
exports.Version = Version;
/**
 * Parses the given string as a sem-Version, ignoring non-numeric and "extra" data,
 * and padding with ".0" where necessary.
 */
function parseAsNormalizedVersion(versionString) {
    var parts = versionString.split(".", 3).map(function (p) { return p.replace(/^(\d*).*$/, function (_, nr) { return nr || "0"; }); });
    while (parts.length < 3) {
        parts.push("0");
    }
    return Version.parse(parts.join("."));
}
exports.parseAsNormalizedVersion = parseAsNormalizedVersion;
var LifeCycleState;
(function (LifeCycleState) {
    LifeCycleState[LifeCycleState["UNAVAILABLE"] = 0] = "UNAVAILABLE";
    LifeCycleState[LifeCycleState["AVAILABLE"] = 1] = "AVAILABLE";
    LifeCycleState[LifeCycleState["DEPRECATED"] = 2] = "DEPRECATED";
    LifeCycleState[LifeCycleState["REMOVED"] = 3] = "REMOVED";
})(LifeCycleState = exports.LifeCycleState || (exports.LifeCycleState = {}));
;
var LifeCycle = (function () {
    function LifeCycle(info) {
        this.deprecationMessage = "";
        this.deletionMessage = "";
        if (info) {
            this.introduced = Version.parse(info.introduced);
            this.deprecated = Version.parse(info.deprecated);
            this.deleted = Version.parse(info.deleted);
            this.deprecationMessage = info.deprecationMessage || "";
            this.deletionMessage = info.deletionMessage || "";
        }
    }
    // TODO  make the following more symmetric
    /**
     * Yields true if this feature is available in the specified version, that is:
     * - it was in base, or added before the specified version
     * - it was not removed yet in the given version
     * - deprecation statues does not influence it results
     */
    LifeCycle.prototype.isAvailableIn = function (version) {
        if (this.isRemovedIn(version)) {
            return false;
        }
        if (!this.introduced || this.introduced.isBeforeOrEqual(version)) {
            return true;
        }
        return false;
    };
    /**
     * Yields true only if the feature is available, (added but not yet removed) and deprecated in the specified version.
     */
    LifeCycle.prototype.isDeprecatedIn = function (version) {
        return this.isAvailableIn(version) && this.deprecated != null && this.deprecated.isBeforeOrEqual(version);
        // Note: '!==' causes almost all unit tests to fail...
    };
    /**
     * Yields true only if this version was actively removed in the given version.
     * Doesn't yield true if the feature was not yet introduced in the given version (see isAvailableIn for that)
     */
    LifeCycle.prototype.isRemovedIn = function (version) {
        return this.deleted != null && this.deleted.isBeforeOrEqual(version);
        // Note: '!==' causes almost all unit tests to fail...
    };
    LifeCycle.prototype.getCurrentState = function (version) {
        if (this.isRemovedIn(version)) {
            return LifeCycleState.REMOVED;
        }
        if (!this.isAvailableIn(version)) {
            return LifeCycleState.UNAVAILABLE;
        }
        if (this.isDeprecatedIn(version)) {
            return LifeCycleState.DEPRECATED;
        }
        return LifeCycleState.AVAILABLE;
    };
    /**
     * Checks a version based on this lifecycle.
     * Returns true if something is thrown or warned, otherwise false
     */
    LifeCycle.prototype.reportVersionIssues = function (version, aboutWhatMessage, printWarnings) {
        switch (this.getCurrentState(version)) {
            case LifeCycleState.UNAVAILABLE:
                throw new Error(aboutWhatMessage + " is not yet available in Mendix version " + version + ". It was introduced in Mendix version " + this.introduced);
            case LifeCycleState.DEPRECATED:
                if (printWarnings) {
                    utils_1.utils.warnOnce(aboutWhatMessage + " is deprecated in Mendix version " + version + " (deprecated since Mendix version " + this.deprecated + ") "
                        + ("and should no longer be instantiated: " + this.deprecationMessage));
                }
                return true;
            case LifeCycleState.REMOVED:
                throw new Error(aboutWhatMessage + " can no longer be instantiated in Mendix version " + version + " "
                    + ("(removed since Mendix version " + this.deleted + "): " + this.deletionMessage + "."));
            case LifeCycleState.AVAILABLE:
                return false;
            default:
                throw new Error("Illegal state");
        }
    };
    return LifeCycle;
}());
exports.LifeCycle = LifeCycle;
var ModifierValueHistory = (function () {
    /**
     * defaultFallback indiciates whether the absence of a lifecycle yields true or false
     */
    function ModifierValueHistory(lifecycle, defaultFallback) {
        if (lifecycle) {
            this.latestValue = lifecycle.currentValue;
            this.changedIn = lifecycle.changedIn ? lifecycle.changedIn.map(Version.parse) : [];
            for (var i = 0; i < this.changedIn.length - 1; i++) {
                if (!this.changedIn[i + 1].isBefore(this.changedIn[i])) {
                    throw new Error("The list of version changes is not ordered correctly: " + JSON.stringify(lifecycle));
                }
            }
        }
        else {
            this.changedIn = [];
            this.latestValue = defaultFallback;
        }
    }
    ModifierValueHistory.prototype.isEnabledIn = function (version) {
        if (this.changedIn.length === 0) {
            return this.latestValue;
        }
        var nonRelevant = this.changedIn.filter(function (changedInVersion) { return version.isBefore(changedInVersion); });
        // odd or even number of toggles from now back to the relevant version ?
        return nonRelevant.length % 2 === 0 ? this.latestValue : !this.latestValue;
    };
    return ModifierValueHistory;
}());
exports.ModifierValueHistory = ModifierValueHistory;
var StructureType;
(function (StructureType) {
    StructureType[StructureType["StructuralUnit"] = 0] = "StructuralUnit";
    StructureType[StructureType["ModelUnit"] = 1] = "ModelUnit";
    StructureType[StructureType["Element"] = 2] = "Element";
})(StructureType = exports.StructureType || (exports.StructureType = {}));
;
var VersionInfo = (function () {
    function VersionInfo() {
    }
    VersionInfo.prototype.checkSameModelVersion = function (model, otherModel) {
        if (model !== otherModel) {
            throw new Error("It is not possible to combine values coming from two different models");
        }
    };
    return VersionInfo;
}());
exports.VersionInfo = VersionInfo;
var StructureVersionInfo = (function (_super) {
    __extends(StructureVersionInfo, _super);
    function StructureVersionInfo(info, structureType) {
        var _this = _super.call(this) || this;
        _this.structureType = structureType;
        _this.properties = {};
        _this.availability = new LifeCycle(info);
        _this.isPublic = structureType === StructureType.Element
            ? new ModifierValueHistory(info.public, false)
            : new ModifierValueHistory(null, true);
        _this.isExperimental = new ModifierValueHistory(info.experimental, false);
        var propertiesArePublicByDefault = structureType === StructureType.StructuralUnit;
        for (var key in info.properties) {
            _this.properties[key] = new PropertyVersionInfo(info.properties[key], propertiesArePublicByDefault);
        }
        _this.defaultPropertyInfo = new PropertyVersionInfo(null, propertiesArePublicByDefault);
        return _this;
    }
    StructureVersionInfo.prototype.checkStructureVersion = function (instance, includeWarnings) {
        var availability = this.availability;
        var metaModelVersion = instance.model.metaModelVersion;
        var typeName = instance.typeName;
        var hasVersionIssues = availability.reportVersionIssues(metaModelVersion, "Type '" + typeName + "'", includeWarnings);
        if (!hasVersionIssues) {
            if (includeWarnings && this.isExperimental && this.isExperimental.isEnabledIn(metaModelVersion)) {
                utils_1.utils.warnOnce("Type '" + typeName + "' is experimental in Mendix meta model version " + metaModelVersion + " and should be used with care.");
            }
        }
        // There is no need to check super structures: each structure has its own complete set of annotations in the meta model.
    };
    StructureVersionInfo.prototype.getPropertyVersionInfo = function (name) {
        return this.properties[name] ? this.properties[name] : this.defaultPropertyInfo;
    };
    return StructureVersionInfo;
}(VersionInfo));
exports.StructureVersionInfo = StructureVersionInfo;
var PropertyVersionInfo = (function (_super) {
    __extends(PropertyVersionInfo, _super);
    function PropertyVersionInfo(info, publicByDefault) {
        var _this = _super.call(this) || this;
        _this.availability = new LifeCycle(info);
        _this.isPublic = new ModifierValueHistory(info ? info.public : null, publicByDefault);
        _this.isRequired = new ModifierValueHistory(info ? info.required : null, false);
        return _this;
    }
    PropertyVersionInfo.prototype.checkPropertyVersion = function (property, includeWarnings) {
        var name = property.name;
        var metaModelVersion = property.parent.model.metaModelVersion;
        var availability = property.parent.versionInfo.getPropertyVersionInfo(name).availability;
        var typeName = property.parent.typeName;
        availability.reportVersionIssues(metaModelVersion, "Property '" + name + "' of type '" + typeName + "'", includeWarnings);
    };
    return PropertyVersionInfo;
}(VersionInfo));
exports.PropertyVersionInfo = PropertyVersionInfo;
function createInVersionCheck(model, typeName, allowedVersions) {
    var version = model.metaModelVersion.toString();
    if (allowedVersions.indexOf(version) === -1) {
        throw new Error("In Mendix version " + version + " it is illegal on instances of " + typeName + " to call the \"createIn\" method, "
            + "either because it's ambiguously contained or derived.");
    }
}
exports.createInVersionCheck = createInVersionCheck;
function isNotBefore(versionString, model) {
    return model.metaModelVersion.isAfterOrEqual(Version.parse(versionString));
}
exports.isNotBefore = isNotBefore;
