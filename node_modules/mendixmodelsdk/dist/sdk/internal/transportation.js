"use strict";
var version_1 = require("../../version");
var utils_1 = require("../utils");
var fs = require("fs");
var restler; // imported in constructor
var SHORT_TIMEOUT = 1 * 60 * 1000;
var LONG_TIMEOUT = 15 * 60 * 1000;
/**
 * Default implementation of {@link ITransportation} that communicates with the Model API Server over
 * HTTP using Restler.
 */
var RestTransportation = (function () {
    function RestTransportation(config) {
        this.config = config;
        restler = require("restler");
        /**
         * globalAgent.maxSockets: from documentation: By default set to Infinity [in Node 0.12, red].
         * Determines how many concurrent sockets the agent can have open per origin.
         * Origin is either a 'host:port' or 'host:port:localAddress' combination.
         *
         * This is set globally because Restler cannot set this per request, although it claims it can in the docs.
         */
        require("http").globalAgent.maxSockets = 20;
        require("https").globalAgent.maxSockets = 20;
    }
    RestTransportation.prototype.request = function (method, url, data, success, failure, longTimeout) {
        var _method = this.sanitizedMethod(method);
        var _url = this.url(url);
        var options = this.generateStandardOptions();
        options["headers"]["content-type"] = "application/json";
        if (longTimeout) {
            options.timeout = LONG_TIMEOUT;
        }
        if (data) {
            options["data"] = JSON.stringify(data);
        }
        this.handleRequest(restler[_method](_url, options), _url, data, function (responseData, response) { return success(responseData); }, failure);
    };
    RestTransportation.prototype.requestMultipartBinaryFileUpload = function (method, url, data, fileParameterName, filename, 
        // FIXME  filename also allowing a Blob is a kludge solely for the Web Modeler - remove '| Blob' in next major version
        success, failure) {
        var _method = this.sanitizedMethod(method);
        var _url = this.url(url);
        var options = this.generateStandardOptions();
        options["multipart"] = true;
        options.timeout = LONG_TIMEOUT; // 5 minutes: uploading mpk's takes some time, and can be quite large.
        if (!filename) {
            throw new Error("File to upload is missing.");
        }
        var fileStats = fs.statSync(filename);
        var fileSizeInBytes = fileStats["size"];
        var fileContents = restler.file(filename, null, fileSizeInBytes);
        data[fileParameterName] = fileContents;
        options["data"] = data;
        this.handleRequest(restler[_method](_url, options), _url, data, function (responseData, response) { return success(responseData); }, failure);
    };
    RestTransportation.prototype.requestFileDownload = function (method, url, success, failure) {
        var _method = this.sanitizedMethod(method);
        var _url = this.url(url);
        var options = this.generateStandardOptions();
        options["decoding"] = "buffer"; // TODO: in the future we might want to use streams here. Currently Restler does not support streams.
        options.timeout = LONG_TIMEOUT; // downloaded MPK's take some time to build, and can be quite large.
        this.handleRequest(restler[_method](_url, options), _url, null, function (responseData, response) { return success(responseData); }, failure);
    };
    RestTransportation.prototype.sanitizedMethod = function (method) {
        var _method = method.toLowerCase();
        return (_method === "delete") ? "del" : _method; // weird exception :'(
    };
    RestTransportation.prototype.url = function (urlEndpoint) {
        var subUrl = urlEndpoint.substring("/api".length);
        return utils_1.utils.combineUrl(this.config.endPoint, subUrl);
    };
    RestTransportation.prototype.generateStandardOptions = function () {
        var options = {
            timeout: SHORT_TIMEOUT,
            headers: {
                "mendixmodelsdkversion": version_1.SDK_VERSION,
                "User-Agent": "mendixmodelsdk/" + version_1.SDK_VERSION + " " + process.platform + " " + process.arch + " node" + process.versions.node
            }
        };
        // upcasts for correct type
        var backendCredentials = this.config.credentials;
        var sdkCredentials = this.config.credentials;
        if (this.config.credentials && this.config.credentials.username) {
            options.username = this.config.credentials.username;
            if (backendCredentials.password) {
                // Backend credentials
                options.password = backendCredentials.password;
                if (backendCredentials.openid) {
                    options.headers = {
                        openid: backendCredentials.openid
                    };
                }
            }
            else if (sdkCredentials.apikey) {
                // Api key
                options.password = sdkCredentials.apikey;
            }
            else {
                throw new Error("Expected either an API key or password (for selected users only)");
            }
        }
        else {
            throw new Error("No credentials provided");
        }
        return options;
    };
    RestTransportation.prototype.handleRequest = function (request, url, data, success, failure) {
        request
            .on("2XX", function (responseData, response) {
            success(responseData, response);
        })
            .on("4XX", function (responseData, response) {
            failure({
                error: responseData,
                statusCode: response.statusCode,
                url: url
            });
        })
            .on("5XX", function (responseData, response) {
            failure({
                error: responseData,
                statusCode: response.statusCode,
                url: url
            });
        })
            .on("complete", function (result, response) {
            // this callback allways fires; only catch results we haven't caught with 2XX, 4XX and 5XX callbacks
            if (result instanceof Error) {
                if (result["code"] === "ECONNREFUSED") {
                    failure({
                        error: "Not available",
                        description: "The Mendix Model API Server is not available. Please try again later.",
                        url: url
                    });
                }
                else if (result["code"] === "EPIPE") {
                    console.warn("Encountered EPIPE - "
                        + "assuming failure callback is already called for this request with status code 413 (Request Entity Too Large).");
                }
                else {
                    failure({
                        error: "No response",
                        description: "The Mendix Model API Server failed to respond. Result code: " + result["code"],
                        url: url
                    });
                }
            }
        })
            .on("timeout", function () {
            failure({
                error: "Timeout",
                description: "The Mendix Model API Server timed out.",
                url: url
            });
        });
    };
    return RestTransportation;
}());
exports.RestTransportation = RestTransportation;
