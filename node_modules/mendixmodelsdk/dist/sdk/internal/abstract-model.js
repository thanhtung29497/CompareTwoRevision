"use strict";
var mobx_1 = require("mobx");
var deltas_1 = require("./deltas");
var instances_1 = require("./instances");
var version_checks_1 = require("./version-checks");
var utils_1 = require("../utils");
var properties_1 = require("./properties");
var qualified_name_cache_1 = require("./qualified-name-cache");
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
var AbstractModel = (function () {
    function AbstractModel(_client, _errorHandler, _connectionConfig) {
        this._client = _client;
        this._errorHandler = _errorHandler;
        this._connectionConfig = _connectionConfig;
        this.metadata = null;
        /**
         * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
         */
        this._unitsCache = {};
        /**
         * Map qualifiedName -> AbstractElement[]; the same qualified name could potentially refer to different kind of objects;
         * e.g. MyFirstModule.SecondThing could both be an entity or a microflow.
         *
         * A structure has a qualified name precisely if it's public, publicly contained through namespaces and
         * has a public, 1-string-typed `name` property.
         * In other words: every structure having a qualified name is already present in the interface of the containing unit.
         * So, as soon as the `_processLoadedUnitInterfaces` has been called the cache is complete (no lazy loading).
         * (It still needs to be continuously updated obviously.)
         */
        this._qualifiedNameCache = new qualified_name_cache_1.default(this);
        /**
         * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
         * Please extend the type whenever applicable, for convenience of the programmer.
         */
        this._unitsByType = {};
        this._unresolvedReferences = [];
        this._areUnitInterfacesLoaded = false;
        this._deltaQueue = null;
    }
    AbstractModel.prototype.closeConnection = function (callback, errorCallback) {
        var _this = this;
        setTimeout(function () {
            _this._deltaQueue.closeConnection(callback, errorCallback || _this._errorHandler);
        }, 1);
    };
    /**
     * Instantiates a new Model that can communicate with the server for sending and receiving documents.
     * Loading a Model will automatically fetches all unit interfaces for this working copy and invokes the (success) callback,
     * or calls the errorHandler if this fails.
     */
    AbstractModel.create = function (client, workingCopyInfo, callback, errorCallback) {
        client.createWorkingCopy(workingCopyInfo, callback, errorCallback);
    };
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback,
     * or call the errorHandler if this fails.
     */
    AbstractModel.read = function (client, workingCopyId, connectionConfig, instance, callback, errorCallback) {
        AbstractModel.readImpl(instance, workingCopyId, callback);
    };
    AbstractModel.readImpl = function (instance, workingCopyId, callback) {
        // TODO  use promises to avoid callback admin mess
        var hasError = false;
        var processMetaDataCallback = null;
        var processUnitInterfacesCallback = null;
        var guardedCallback = function () {
            if (!hasError && processMetaDataCallback && processUnitInterfacesCallback) {
                /*
                 * order is important: metadata (e.g. version) must be set first,
                 * then unit-interfaces (which uses version), then the user can do his/her thing.
                 */
                processMetaDataCallback();
                processUnitInterfacesCallback();
                callback(instance);
            }
        };
        var guardedErrorCallback = function (err) {
            if (!hasError) {
                hasError = true;
                instance._errorHandler(err);
            }
            // Loading is parallel, if multiple errors occur, we are only interested in the first one..
        };
        instance._loadMetaData(workingCopyId, function (callback) {
            processMetaDataCallback = callback;
            return void guardedCallback();
        }, guardedErrorCallback);
        instance._loadUnitInterfaces(workingCopyId, function (callback) {
            processUnitInterfacesCallback = callback;
            return void guardedCallback();
        }, guardedErrorCallback);
    };
    Object.defineProperty(AbstractModel.prototype, "id", {
        get: function () {
            return this.metadata.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractModel.prototype, "_unitTypes", {
        get: function () {
            return Object.keys(this._unitsByType);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     */
    AbstractModel.prototype._unitInterfacesByType = function (typeName) {
        if (!(typeName in this._unitsByType)) {
            mobx_1.extendObservable(this._unitsByType, (_a = {}, _a[typeName] = mobx_1.asFlat([]), _a));
        }
        return this._unitsByType[typeName];
        var _a;
    };
    /**
     * Returns a defensive collection of all units in this model.
     */
    AbstractModel.prototype.allUnits = function () {
        var result = [];
        for (var key in this._unitsByType) {
            var objects = this._unitsByType[key];
            result.push.apply(result, objects.slice());
        }
        return result;
    };
    AbstractModel.prototype._sendDelta = function (delta) {
        this._deltaQueue.push(new deltas_1.DeltaRequest(delta));
    };
    /**
     * Registers the given `unit` in the cache(s).
     */
    AbstractModel.prototype._cache = function (unit) {
        if (!unit.typeName) {
            throw new Error("Illegal state: unit has no type name specified");
        }
        if (!this._unitsCache[unit.id]) {
            this._unitsCache[unit.id] = unit;
            this._unitInterfacesByType(unit.typeName).push(unit);
        }
    };
    /**
     * Unregisters the given `unit` from the cache(s).
     */
    AbstractModel.prototype._uncache = function (unit) {
        delete this._unitsCache[unit.id];
        var idx = this._unitsByType[unit.typeName].indexOf(unit); // yay for pointer equality
        if (idx > -1) {
            this._unitsByType[unit.typeName].splice(idx, 1);
        }
    };
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    AbstractModel.prototype.loadUnitById = function (id, forceRefresh, callback, errorCallback) {
        if (id === null) {
            return void callback(null);
        }
        var unit = this._unitsCache[id];
        if (!unit) {
            if (typeof errorCallback === "function") {
                errorCallback(new Error("Unknown unit ID: " + id));
            }
            else {
                this._errorHandler(new Error("Unknown unit ID: " + id));
            }
        }
        else if (forceRefresh) {
            // make sure we can load the unit again:
            unit._markNotLoaded();
            this._loadUnit(unit, callback, errorCallback);
        }
        else if (unit._isLoading) {
            unit._registerAfterLoadCallback(callback);
        }
        else if (unit.isLoaded) {
            setTimeout(function () {
                callback(unit);
            }, 1);
        }
        else {
            this._loadUnit(unit, callback, errorCallback);
        }
    };
    AbstractModel.prototype._loadUnit = function (unit, callback, errorCallback) {
        var _this = this;
        unit._registerAfterLoadCallback(callback);
        unit._markLoading();
        this._client.loadUnitById(this.metadata.id, unit.id, function (data) {
            mobx_1.transaction(function () {
                unit._updateWithJson(data);
                _this._resolveContainer(unit, data.containerId);
                unit._resolveReferences();
            });
            unit._markLoaded();
        }, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype._loadMetaData = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        this._client.loadWorkingCopyMetaData(workingCopyId, function (data) {
            callback(_this._processLoadedMetaData.bind(_this, data));
        }, errorCallback);
    };
    AbstractModel.prototype._processLoadedMetaData = function (data) {
        this.metadata = data;
        this.metaModelVersion = version_checks_1.parseAsNormalizedVersion(data.metaData.metaModelVersion);
        this.mxVersionForModel = version_checks_1.parseAsNormalizedVersion(data.mprMetaData._ProductVersion);
        this._deltaQueue = new deltas_1.DeltaQueue(this);
    };
    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     */
    AbstractModel.prototype._loadUnitInterfaces = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        if (this._areUnitInterfacesLoaded) {
            throw new Error("Illegal state: unit interfaces already loaded");
        }
        this._client.loadUnitInterfaces(workingCopyId, function (data) {
            return void callback(_this._processLoadedUnitInterfaces.bind(_this, data));
        }, errorCallback);
    };
    AbstractModel.prototype._processLoadedUnitInterfaces = function (data) {
        var _this = this;
        mobx_1.transaction(function () {
            data.forEach(function (unitJson) {
                instances_1.instancehelpers.abstractUnitJsonToInstance(_this, unitJson, true);
            });
            // resolve all parents:
            data.filter(function (unitJson) { return !!unitJson.containerId; }).forEach(function (unitJson) {
                var unit = _this._unitsCache[unitJson.$ID];
                _this._resolveContainer(unit, unitJson.containerId);
            });
            // resolve all qualified names:
            Object.keys(_this._unitsCache).forEach(function (key) { return _this._qualifiedNameCache.addStructureToCache(_this._unitsCache[key]); });
            // resolve all references:
            Object.keys(_this._unitsCache).forEach(function (key) { return _this._unitsCache[key]._resolveReferences(); });
        });
        this._areUnitInterfacesLoaded = true;
    };
    AbstractModel.prototype._resolveContainer = function (unit, containerId) {
        if (!unit) {
            return; // can happen as long as the meta model isn't complete.
        }
        var container = this._unitsCache[containerId];
        if (!container) {
            throw new Error("Invalid container ID: " + containerId);
        }
        if (container !== unit) {
            // Project has a self reference container, which is of course very annoying for recursion..
            // add unit to the structural parent in the project tree
            this._addUnitToStructuralParent(unit, container);
        }
    };
    /**
     * Structural units have children (e.g., folders have documents), but in storage the inverse is stored:
     * documents specify in which parent they reside.
     * However, in the SDK we want to be able to read the children of a folder, so these kind of properties are expressed
     * using StructuralChild(List)Property objects, see `properties/structural.ts`.
     * We notify structural parents that a child was added upon loading a child structure,
     * so that parent can do the appropriate bookkeeping at that time (and only once).
     * This way we avoid having to visit all unit interfaces to gather all childrenof a specific structural child (list) property.
     */
    AbstractModel.prototype._addUnitToStructuralParent = function (unit, parent) {
        if (unit.container !== parent) {
            // old container needs to be unset first
            this._removeUnitFromStructuralParent(unit);
        }
        // set the new parent
        unit.container = parent;
        var prop = parent["__" + unit._containmentName];
        parent._isUpdating = true;
        if (prop instanceof properties_1.StructuralChildProperty) {
            prop.observableValue.set(unit);
        }
        else if (prop instanceof properties_1.StructuralChildListProperty) {
            if (prop.observableValue.indexOf(unit) === -1) {
                prop.observableValue.push(unit);
            }
        }
        else {
            throw new Error("Illegal state");
        }
        parent._isUpdating = false;
    };
    AbstractModel.prototype._removeUnitFromStructuralParent = function (unit) {
        if (!unit.container) {
            return;
        }
        var oldParent = unit.container;
        var oldProp = oldParent["__" + unit._containmentName];
        oldParent._isUpdating = true;
        if (oldProp instanceof properties_1.StructuralChildProperty) {
            oldProp.observableValue.set(null);
        }
        else if (oldProp instanceof properties_1.StructuralChildListProperty) {
            oldProp.observableValue.remove(unit);
        }
        else {
            throw new Error("Illegal state");
        }
        oldParent._isUpdating = false;
        unit.container = null;
    };
    /**
     * If a reference is broken, it should be registered here, so that it can be restored once model elements are renamed.
     */
    AbstractModel.prototype._registerUnresolvedReference = function (ref) {
        if (this._unresolvedReferences.indexOf(ref) === -1) {
            this._unresolvedReferences.push(ref);
        }
    };
    /**
     * If a reference is no longer broken, it should be unregistered here.
     */
    AbstractModel.prototype._unregisterUnresolvedReference = function (ref) {
        var idx = this._unresolvedReferences.indexOf(ref);
        if (idx >= 0) {
            this._unresolvedReferences.splice(idx, 1);
        }
    };
    AbstractModel.prototype._unresolvedReferencesFor = function (unit) {
        return this._unresolvedReferences.filter(function (ref) { return ref.owner.unit === unit; });
    };
    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     */
    AbstractModel.prototype._processNameChange = function (element) {
        if (instances_1.instancehelpers.structureAffectsQualifiedNames(element)) {
            this._qualifiedNameCache.processNameChange(element);
            for (var i = this._unresolvedReferences.length - 1; i >= 0; i--) {
                if (this._unresolvedReferences[i].resolve()) {
                    this._unresolvedReferences.splice(i, 1);
                }
            }
        }
    };
    AbstractModel.prototype._assertConnectionClosed = function () {
        if (!this._deltaQueue.isClosing) {
            throw new Error("Connection should be closed first");
        }
    };
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    AbstractModel.prototype.deleteWorkingCopy = function (callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.deleteWorkingCopy(this.id, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.exportMpk = function (outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportMpk(this.id, outFilePath, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.getFilePaths = function (callback, errorCallback) {
        this.getFiles(callback, errorCallback);
    };
    AbstractModel.prototype.getFiles = function (arg1, arg2, arg3) {
        var cb, errorCb, options;
        if (typeof arg1 === "function") {
            cb = arg1;
            errorCb = arg2;
            options = {
                format: "json"
            };
        }
        else {
            options = arg1;
            cb = arg2;
            errorCb = arg3;
        }
        this._client.getFiles(this.id, options, cb, errorCb);
    };
    AbstractModel.prototype.getFile = function (filePath, outFilePath, callback, errorCallback) {
        this._client.getFile(this.id, filePath, outFilePath, callback, errorCallback);
    };
    AbstractModel.prototype.putFile = function (inFilePath, filePath, callback, errorCallback) {
        this._client.putFile(this.id, inFilePath, filePath, callback, errorCallback);
    };
    AbstractModel.prototype.deleteFile = function (filePath, callback, errorCallback) {
        this._client.deleteFile(this.id, filePath, callback, errorCallback);
    };
    AbstractModel.prototype.getAppEnvironmentStatus = function (callback, errorCallback) {
        this._client.getAppEnvironmentStatus(this.id, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.getAppUpdateStatus = function (jobId, callback, errorCallback) {
        this._client.getAppUpdateStatus(this.id, jobId, callback, errorCallback);
    };
    AbstractModel.prototype.startAppUpdate = function (callback, errorCallback) {
        this._client.startAppUpdate(this.id, callback, errorCallback);
    };
    AbstractModel.prototype.getEditorData = function (callback, errorCallback) {
        this._client.getEditorData(callback, errorCallback || this._errorHandler);
    };
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.typeName, "Expenses.Expense.Price");`
     */
    AbstractModel.prototype._resolveName = function (typeName, qualifiedName) {
        return this._qualifiedNameCache.resolve(typeName, qualifiedName);
    };
    AbstractModel.prototype._warnAboutUnsupportedType = function (propertyName, qname) {
        utils_1.utils.warnOnce("Cannot resolve identifier; the type of the identifiers used by property '" + propertyName + "' is currently not supported. "
            + ("Please use the property '." + propertyName + "QualifiedName' instead to read or update this reference."));
    };
    AbstractModel.prototype.findModuleByQualifiedName = function (qname) {
        throw new Error("Abstract! Should be overriden");
    };
    AbstractModel.prototype._allModelClasses = function () {
        throw new Error("Abstract! Should be overriden");
    };
    AbstractModel.prototype._allOfTypes = function (typeNames) {
        var _this = this;
        return utils_1.utils.flatten(typeNames.map(function (typeName) { return _this._unitInterfacesByType(typeName); }));
    };
    return AbstractModel;
}());
exports.AbstractModel = AbstractModel;
