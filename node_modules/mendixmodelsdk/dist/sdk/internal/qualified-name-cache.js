"use strict";
var utils_1 = require("../utils");
var elements_1 = require("./elements");
var instances_1 = require("./instances");
var lodash_1 = require("lodash");
var NEW_ARRAY = function () { return []; };
/**
 * Manages a cached map [qualified name: string] -> list of structures,
 * with the possibility to retrieve (resolve) based on qualified name.
 *
 * Used to speed up resolution of by-(qualified-)name references.
 */
var QualifiedNameCache = (function () {
    function QualifiedNameCache(_model) {
        var _this = this;
        this._model = _model;
        this._cache = {};
        this.addElementToCache = function (structure) {
            if (structure instanceof elements_1.AbstractElement && structure._isByNameReferrable()) {
                var oldName = structure._registeredQualifiedName;
                var newName = structure._registeredQualifiedName = structure.qualifiedName;
                // Note: qname might be an empty string!
                if (oldName === newName) {
                    return;
                }
                if (oldName !== undefined) {
                    utils_1.utils.removeFromArray(_this._cache[oldName], structure);
                }
                utils_1.utils.getOrCreateMapEntry(_this._cache, newName, NEW_ARRAY).push(structure);
            }
        };
    }
    QualifiedNameCache.prototype.resolve = function (typeName, qualifiedName) {
        if (!qualifiedName) {
            return null;
        }
        var elements = this._cache[qualifiedName];
        if (!elements) {
            return null;
        }
        if (!typeName) {
            throw new Error("please provide a typename");
        }
        var initializer = instances_1.instancehelpers.lookupClass(typeName, this._model._allModelClasses());
        return lodash_1.find(elements, function (elem) { return elem instanceof initializer; });
    };
    /**
     * Recursively adds this structure and its children to the elements cache.
     */
    QualifiedNameCache.prototype.addStructureToCache = function (structure) {
        // If a structure was renamed and it is a namespace, the name change also effects the names of children, hence the traverse.
        structure.traversePublicParts(this.addElementToCache);
    };
    QualifiedNameCache.prototype.removeStructureFromCache = function (structure) {
        if (structure instanceof elements_1.AbstractElement && structure._registeredQualifiedName) {
            utils_1.utils.removeFromArray(this._cache[structure._registeredQualifiedName], structure);
        }
    };
    /**
     * Updates the cache as far as it is affected by the rename of this element.
     * Child entries are updated automatically as well.
     */
    QualifiedNameCache.prototype.processNameChange = function (structure) {
        // If it is a namespace or the structure is by name referrable the cache should be updated.
        if (instances_1.instancehelpers.structureAffectsQualifiedNames(structure)) {
            structure.traversePublicParts(this.addElementToCache);
        }
    };
    return QualifiedNameCache;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = QualifiedNameCache;
