"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var mobx_1 = require("mobx");
var abstract_property_1 = require("./abstract-property");
var primitives_1 = require("./primitives");
var references_1 = require("../references");
var utils_1 = require("../../utils");
/**
 * Property value that references a (model) element by name.
 */
var ByNameReferenceProperty = (function (_super) {
    __extends(ByNameReferenceProperty, _super);
    function ByNameReferenceProperty(declaredOn, parent, name, initialValue, _targetType) {
        var _this = _super.call(this, declaredOn, parent, name, initialValue, _targetType) || this;
        _this._targetType = _targetType;
        return _this;
    }
    ByNameReferenceProperty.prototype.initialize = function (value, _targetType) {
        return new references_1.ByNameReference(this.parent, _targetType, this.name);
    };
    ByNameReferenceProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue.get();
    };
    ByNameReferenceProperty.prototype.set = function (newValue) {
        if (this.isRequired && !newValue) {
            throw new Error("Cannot unset required property '" + this.name + "' on '" + this.parent.qualifiedName + "' of type '" + this.parent.typeName + "'");
        }
        this.assertWritable();
        this.observableValue.set(newValue);
    };
    ByNameReferenceProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.updateWithRawValue(value);
    };
    ByNameReferenceProperty.prototype.resolveReferences = function () {
        this.observableValue.resolve();
    };
    ByNameReferenceProperty.prototype.onChange = function (newValue, oldValue) {
        this.parent._sendChangeDelta(this.name, newValue ? newValue.qualifiedName : null);
    };
    ByNameReferenceProperty.prototype.qualifiedName = function () {
        return this.observableValue.qualifiedName();
    };
    Object.defineProperty(ByNameReferenceProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    ByNameReferenceProperty.prototype.dispose = function () {
        this.observableValue.dispose();
        _super.prototype.dispose.call(this);
    };
    ByNameReferenceProperty.prototype._toJSON = function () {
        return (this.isRequired || this.get()) ? this.qualifiedName() : null;
    };
    ByNameReferenceProperty.prototype.deepCopyInto = function (clone, _, unresolvedIdentifierFixers) {
        var _this = this;
        // make sure we copy the refs, not the values, refs might be broken.
        var qn = this.qualifiedName();
        unresolvedIdentifierFixers.push(function () {
            var elem = qn ? clone._model._resolveName(_this.targetType, qn) : null;
            // This works around #875733 and doesn't seem to impact anything else (negatively) so far...
            if (elem !== null) {
                clone[_this.name] = elem;
            }
            /*
             * FIXME  This doesn't seem to be semantically correct,
             * since deep copying inconsistent model content would cause default values to "spring back".
             * We have to think whether we should throw on setting this to null.
             */
        });
    };
    return ByNameReferenceProperty;
}(abstract_property_1.AbstractProperty));
exports.ByNameReferenceProperty = ByNameReferenceProperty;
/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
var ByNameReferenceListProperty = (function (_super) {
    __extends(ByNameReferenceListProperty, _super);
    function ByNameReferenceListProperty(declaredOn, parent, name, value, _targetType) {
        var _this = _super.call(this, declaredOn, parent, name, value) || this;
        _this._targetType = _targetType;
        _this.supressViewEvents = false;
        _this.viewList = mobx_1.observable(mobx_1.asFlat([]));
        _this.viewListDisposer = _this.viewList.observe(function (changeData) {
            if (_this.supressViewEvents) {
                return;
            }
            // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
            switch (changeData.type) {
                case "splice": {
                    var splice = changeData;
                    var newValues = splice.object.slice(splice.index, splice.index + splice.addedCount);
                    newValues.forEach(function (newValue) { return utils_1.utils.assertNotNull(newValue, _this.name, true); });
                    var newReferences = newValues.map(function (newValue) {
                        var ref = new references_1.ByNameReference(_this.parent, _this._targetType, _this.name);
                        ref.set(newValue);
                        return ref;
                    });
                    (_a = _this.observableValue).splice.apply(_a, [splice.index, splice.removed.length].concat(newReferences)).forEach(function (ref) { return ref.dispose(); });
                    return;
                }
                case "update": {
                    var update = changeData;
                    if (update.index < 0 || update.index >= _this.observableValue.length) {
                        throw new Error("Update index out of bounds " + update.index);
                    }
                    var newValue = update.object[update.index];
                    utils_1.utils.assertNotNull(newValue, _this.name, true);
                    var newRef = new references_1.ByNameReference(_this.parent, _this._targetType, _this.name);
                    newRef.set(newValue);
                    _this.observableValue[update.index].dispose();
                    _this.observableValue[update.index] = newRef;
                    return;
                }
            }
            var _a;
        });
        return _this;
    }
    ByNameReferenceListProperty.prototype.initialize = function (value) {
        if (value && value.length > 0) {
            throw new Error("Illegal state: can only initialize with []");
        }
        return mobx_1.observable(mobx_1.asFlat([]));
    };
    ByNameReferenceListProperty.prototype.get = function () {
        this.assertReadable();
        return this.viewList;
    };
    ByNameReferenceListProperty.prototype.set = function (newElements) {
        throw new Error("Illegal state: cannot re-assign list property - use push or splice instead");
    };
    ByNameReferenceListProperty.prototype.updateWithRawValue = function (qualifiedNames) {
        var _this = this;
        this.replaceViewItems([]);
        this.observableValue.replace((qualifiedNames || []).map(function (qualifiedName) {
            var ref = new references_1.ByNameReference(_this.parent, _this._targetType, _this.name);
            ref.updateWithRawValue(qualifiedName);
            return ref;
        }));
    };
    ByNameReferenceListProperty.prototype.resolveReferences = function () {
        this.observableValue.map(function (ref) { return ref.resolve(); });
        this.replaceViewItems(this.observableValue.map(function (ref) { return ref.get(); }));
    };
    ByNameReferenceListProperty.prototype.qualifiedNames = function () {
        return this.observableValue.map(function (ref) { return ref.qualifiedName(); });
    };
    ByNameReferenceListProperty.prototype.dispose = function () {
        this.viewListDisposer(); // prevent further events
        this.observableValue.forEach(function (ref) { return ref.dispose(); });
        _super.prototype.dispose.call(this);
    };
    ByNameReferenceListProperty.prototype.replaceViewItems = function (newItems) {
        this.supressViewEvents = true;
        this.viewList.replace(newItems);
        this.supressViewEvents = false;
    };
    ByNameReferenceListProperty.prototype.onChange = function (changeData) {
        this.assertWritable();
        // Reuse listeness behavior from primitiveList
        // Uses toRawChangeValue to get the raw data
        primitives_1.PrimitiveListProperty.prototype.onChange.apply(this, arguments);
    };
    ByNameReferenceListProperty.prototype.toRawChangeValue = function (reference) {
        return reference.qualifiedName();
    };
    Object.defineProperty(ByNameReferenceListProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    ByNameReferenceListProperty.prototype._toJSON = function () {
        return this.qualifiedNames();
    };
    ByNameReferenceListProperty.prototype.deepCopyInto = function (clone, _, unresolvedIdentifierFixers) {
        var _this = this;
        // make sure we copy the refs, not the values, refs might be broken.
        var qns = this.qualifiedNames();
        unresolvedIdentifierFixers.push(function () {
            clone[_this.name].replace(qns
                .map(function (qn) { return qn ? clone._model._resolveName(_this.targetType, qn) : null; })
                .filter(function (elem) { return !!elem; }));
        });
    };
    return ByNameReferenceListProperty;
}(abstract_property_1.AbstractProperty));
exports.ByNameReferenceListProperty = ByNameReferenceListProperty;
