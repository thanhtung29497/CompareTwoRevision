import { IArrayChange, IArraySplice, IObservableArray } from "mobx";
import { AbstractProperty } from "./abstract-property";
import { AbstractElement, IAbstractElement } from "../elements";
import { ByNameReference } from "../references";
/**
 * Property value that references a (model) element by name.
 */
export declare class ByNameReferenceProperty<T extends IAbstractElement> extends AbstractProperty<T, ByNameReference<T>> {

    parent: AbstractElement;
    constructor(declaredOn: any, parent: AbstractElement, name: string, initialValue: T, _targetType: string);
    initialize(value: T, _targetType: string): ByNameReference<T>;
    get(): T;
    set(newValue: T): void;
    updateWithRawValue(value: string): void;
    resolveReferences(): void;
    onChange(newValue: T, oldValue: T): void;
    qualifiedName(): string;
    readonly targetType: string;
    dispose(): void;

    deepCopyInto(clone: any, _: any, unresolvedIdentifierFixers: any): void;
}
/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
export declare class ByNameReferenceListProperty<T extends IAbstractElement> extends AbstractProperty<T[], IObservableArray<ByNameReference<T>>> {

    parent: AbstractElement;
    supressViewEvents: boolean;
    private viewList;
    private viewListDisposer;
    constructor(declaredOn: any, parent: AbstractElement, name: string, value: T[], _targetType: string);
    initialize(value: T[]): IObservableArray<ByNameReference<T>>;
    get(): IObservableArray<T>;
    set(newElements: T[]): void;
    updateWithRawValue(qualifiedNames: string[]): void;
    resolveReferences(): void;
    qualifiedNames(): string[];
    dispose(): void;
    replaceViewItems(newItems: T[]): void;
    onChange(changeData: IArrayChange<ByNameReference<T>> | IArraySplice<ByNameReference<T>>): void;
    toRawChangeValue(reference: ByNameReference<T>): any;
    readonly targetType: string;

    deepCopyInto(clone: any, _: any, unresolvedIdentifierFixers: any): void;
}
