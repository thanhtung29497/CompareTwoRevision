"use strict";
/**
 * @returns whether indices.asSet equals [0, 1, ..., (indices.length - 1)].
 */
function isPermutation(indices) {
    var sorted = indices.slice().sort(function (x, y) { return x - y - 0; }); // defensive copy + defeat broken JS sorting...
    for (var i = 0; i < sorted.length; i++) {
        if (i !== sorted[i]) {
            return false;
        }
    }
    return true;
}
exports.isPermutation = isPermutation;
function runLenghtEncode(values, max) {
    if (max === void 0) { max = 4; }
    var runs = [];
    var lastValue = NaN;
    var currentRun;
    for (var i = 0; i < values.length; i++) {
        if (values[i] === lastValue) {
            currentRun.count++;
        }
        else {
            lastValue = values[i];
            currentRun = { count: 1, value: lastValue };
            runs.push(currentRun);
            if (runs.length > max) {
                return null;
            }
        }
    }
    return runs;
}
exports.runLenghtEncode = runLenghtEncode;
/**
 * @returns the move action expressed by the given indices, expressed as an array `[fromIndex, toIndex]`,
 * 	or `null` if it's not a move.
 */
function detectMove(indices) {
    if (!isPermutation(indices)) {
        return null;
    }
    var runsOrNull = runLenghtEncode(indices.map(function (num, i) { return num - i; }), 4);
    if (!runsOrNull) {
        return null;
    }
    var runs = runsOrNull;
    if (runs.length < 2) {
        return null;
    }
    // "un-degenerate":
    if (runs[0].value !== 0) {
        runs.unshift({ count: 0, value: 0 });
    }
    if (runs[runs.length - 1].value !== 0) {
        runs.push({ count: 0, value: 0 });
    }
    if (runs.length !== 4) {
        return null;
    }
    var n = indices.length;
    if (runs[1].value === 1) {
        var f = runs[0].count;
        var t = runs[1].count + f;
        if (runs[2].count === 1 && runs[2].value === (f - t) && runs[3].count === (n - t - 1) && runs[3].value === 0) {
            return [f, t];
        }
    }
    else if (runs[1].count === 1) {
        var t = runs[0].count;
        var f = runs[1].value + t;
        if (runs[2].count === (f - t) && runs[2].value === -1 && runs[3].count === (n - f - 1) && runs[3].value === 0) {
            return [f, t];
        }
    }
    return null;
}
exports.detectMove = detectMove;
/**
 * @returns whether the members of the two given arrays are identical (using object comparison),
 * and occur in the same order.
 */
function areIdentical(left, right) {
    if (left.length !== right.length) {
        return false;
    }
    for (var i = 0; i < left.length; i++) {
        if (left[i] !== right[i]) {
            return false;
        }
    }
    return true;
}
exports.areIdentical = areIdentical;
