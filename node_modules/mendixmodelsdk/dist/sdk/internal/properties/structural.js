"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var mobx_1 = require("mobx");
var abstract_property_1 = require("./abstract-property");
var units_1 = require("../units");
/**
 * Note: structural child values are updated through AbstractModel._addUnitToStructuralParent.
 */
/**
 * Value of a property owned by a structural unit.
 */
var StructuralChildProperty = (function (_super) {
    __extends(StructuralChildProperty, _super);
    function StructuralChildProperty(declaredOn, parent, name, value, targetRefType) {
        return _super.call(this, declaredOn, parent, name, value) || this;
    }
    StructuralChildProperty.prototype.initialize = function (value) {
        return mobx_1.observable(mobx_1.asReference(value));
    };
    StructuralChildProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue.get();
    };
    StructuralChildProperty.prototype.set = function (value) {
        if (value) {
            console.warn("Cannot directly set a structural child property");
        }
        else {
            var unit = this.observableValue.get();
            if (unit instanceof units_1.ModelUnit) {
                unit.delete();
                this.observableValue.set(null);
            }
            else {
                console.warn("Cannot delete a structural unit");
            }
        }
    };
    StructuralChildProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("Illegal state: cannot update a structural child property");
    };
    StructuralChildProperty.prototype.onChange = function (changeData) {
        // do nothing
        // TODO  changeData seems to be always null: is that correct and expected?
    };
    StructuralChildProperty.prototype.dispose = function () {
        // do nothing
    };
    StructuralChildProperty.prototype.deepCopyInto = function () {
        /*
        Structural children are not copied by default, that would require
        loading and cloning all children, which is probably not desirable.

        const child =  this.get();
        if (child) {
            child.deepCopyInto(clone);
        }*/
    };
    return StructuralChildProperty;
}(abstract_property_1.AbstractProperty));
exports.StructuralChildProperty = StructuralChildProperty;
/**
 * Property instance that wraps a list of structural units.
 * Structural child values are updated through AbstractModel._addUnitToStructuralParent.
 */
var StructuralChildListProperty = (function (_super) {
    __extends(StructuralChildListProperty, _super);
    function StructuralChildListProperty(declaredOn, parent, name, value, targetRefType) {
        return _super.call(this, declaredOn, parent, name, value) || this;
    }
    StructuralChildListProperty.prototype.initialize = function (values) {
        return mobx_1.observable(mobx_1.asFlat(values || []));
    };
    StructuralChildListProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue;
    };
    StructuralChildListProperty.prototype.set = function (value) {
        console.warn("Cannot set a structural child property");
    };
    StructuralChildListProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("Illegal state: cannot update a structural child property");
    };
    StructuralChildListProperty.prototype.onChange = function (changeData) {
        var _this = this;
        this.assertWritable();
        // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        switch (changeData.type) {
            case "splice": {
                var splice = changeData;
                splice.removed.forEach(function (unit) { return _this.processChildRemoval(unit); });
                for (var i = splice.index; i < splice.index + splice.addedCount; i++) {
                    this.processChildAddition(i);
                }
                return;
            }
            case "update": {
                var update = changeData;
                this.processChildRemoval(update.oldValue);
                this.processChildAddition(update.index);
                return;
            }
        }
    };
    StructuralChildListProperty.prototype.processChildRemoval = function (unit) {
        /* If the unit was removed and not inserted at another place
        * (either on another parent or in the same parent on another index),
        * remove it:
        */
        if (unit instanceof units_1.StructuralUnit) {
            throw new Error("Deletion of structural child units is not yet implemented");
        }
        if (this.observableValue.indexOf(unit) === -1) {
            unit.container = null;
            unit.clearBackReferences();
            unit.delete();
        }
    };
    StructuralChildListProperty.prototype.processChildAddition = function (index) {
        console.warn("Adding a unit to a (property of a) structural unit is part of creating that unit");
    };
    StructuralChildListProperty.prototype.dispose = function () {
        // do nothing
    };
    StructuralChildListProperty.prototype.deepCopyInto = function (clone) {
        /*
        Structural children are not copied by default, that would require
        loading and cloning all children, which is probably not desirable.

        this.get().forEach(child => child.deepCopyInto(clone));
        */
    };
    return StructuralChildListProperty;
}(abstract_property_1.AbstractProperty));
exports.StructuralChildListProperty = StructuralChildListProperty;
