"use strict";
var mobx_1 = require("mobx");
var references = require("../references");
/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
var AbstractProperty = (function () {
    function AbstractProperty(declaredOn, parent, name) {
        var initializeArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            initializeArgs[_i - 3] = arguments[_i];
        }
        this.declaredOn = declaredOn;
        this.parent = parent;
        this.name = name;
        parent._registerProperty(this);
        this.observableValue = this.initialize.apply(this, initializeArgs);
        if (this.observableValue instanceof references.AbstractReference) {
            this.handle = this.observableValue.observe(this.fireOnChange.bind(this), false);
        }
        else {
            this.handle = mobx_1.observe(this.observableValue, this.fireOnChange.bind(this), false);
        }
    }
    Object.defineProperty(AbstractProperty.prototype, "versionInfo", {
        get: function () {
            return (this.declaredOn["versionInfo"]).getPropertyVersionInfo(this.name);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isPublic", {
        get: function () {
            return this.versionInfo.isPublic.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isRequired", {
        get: function () {
            return this.versionInfo.isRequired.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isAvailable", {
        /**
         * Returns true if this property is not deleted, and already availabe in the current model version.
         */
        get: function () {
            return this.versionInfo.availability.isAvailableIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize should return something that is observable.
     * The property will observe this internal structure
     * and make sure changes are pushed to the server whenever needed, in its onChange event.
     */
    AbstractProperty.prototype.initialize = function (value) {
        var moreConstructorArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            moreConstructorArgs[_i - 1] = arguments[_i];
        }
        throw new Error("This function should be overriden in subclass");
    };
    AbstractProperty.prototype.fireOnChange = function () {
        if (!this.parent._isUpdating) {
            this.assertWritable();
            this.onChange.apply(this, arguments);
        }
    };
    AbstractProperty.prototype.onChange = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.get = function () {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.set = function (newValue) {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.assertWritable = function () {
        this.parent._assertLoaded(this);
        this.assertPropertyAvailableInCurrentVersion();
    };
    AbstractProperty.prototype.assertReadable = function () {
        if (!this.isPublic) {
            this.parent._assertLoaded(this);
        }
        this.assertPropertyAvailableInCurrentVersion();
    };
    AbstractProperty.prototype.assertPropertyAvailableInCurrentVersion = function () {
        // parent check is done here and not in property info, because the actual type of the structure
        // might have different version annations as the type that declared the property
        this.parent.versionInfo.checkStructureVersion(this.parent, true);
        this.versionInfo.checkPropertyVersion(this, true);
    };
    AbstractProperty.prototype.resolveReferences = function () {
        // empty stub
    };
    AbstractProperty.prototype.dispose = function () {
        this.handle();
    };
    AbstractProperty.prototype._toJSON = function () {
        throw new Error("Cannot JSON-serialize property: " + this + " (this function should be overridden in sub class)");
    };
    return AbstractProperty;
}());
exports.AbstractProperty = AbstractProperty;
