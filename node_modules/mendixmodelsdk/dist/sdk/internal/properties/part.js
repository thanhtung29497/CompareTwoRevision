"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var mobx_1 = require("mobx");
var abstract_property_1 = require("./abstract-property");
var instances_1 = require("../instances");
var move_utils_1 = require("./move-utils");
/* for debugging:
function describe(element: Element) {
    if (!element) {
        return "null";
    }
    let description = `${element.typeName}(id=${element.id}`;
    description += `, container: `;
    if (element.container) {
        const childHandle = element.container._childHandle(element);
        description += `{id=${element.container.id}, property=${childHandle ? childHandle.containingProperty.name : "ill-defined!"}}`;
    } else {
        description += "null";
    }
    description += ")";
    return description;
}
 */
/**
 * A property value that is a (model) element.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
var PartProperty = (function (_super) {
    __extends(PartProperty, _super);
    function PartProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PartProperty.prototype.initialize = function (value, hasDefaultValue) {
        this.hasDefaultValue = hasDefaultValue;
        return mobx_1.observable(mobx_1.asReference(value));
    };
    PartProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue.get();
    };
    PartProperty.prototype.set = function (newValue) {
        if (this.isRequired && !newValue) {
            throw new Error("Cannot unset required part property");
        }
        this.assertWritable();
        var oldValue = this.observableValue.get();
        if (newValue === oldValue) {
            return; // (nothing to do)
        }
        if (newValue) {
            newValue.versionInfo.checkSameModelVersion(newValue.model, this.parent.model);
            newValue.versionInfo.checkStructureVersion(newValue, true);
            if (newValue._isNew) {
                newValue.container = this.parent;
                if (!this.parent._isNew) {
                    newValue._updateElementsContainer(this.parent.unit);
                    this.parent._model._qualifiedNameCache.addStructureToCache(newValue);
                }
                newValue._sendCreateDelta(this.parent, this.name);
            }
            else {
                newValue._sendMoveDelta(this.parent, this.name);
                var oldParent = newValue.container;
                var childHandle = oldParent._childHandle(newValue); // !== undefined
                if (oldParent) {
                    if (oldParent === this.parent) {
                        if (this !== childHandle.containingProperty) {
                            childHandle.detach();
                        }
                    }
                    else {
                        newValue.container = this.parent;
                        childHandle.detach();
                    }
                }
                if (oldValue) {
                    oldValue.container = null;
                    oldValue.delete();
                }
            }
        }
        this.observableValue.set(newValue);
    };
    PartProperty.prototype.updateWithRawValue = function (value) {
        var newChild = instances_1.instancehelpers.modelElementJsonToInstance(this.parent._model, this.parent.unit, this.parent, value, this.parent._isPartial);
        // cleanup old value, we got a server side change that this child is no longer ours:
        var currentChild = this.observableValue.get();
        if (currentChild !== null && currentChild !== newChild) {
            currentChild._dispose();
        }
        this.observableValue.set(newChild);
    };
    PartProperty.prototype.onChange = function (newValue, oldValue) {
        // (do nothing)
    };
    PartProperty.prototype.resolveReferences = function () {
        if (this.observableValue.get()) {
            this.observableValue.get()._resolveReferences();
        }
    };
    PartProperty.prototype.updateElementContainer = function (unit) {
        if (this.observableValue.get()) {
            this.observableValue.get()._updateElementsContainer(unit);
        }
    };
    PartProperty.prototype.dispose = function () {
        if (this.observableValue.get()) {
            this.observableValue.get()._dispose();
        }
    };
    PartProperty.prototype._toJSON = function () {
        var value = this.get();
        return value ? value.toJSON() : null;
    };
    PartProperty.prototype.deepCopyInto = function (clone, idMap, unresolvedIdentifierFixers) {
        var val = this.get();
        if (val === null) {
            clone[this.name] = val;
        }
        else {
            val._deepCopyStructureInto(clone, this.name, idMap, unresolvedIdentifierFixers);
        }
    };
    return PartProperty;
}(abstract_property_1.AbstractProperty));
exports.PartProperty = PartProperty;
/**
 * A property value that is a list of (model) elements.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
var PartListProperty = (function (_super) {
    __extends(PartListProperty, _super);
    function PartListProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    * Currently, only possible default value for listy properties is [],
    * so we don't have to store initialItems to be able to distinguish from default value.
    */
    PartListProperty.prototype.initialize = function (initialItems) {
        return mobx_1.observable(mobx_1.asFlat(initialItems || []));
    };
    PartListProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue;
    };
    PartListProperty.prototype.set = function (newValue) {
        this.assertWritable();
        this.observableValue.replace(newValue);
    };
    PartListProperty.prototype.updateWithRawValue = function (value) {
        var _this = this;
        var newChildren = value.map(function (e) {
            return instances_1.instancehelpers.modelElementJsonToInstance(_this.parent._model, _this.parent.unit, _this.parent, e, _this.parent._isPartial);
        });
        var oldChildren = this.observableValue;
        // dispose old children:
        for (var i = 0; i < oldChildren.length; i++) {
            if (newChildren.indexOf(oldChildren[i]) === -1) {
                oldChildren[i]._dispose();
            }
        }
        this.observableValue.replace(newChildren);
    };
    PartListProperty.prototype.onChange = function (changeData) {
        var _this = this;
        this.assertWritable();
        // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        switch (changeData.type) {
            case "splice": {
                var splice = changeData;
                // idempotent?:
                if (move_utils_1.areIdentical(splice.added, splice.removed)) {
                    return;
                }
                if (this.observableValue.length === splice.addedCount && splice.addedCount === splice.removedCount) {
                    var indices = splice.removed.map(function (item) { return _this.observableValue.indexOf(item); });
                    // Note: for some reason we need to inspect splice.removed and then reverse indices?!
                    var moveData = move_utils_1.detectMove(indices);
                    if (moveData) {
                        if (moveData[1] === moveData[0] + 1) {
                            moveData = moveData.reverse();
                        }
                        this.observableValue[moveData[0]]._sendMoveDelta(this.parent, this.name, moveData[0]);
                        return;
                    }
                }
                splice.removed.forEach(function (element) { return _this.processChildRemoval(element); });
                for (var i = splice.index; i < splice.index + splice.addedCount; i++) {
                    this.processChildAddition(i);
                }
                return;
            }
            case "update": {
                var update = changeData;
                this.processChildRemoval(update.oldValue);
                this.processChildAddition(update.index);
                return;
            }
        }
    };
    PartListProperty.prototype.processChildRemoval = function (element) {
        /* If the element was removed and not inserted at another place
        * (either on another parent or in the same parent on another index),
        * remove it:
        */
        if (element.container === this.parent && this.observableValue.indexOf(element) === -1) {
            element.container = null;
            element.clearBackReferences();
            element.delete();
        }
    };
    PartListProperty.prototype.processChildAddition = function (index) {
        var item = this.observableValue[index];
        if (!item) {
            throw new Error("Null values cannot be added to property '" + this.name + "' of '" + this.parent.typeName + "#" + this.parent.id + "'");
        }
        item.versionInfo.checkSameModelVersion(item.model, this.parent.model);
        item.versionInfo.checkStructureVersion(item, true);
        if (this.observableValue.filter(function (other) { return other === item; }).length > 1) {
            throw new Error("Object '" + item.typeName + "#" + item.id + "' was added more than once "
                + ("to property '" + this.name + "' of '" + this.parent.typeName + "#" + this.parent.id + "'"));
        }
        if (item._isNew) {
            item.container = this.parent;
            if (!this.parent._isNew) {
                item._updateElementsContainer(this.parent.unit);
                this.parent._model._qualifiedNameCache.addStructureToCache(item);
            }
            item._unit = this.parent.unit;
            item._sendCreateDelta(this.parent, this.name);
            if (index < this.observableValue.length - 1) {
                // only send delta if not added at the end
                item._sendMoveDelta(this.parent, this.name, index);
            }
        }
        else {
            item._sendMoveDelta(this.parent, this.name, index);
            var oldParent = item.container;
            item.container = this.parent;
            if (oldParent) {
                oldParent._detachChild(item);
            }
        }
        // This could be a by-name-referrable element that was previously removed. We need to update the references to it then.
        if (item && item._isByNameReferrable()) {
            item._processNameChange();
        }
    };
    PartListProperty.prototype.resolveReferences = function () {
        this.observableValue.forEach(function (item) { return item._resolveReferences(); });
    };
    PartListProperty.prototype.updateElementContainer = function (unit) {
        this.observableValue.forEach(function (item) { return item._updateElementsContainer(unit); });
    };
    PartListProperty.prototype.removeChild = function (child) {
        var idx = this.observableValue.indexOf(child);
        if (idx >= 0) {
            this.observableValue.splice(idx, 1);
            return true;
        }
        return false;
    };
    PartListProperty.prototype.dispose = function () {
        this.observableValue.forEach(function (elem) { return elem._dispose(); });
    };
    PartListProperty.prototype._toJSON = function () {
        return this.get().map(function (item) { return item.toJSON(); });
    };
    PartListProperty.prototype.deepCopyInto = function (clone, idMap, unresolvedIdentifierFixers) {
        var _this = this;
        // throw away default / existing values in the list
        clone["__" + this.name].get().clear();
        this.get()
            .filter(function (child) { return !!child; })
            .forEach(function (child) { return child._deepCopyStructureInto(clone, _this.name, idMap, unresolvedIdentifierFixers); });
    };
    return PartListProperty;
}(abstract_property_1.AbstractProperty));
exports.PartListProperty = PartListProperty;
