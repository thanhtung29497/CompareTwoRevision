import { IObservableValue } from "mobx";
import * as elements from "./elements";
import { common } from "../../common";
/**
 * Abstract base class for both {@link ReferenceByName by-name} and {@link ReferenceById by-id} references
 * to elements of type `T`, which are observed.
 */
export declare class AbstractReference<T extends elements.IAbstractElement> {
    owner: elements.AbstractElement;
    protected isResolved: boolean;
    protected target: IObservableValue<T>;
    protected isResolving: boolean;
    protected referenceId: string;
    /**
     * Constructs and returns a new reference instance, that is owned (by a property of) an abstract element.
     */
    constructor(owner: elements.AbstractElement);
    /**
     * Registers an observer in the form of a callback with this references and fires that callback
     * immediately if the reference is already resolved.
     * Used by properties to observe this reference, so that storage and logical updates can be applied.
     */
    observe(callback: (newValue: T, oldValue: T) => void, fireImmediately?: boolean): common.IVoidCallback;
    /**
     * Returns the value of the wrapped reference.
     */
    get(): T;
    /**
     * Sets the value of the wrapped reference, taking care of resolution and life cycle.
     */
    set(newValue: T): void;
    /**
     * Sets only the raw target id, without trying to resolve that.
     */
    updateWithRawValue(value: string): void;
    protected registerRef(): void;
    protected unregisterRef(): void;
    resolve(): boolean;
    dispose(): void;
}
export declare class ByIdReference<T extends elements.AbstractElement> extends AbstractReference<T> {
    set(newValue: T): void;
    assertValueHasSameUnit(): void;
    get(): T;
    resolve(): boolean;
}
export declare class ByNameReference<T extends elements.IAbstractElement> extends AbstractReference<T> {
    targetType: string;
    propertyName: string;
    constructor(owner: elements.AbstractElement, targetType: string, propertyName: string);
    set(newValue: T): void;
    resolve(): boolean;
    /**
     * The target does no longer exist, but the stored reference should stay the same.
     */
    unresolve(): void;
    dispose(): void;
    qualifiedName(): string;
}
