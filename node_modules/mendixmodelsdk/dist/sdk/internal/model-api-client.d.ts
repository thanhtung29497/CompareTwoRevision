import { configuration } from "../config";
import { common } from "../../common";
import * as transport from "./transport-interfaces";
import * as units from "./units";
import * as transportation from "./transportation";
/**
 * The IModelApiClient interface is used for forwarding calls to the underlying Mendix Model API.
 * Implementations of this interface serve as fully-typed clients for the Model API Server.
 * Default implementation: {@link ModelApiClientImpl}.
 * Note that all its methods are asynchronous, with the last two arguments always being a (success) callback and an error callback,
 * and we will only explain the "essential" arguments in their documentation.
 *
 * Note: this interface is part of the internal API of the Model SDK.
 *
 * DISCLAIMER: End-users of the SDK should never rely directly on elements of the internal API,
 * e.g. by implementing interfaces or instantiating classes.
 * Anything in this file can be removed, or change signature, even between patch-level SDK versions.
 */
export interface IModelApiClient {
    createWorkingCopy(workingCopyInfo: configuration.ICreateWorkingCopyParameters, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback): any;
    /**
     * Loads all unit interfaces of the working copy indicated with `workingCopyId` as an array of normalized model JSON.
     */
    loadUnitInterfaces(workingCopyId: string, callback: common.ICallback<transport.IAbstractUnitJson[]>, errorCallback: common.IErrorCallback): any;
    /**
     * Retrieves the top-level working copy information/meta data for the working copy with given `workingCopyId`.
     */
    loadWorkingCopyMetaData(workingCopyId: string, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback): any;
    deleteWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    grantAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    revokeAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    checkAccess(workingCopyId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback): any;
    revokeAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    grantAccessByProject(projectId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback): any;
    getAppEnvironmentStatus(workingCopyId: string, callback: common.ICallback<transport.IEnvironmentStatus>, errorCallback: common.IErrorCallback): any;
    /**
     * Start async deploy flow, creates new app job and returns it
     */
    startAppUpdate(workingCopyId: string, callback: common.ICallback<transport.IDeployJobStatus>, errorCallback: common.IErrorCallback): any;
    /**
     * Retrieves App Job by jobId
     */
    getAppUpdateStatus(workingCopyId: string, jobId: string, callback: common.ICallback<transport.IDeployJobStatus>, errorCallback: common.IErrorCallback): any;
    getMyWorkingCopies(callback: common.ICallback<transport.IWorkingCopy[]>, errorCallback: common.IErrorCallback): any;
    exportMpk(workingCopyId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Retrieves a unit, as normalized model JSON, by working copy and unit ID.
     */
    loadUnitById<T extends units.AbstractUnit>(workingCopyId: string, unitId: string, callback: common.ICallback<transport.IAbstractUnitJson>, errorCallback: common.IErrorCallback): any;
    /**
     * Sends a sequence of deltas on the working copy with the given `workingCopyId` to the Model API Server;
     * batched if more than one is passed, as a single delta otherwise.
     */
    sendDeltas(workingCopyId: string, deltas: transport.IDelta[], callback: common.ICallback<Object>, errorCallback: common.IErrorCallback): any;
    /**
     * Returns an array of all filepaths in the working copy.
     */
    getFiles(workingCopyId: string, options: transport.IGetFilesOptions, callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): any;
    /**
     * Downloads the file specified by the supplied filepath.
     */
    getFile(workingCopyId: string, filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Uploads the supplied file to the specified filepath.
     */
    putFile(workingCopyId: string, inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Deletes the file with the specified filepath.
     */
    deleteFile(workingCopyId: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Returns UUIDs for helper working copies for each supported Mendix version.
     *
     * These are pre-defined working copies that are accessible for read operations,
     * and contain units that might come in handy when creating pages from templates.
     */
    getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback): any;
    /**
     * Retrieves the working copy id that the given project ID maps to.
     */
    getWorkingCopyByProject(projectId: any, callback: common.ICallback<string>, errorCallback: common.IErrorCallback): any;
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    updateWorkingCopyByProject(projectId: string, workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    deleteWorkingCopyByProject(projectId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Lock the working copy (will be locked for the currently authenticated openid)
     */
    lockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Unlock the working copy (will be unlocked for the currently authenticated openid, will fail if it's locked by another openid)
     */
    unlockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
}
export declare class ModelApiClientImpl implements IModelApiClient {
    private transportation;
    constructor(transportation: transportation.ITransportation);
    private pendingRequests;
    private MAX_PARALLEL_REQUESTS;
    private runningRequests;
    createWorkingCopy(workingCopyInfo: configuration.ICreateWorkingCopyParameters, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback): void;
    loadWorkingCopyMetaData(workingCopyId: string, callback: common.ICallback<transport.IWorkingCopy>, errorCallback: common.IErrorCallback): void;
    loadUnitInterfaces(workingCopyId: string, callback: common.ICallback<transport.IAbstractUnitJson[]>, errorCallback: common.IErrorCallback): void;
    deleteWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    grantAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    revokeAccess(workingCopyId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    checkAccess(workingCopyId: string, memberOpenId: string, callback: common.ICallback<boolean>, errorCallback: common.IErrorCallback): void;
    grantAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    revokeAccessByProject(projectId: string, memberOpenId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    exportMpk(workingCopyId: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    startAppUpdate(workingCopyId: string, callback: common.ICallback<transport.IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    getAppUpdateStatus(workingCopyId: string, jobId: string, callback: common.ICallback<transport.IDeployJobStatus>, errorCallback: common.IErrorCallback): void;
    private parseAppUpdateStatus(status);
    loadUnitById<T extends units.AbstractUnit>(workingCopyId: string, unitId: string, callback: common.ICallback<transport.IAbstractUnitJson>, errorCallback: common.IErrorCallback): void;
    sendDeltas(workingCopyId: string, deltas: transport.IDelta[], callback: common.ICallback<Object>, errorCallback: common.IErrorCallback): void;
    getFiles(workingCopyId: string, options: transport.IGetFilesOptions, callback: common.ICallback<any>, errorCallback: common.IErrorCallback): void;
    getFile(workingCopyId: string, filePath: string, outFilePath: string, callback: common.ICallback<any>, errorCallback: common.IErrorCallback): void;
    putFile(workingCopyId: string, inFilePath: string | Blob, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    deleteFile(workingCopyId: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    getAppEnvironmentStatus(workingCopyId: string, callback: common.ICallback<transport.IEnvironmentStatus>, errorCallback: common.IErrorCallback): void;
    getEditorData(callback: common.ICallback<IEditorData>, errorCallback: common.IErrorCallback): void;
    getMyWorkingCopies(callback: common.ICallback<transport.IWorkingCopy[]>, errorCallback: common.IErrorCallback): void;
    getWorkingCopyByProject(projectId: any, callback: common.ICallback<string>, errorCallback: common.IErrorCallback): void;
    createWorkingCopyByProject(projectId: string, workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    /**
     * Update the project-to-working copy mapping with the given data.
     */
    updateWorkingCopyByProject(projectId: string, workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    /**
     * Deletes the project-to-working copy mapping for given project ID.
     */
    deleteWorkingCopyByProject(projectId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    lockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    unlockWorkingCopy(workingCopyId: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    private sendGetUnitRequest(info);
    private createDownloadHandler(exportPath, callback, errorCallback);
    private handleRawDeploymentResult(callback, errorCallback, deploymentResult);
    private parseBuildStatus(buildstatus);
    private storeResponseAsFile(response, outFilePath, callback, errorCallback);
    private loadUnitByIdBatched(info);
    private completeGetUnitRequest();
}
export declare type IEditorData = {
    [mmVersion: string]: {
        pageTemplates: string;
    };
};
