import { AbstractModel } from "./abstract-model";
import * as versions from "./version-checks";
import * as structures from "./structures";
import * as units from "./units";
import * as elements from "./elements";
import * as transport from "./transport-interfaces";
import { IObservableArray } from "mobx";
/**
 * The `instances` module contains various classes and functions
 * which revolve around creating/maintaining/updating actual model contents.
 */
/**
 * Generic type alias for `Mobservable.IObservableArray<T>`,
 * mainly to achieve some brevity in generated SDK code.
 */
export interface IList<T> extends IObservableArray<T> {
}
/**
 * Base class for enumerations in the meta model.
 * Literals of an enumeration are generated as public static constants of the generated sub class
 * which are instances of the generated sub class.
 */
export declare abstract class IEnum {

    protected qualifiedTsTypeName: string;
    versionInfo: versions.LifeCycle;
    constructor(_name: string, lifeCycleInfo: versions.ILifeCycle);
    readonly name: string;
    toString(): string;
    qualifiedTsLiteralName(): string;
    checkEnumVersion(metaModelVersion: versions.Version, includeWarnings: boolean): void;
}
export declare namespace instancehelpers {
    /**
     * Given some a (normalized) JSON representation of a unit,
     * creates an instance of the corresponding `unit.AbstractUnit` sub class (structural/model)
     * and populates that from the JSON.
     * Should only be called if this unit was not already in memory.
     */
    function abstractUnitJsonToInstance(model: AbstractModel, json: transport.IAbstractUnitJson, isPartial: boolean): units.AbstractUnit;
    /**
     * Given some a (normalized) JSON representation of a model element,
     * creates an instance of the corresponding `elements.Element`
     * and populates that from the JSON.
     * Will update existing elements if this element was created before.
     */
    function modelElementJsonToInstance(model: AbstractModel, unit: units.ModelUnit, container: elements.AbstractElement, json: transport.IAbstractElementJson, isPartial: boolean): elements.Element;
    /**
     * Creates a new element for a SDK user.
     */
    function createElement(owner: any, constructor: elements.IElementConstructor, parentPropName?: string, parentPropIsList?: boolean): any;
    /**
     * Creates a new unit for a SDK user.
     */
    function createUnit(container: units.IStructuralUnit, constructor: units.IAbstractUnitConstructor): any;
    /**
     * Type -> class (the constructor function, technically) lookup, e.g. "DomainModels$Entity" -> DomainModels.Entity
     */
    function lookupClass(qualifiedTypeName: string, classes: any): any;
    function structureAffectsQualifiedNames(structure: structures.Structure): boolean;
}
