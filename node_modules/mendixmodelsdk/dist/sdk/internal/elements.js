"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var structures = require("./structures");
/**
 * See {@link IAbstractElement}.
 */
var AbstractElement = (function (_super) {
    __extends(AbstractElement, _super);
    function AbstractElement(model, typeName, id, isPartial, container) {
        var _this = _super.call(this, model, typeName, id, isPartial, container) || this;
        /*
         * In-memory by-id or by-name references from other elements to this element.
         * These are the objects that need to be informed when names changes occur, or if the element is deleted.
         */
        _this._backReferences = [];
        return _this;
    }
    Object.defineProperty(AbstractElement.prototype, "isLoaded", {
        /**
         * Checks whether all properties are available at the moment
         *  - if false, a load is required to access these properties.
         */
        get: function () {
            return this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractElement.prototype, "qualifiedName", {
        /**
         * Calculates the fully qualified name of this element,
         * by visiting all parents that have $isNamespace set to `true`.
         */
        get: function () {
            var parts = [];
            var element = this.container;
            while (element) {
                if (element._declaredAsNamespace) {
                    parts.unshift(element["name"]);
                }
                element = element.container;
            }
            parts.push(this["name"]);
            return parts.filter(function (n) { return !!n; }).join(".");
        },
        enumerable: true,
        configurable: true
    });
    AbstractElement.prototype.load = function (callback, forceRefresh) {
        var _this = this;
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (!callback) {
            this._assertLoaded();
            return this;
        }
        this.unit._model.loadUnitById(this.unit.id, forceRefresh, function () {
            // this element should be loaded now!
            _this._assertLoaded();
            callback(_this);
        });
    };
    /**
     * updateElementsContainer recursively sets the unit to which this elements belong
     * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
     * an element is actually added to the tree (buy pushing / assigning it to some part property)
     */
    AbstractElement.prototype._updateElementsContainer = function (unit) {
        this.allProperties().forEach(function (property) {
            if (property instanceof properties.PartProperty || property instanceof properties.PartListProperty) {
                property.updateElementContainer(unit);
            }
            else if (property instanceof properties.ByIdReferenceProperty) {
                property.updateElementContainer();
            }
        });
    };
    /**
     * Return true if this is an abstractElement that might be referred to by some other element.
     * If true, this element is maintained in the qualifiedNamesCache
     */
    AbstractElement.prototype._isByNameReferrable = function () {
        return false;
    };
    /**
     * Adds a back reference, i.e. a reference pointing to us,
     * which needs to be informed of changes to this element (including deletion).
     */
    AbstractElement.prototype._addBackReference = function (ref) {
        this._backReferences.push(ref);
    };
    /**
     * Removes the given back reference.
     */
    AbstractElement.prototype._removeBackReference = function (ref) {
        var idx = this._backReferences.indexOf(ref);
        if (idx >= 0) {
            this._backReferences.splice(idx, 1);
        }
    };
    AbstractElement.prototype.getBackReferences = function () {
        return this._backReferences;
    };
    AbstractElement.prototype.clearBackReferences = function () {
        this._backReferences.forEach(function (reference) { return reference.unresolve(); });
    };
    AbstractElement.prototype.delete = function () {
        for (var i = this._backReferences.length - 1; i >= 0; i--) {
            var ref = this._backReferences[i];
            if (ref instanceof references.ByIdReference) {
                // by-id references? should apply cascading delete! See story 475769
                ref.owner.delete();
            }
            else if (ref instanceof references.ByNameReference) {
                // references by name should no longer resolve
                ref.unresolve();
            }
        }
        this._backReferences = [];
        // remove from qualifiedNamesCache
        this._model._qualifiedNameCache.removeStructureFromCache(this);
        // avoid roundtrip delete -> remove from parent -> delete etc, so enforce that an element is removed through its parent:
        if (this.container) {
            this.container._detachChild(this);
        }
        else {
            this._sendDeleteDelta();
            _super.prototype.delete.call(this);
        }
    };
    return AbstractElement;
}(structures.Structure));
exports.AbstractElement = AbstractElement;
var Element = (function (_super) {
    __extends(Element, _super);
    function Element(model, typeName, id, isPartial, unit, container) {
        var _this = _super.call(this, model, typeName, id, isPartial, container) || this;
        if (unit) {
            _this._updateElementsContainer(unit);
        }
        return _this;
    }
    Object.defineProperty(Element.prototype, "unit", {
        get: function () {
            return this._unit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "isLoaded", {
        /**
         * Checks whether all attributes are available ATM
         *  -  if false, a load is required to access these properties.
         */
        get: function () {
            return this._isNew || this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Element.prototype._updateElementsContainer = function (unit) {
        this._unit = unit;
        unit._elementsCache[this.id] = this;
        this._model = unit._model;
        _super.prototype._updateElementsContainer.call(this, unit);
    };
    /**
     * Sends the appropriate create delta to the server, and also sends all pending deltas,
     * after this element has been assigned to some parent.
     */
    Element.prototype._sendCreateDelta = function (owner, parentPropertyName) {
        var _this = this;
        // TODO: part of this needs to be pulled up to Structure
        if (this._isUpdating) {
            return;
        }
        if (!this._isNew) {
            throw new Error("Illegal state: cannot send create delta for pre-existing element");
        }
        this._assertLoaded();
        if (owner && owner._isNew) {
            // Parent is not known at the server yet, we need to try again later
            owner._pendingDeltasAfterCreate.push([this, parentPropertyName]);
            return;
        }
        if (owner.unit) {
            this._updateElementsContainer(owner.unit);
        }
        this.unit._model._sendDelta({
            parentId: owner.id,
            elementType: this.typeName,
            parentPropertyName: parentPropertyName,
            deltaType: deltas.DeltaTypes.CREATE_ELEMENT,
            unitId: this.unit.id,
            elementId: this.id
        });
        this._isNew = false;
        this._pendingDeltasAfterCreate.forEach(function (pending) {
            if (pending instanceof Array) {
                pending[0]._sendCreateDelta(_this, pending[1]);
            }
            else {
                var delta = pending;
                delta.unitId = _this.unit.id;
                _this.unit._model._sendDelta(delta);
            }
        });
    };
    /**
     * Sends the appropriate create delta to the server
     * after this element has been moved to a new parent.
     */
    Element.prototype._sendMoveDelta = function (newParent, newPropertyName, index) {
        if (this._isUpdating) {
            return;
        }
        this._assertLoaded();
        var moveDelta = {
            unitId: (this.unit && this.unit.id),
            elementId: this.id,
            deltaType: deltas.DeltaTypes.MOVE_ELEMENT,
            newParentId: newParent.id,
            newParentPropertyName: newPropertyName
        };
        if (index !== undefined) {
            moveDelta.newIndex = index;
        }
        // Tricky: move might happen to a new element, for which creating we need to wait before sending this delta.
        if (newParent._isNew) {
            // TODO: invariant: should be in transaction to prevent data loss!
            // Otherwise it is possible that the move is only done in the next delta batch
            // and the element can not be found anymore as the detachedElements cache is gone.
            // (Or persist detached elements?)
            newParent._pendingDeltasAfterCreate.push(moveDelta);
        }
        else {
            if (this._isNew) {
                this._pendingDeltasAfterCreate.push(moveDelta);
            }
            else {
                this.unit._model._sendDelta(moveDelta);
            }
        }
    };
    Element.prototype.deepCopyInto = function (newParent, targetPropertyName) {
        if (!this.isLoaded) {
            throw new Error("Only loaded elements can be copied. Use .load() first");
        }
        return _super.prototype.deepCopyInto.call(this, newParent, targetPropertyName);
    };
    return Element;
}(AbstractElement));
exports.Element = Element;
var references = require("./references");
var deltas = require("./deltas");
var properties = require("./properties");
